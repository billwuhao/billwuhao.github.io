<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>吴明文的笔记文章集</title>
    <url>/zhuye-5bb44329fc7e/</url>
    <content><![CDATA[<p><a href="https://billwuhao.com/2020/08/08/zhuye/#more" title="诗和远方都在脚下"><img src="/images/dbj.jpg"></a></p>
<br>

<h1 id="⚫"><a href="#⚫" class="headerlink" title="⚫ "></a>⚫ <a href="/data/data-432d96069dc0/" title="&lt;font color&#x3D;#AE6011 &gt;数据分析基础工具，方法与实践&lt;&#x2F;font&gt;"><font color=#AE6011 >数据分析基础工具，方法与实践</font></a></h1><hr>
<h1 id="⚫-1"><a href="#⚫-1" class="headerlink" title="⚫ "></a>⚫ <a href="/poetry/poetry-272f7965d2fe/" title="&lt;font color&#x3D;#AE6011 &gt;野诗三百首&lt;&#x2F;font&gt;"><font color=#AE6011 >野诗三百首</font></a></h1><hr>
<h1 id="⚫-2"><a href="#⚫-2" class="headerlink" title="⚫ "></a>⚫ <a href="/principle/principle-f0e37204b1fa/" title="&lt;font color&#x3D;#AE6011 &gt;自然原理，社会原则和心理知识汇编&lt;&#x2F;font&gt;"><font color=#AE6011 >自然原理，社会原则和心理知识汇编</font></a></h1><hr>
<h1 id="⚫-3"><a href="#⚫-3" class="headerlink" title="⚫ "></a>⚫ <a href="/Markdown-d39685381dd6/" title="&lt;font color&#x3D;#AE6011 &gt;实用 Markdown 语法汇总&lt;&#x2F;font&gt;"><font color=#AE6011 >实用 Markdown 语法汇总</font></a></h1><hr>
<h1 id="⚫-4"><a href="#⚫-4" class="headerlink" title="⚫ "></a>⚫ <a href="/other/other-a63373b9752b/" title="&lt;font color&#x3D;#AE6011 &gt;其他文章&lt;&#x2F;font&gt;"><font color=#AE6011 >其他文章</font></a></h1>]]></content>
  </entry>
  <entry>
    <title>数据分析基础工具，方法与实践</title>
    <url>/data/data-432d96069dc0/</url>
    <content><![CDATA[<p><a href="https://billwuhao.com/2020/08/08/zhuye/#more" title="诗和远方都在脚下"><img src="/images/dbj.jpg"></a></p>
<br>

<blockquote>
<p>该笔记主要内容是数据分析工具应用层面的基础知识，基础的统计学方法以及综合实践练习。</p>
</blockquote>
<h1 id="一，Python-及其科学计算库"><a href="#一，Python-及其科学计算库" class="headerlink" title="一，Python 及其科学计算库"></a>一，Python 及其科学计算库</h1><h2 id="⚫-Python"><a href="#⚫-Python" class="headerlink" title="⚫ Python"></a>⚫ Python</h2><h3 id=""><a href="#" class="headerlink" title=""></a><a href="/data/python1-8843db772140/" title="&lt;font color&#x3D;#AE6011 &gt;认识 python&lt;&#x2F;font&gt;"><font color=#AE6011 >认识 python</font></a></h3><h3 id="-1"><a href="#-1" class="headerlink" title=""></a><a href="/data/python2-264a8e0ab5f1/" title="&lt;font color&#x3D;#AE6011 &gt;数据容器&lt;&#x2F;font&gt;"><font color=#AE6011 >数据容器</font></a></h3><h3 id="-2"><a href="#-2" class="headerlink" title=""></a><a href="/data/python3-2dee073565c6/" title="&lt;font color&#x3D;#AE6011 &gt;函数和面向对象&lt;&#x2F;font&gt;"><font color=#AE6011 >函数和面向对象</font></a></h3><h3 id="-3"><a href="#-3" class="headerlink" title=""></a><a href="/data/python4-8e8770a6503f/" title="&lt;font color&#x3D;#AE6011 &gt;异常, 模块和包, 以及文件读写&lt;&#x2F;font&gt;"><font color=#AE6011 >异常, 模块和包, 以及文件读写</font></a></h3><h3 id="-4"><a href="#-4" class="headerlink" title=""></a><a href="/data/regex-95e69c7b339c/" title="&lt;font color&#x3D;#AE6011 &gt;通俗易懂正则表达式&lt;&#x2F;font&gt;"><font color=#AE6011 >通俗易懂正则表达式</font></a></h3><h2 id="⚫"><a href="#⚫" class="headerlink" title="⚫ "></a>⚫ <a href="/data/matplotlib-bfa2528613f9/" title="&lt;font color&#x3D;#AE6011 &gt;Matplotlib&lt;&#x2F;font&gt;"><font color=#AE6011 >Matplotlib</font></a></h2><h2 id="⚫-Numpy"><a href="#⚫-Numpy" class="headerlink" title="⚫ Numpy"></a>⚫ Numpy</h2><h3 id="-5"><a href="#-5" class="headerlink" title=""></a><a href="/data/numpy1-caa388146ce1/" title="&lt;font color&#x3D;#AE6011 &gt;ndarray 对象介绍及切片操作&lt;&#x2F;font&gt;"><font color=#AE6011 >ndarray 对象介绍及切片操作</font></a></h3><h3 id="-6"><a href="#-6" class="headerlink" title=""></a><a href="/data/numpy2-e9e4c18c3431/" title="&lt;font color&#x3D;#AE6011 &gt;ndarray 对象的运算，方法及创建&lt;&#x2F;font&gt;"><font color=#AE6011 >ndarray 对象的运算，方法及创建</font></a></h3><h3 id="-7"><a href="#-7" class="headerlink" title=""></a><a href="/data/numpy3-2300149490ed/" title="&lt;font color&#x3D;#AE6011 &gt;常用的通函数及 API&lt;&#x2F;font&gt;"><font color=#AE6011 >常用的通函数及 API</font></a></h3><h2 id="⚫-Pandas"><a href="#⚫-Pandas" class="headerlink" title="⚫ Pandas"></a>⚫ Pandas</h2><h3 id="-8"><a href="#-8" class="headerlink" title=""></a><a href="/data/pandas1-4798b1c5fd91/" title="&lt;font color&#x3D;#AE6011 &gt;数据结构的操作，处理与计算&lt;&#x2F;font&gt;"><font color=#AE6011 >数据结构的操作，处理与计算</font></a></h3><h3 id="-9"><a href="#-9" class="headerlink" title=""></a><a href="/data/pandas2-467dbcb23e38/" title="&lt;font color&#x3D;#AE6011 &gt;处理和计算函数&lt;&#x2F;font&gt;"><font color=#AE6011 >处理和计算函数</font></a></h3><h3 id="-10"><a href="#-10" class="headerlink" title=""></a><a href="/data/pandas3-bd0cfff75a2b/" title="&lt;font color&#x3D;#AE6011 &gt;时间序列，导入导出与可视化&lt;&#x2F;font&gt;"><font color=#AE6011 >时间序列，导入导出与可视化</font></a></h3><h1 id="二，SQL"><a href="#二，SQL" class="headerlink" title="二，SQL"></a>二，SQL</h1><h2 id="⚫-MySQL"><a href="#⚫-MySQL" class="headerlink" title="⚫ MySQL"></a>⚫ MySQL</h2><h3 id="-11"><a href="#-11" class="headerlink" title=""></a><a href="/data/mysql1-a1e1ed8d89a7/" title="&lt;font color&#x3D;#AE6011 &gt;基本介绍和单表操作&lt;&#x2F;font&gt;"><font color=#AE6011 >基本介绍和单表操作</font></a></h3><h3 id="-12"><a href="#-12" class="headerlink" title=""></a><a href="/data/mysql2-8fd5fec702bb/" title="&lt;font color&#x3D;#AE6011 &gt;多表基础操作&lt;&#x2F;font&gt;"><font color=#AE6011 >多表基础操作</font></a></h3><h3 id="-13"><a href="#-13" class="headerlink" title=""></a><a href="/data/mysql3-8dca988d8207/" title="&lt;font color&#x3D;#AE6011 &gt;常用函数&lt;&#x2F;font&gt;"><font color=#AE6011 >常用函数</font></a></h3><h3 id="-14"><a href="#-14" class="headerlink" title=""></a><a href="/data/mysql4-95ef69379b8e/" title="&lt;font color&#x3D;#AE6011 &gt;索引，视图和三范式&lt;&#x2F;font&gt;"><font color=#AE6011 >索引，视图和三范式</font></a></h3><h2 id="⚫-HiveQL"><a href="#⚫-HiveQL" class="headerlink" title="⚫ HiveQL"></a>⚫ HiveQL</h2><h3 id="-15"><a href="#-15" class="headerlink" title=""></a><a href="/data/hadoop1-ce4bb28dd03c/" title="&lt;font color&#x3D;#AE6011 &gt;Hive 介绍和 HiveQL 库和表初探&lt;&#x2F;font&gt;"><font color=#AE6011 >Hive 介绍和 HiveQL 库和表初探</font></a></h3><h3 id="-16"><a href="#-16" class="headerlink" title=""></a><a href="/data/hadoop2-8198ce8f5fce/" title="&lt;font color&#x3D;#AE6011 &gt;HiveQL 表查询&lt;&#x2F;font&gt;"><font color=#AE6011 >HiveQL 表查询</font></a></h3><h3 id="-17"><a href="#-17" class="headerlink" title=""></a><a href="/data/hadoop3-743e8abb1c1c/" title="&lt;font color&#x3D;#AE6011 &gt;HiveQL 窗口函数和常用优化技巧&lt;&#x2F;font&gt;"><font color=#AE6011 >HiveQL 窗口函数和常用优化技巧</font></a></h3><h1 id="三，统计学方法"><a href="#三，统计学方法" class="headerlink" title="三，统计学方法"></a>三，统计学方法</h1><h2 id="⚫-1"><a href="#⚫-1" class="headerlink" title="⚫ "></a>⚫ <a href="/data/statistics1-24ca6e122f33/" title="&lt;font color&#x3D;#AE6011 &gt;描述统计&lt;&#x2F;font&gt;"><font color=#AE6011 >描述统计</font></a></h2><h2 id="⚫-2"><a href="#⚫-2" class="headerlink" title="⚫ "></a>⚫ <a href="/data/statistics2-136ca00916f8/" title="&lt;font color&#x3D;#AE6011 &gt;推断统计&lt;&#x2F;font&gt;"><font color=#AE6011 >推断统计</font></a></h2><h2 id="⚫-3"><a href="#⚫-3" class="headerlink" title="⚫ "></a>⚫ <a href="/data/statistics3-1967a7845ced/" title="&lt;font color&#x3D;#AE6011 &gt;线性回归&lt;&#x2F;font&gt;"><font color=#AE6011 >线性回归</font></a></h2><h2 id="⚫-4"><a href="#⚫-4" class="headerlink" title="⚫ "></a>⚫ <a href="/data/statistics4-344a69d01fea/" title="&lt;font color&#x3D;#AE6011 &gt;逻辑回归&lt;&#x2F;font&gt;"><font color=#AE6011 >逻辑回归</font></a></h2><h2 id="⚫-5"><a href="#⚫-5" class="headerlink" title="⚫ "></a>⚫ <a href="/data/statistics5-2abb7ab7c911/" title="&lt;font color&#x3D;#AE6011 &gt;分类模型评估&lt;&#x2F;font&gt;"><font color=#AE6011 >分类模型评估</font></a></h2><h2 id="⚫-6"><a href="#⚫-6" class="headerlink" title="⚫ "></a>⚫ <a href="/data/statistics6-a328029dd5af/" title="&lt;font color&#x3D;#AE6011 &gt;KNN 算法&lt;&#x2F;font&gt;"><font color=#AE6011 >KNN 算法</font></a></h2><h2 id="⚫-7"><a href="#⚫-7" class="headerlink" title="⚫ "></a>⚫ <a href="/data/statistics7-09facbbd1b27/" title="&lt;font color&#x3D;#AE6011 &gt;朴素贝叶斯&lt;&#x2F;font&gt;"><font color=#AE6011 >朴素贝叶斯</font></a></h2><h2 id="⚫-8"><a href="#⚫-8" class="headerlink" title="⚫ "></a>⚫ <a href="/data/statistics8-32b3a23ba9e8/" title="&lt;font color&#x3D;#AE6011 &gt;决策树&lt;&#x2F;font&gt;"><font color=#AE6011 >决策树</font></a></h2><h2 id="⚫-9"><a href="#⚫-9" class="headerlink" title="⚫ "></a>⚫ <a href="/data/statistics9-37ff3fbe9723/" title="&lt;font color&#x3D;#AE6011 &gt;K-Means 算法&lt;&#x2F;font&gt;"><font color=#AE6011 >K-Means 算法</font></a></h2><h1 id="-18"><a href="#-18" class="headerlink" title=""></a><a href="/data/case-ede78215895b/" title="&lt;font color&#x3D;#AE6011 &gt;四，综合实践练习&lt;&#x2F;font&gt;"><font color=#AE6011 >四，综合实践练习</font></a></h1>]]></content>
  </entry>
  <entry>
    <title>自然原理，社会原则和心理知识汇编</title>
    <url>/principle/principle-f0e37204b1fa/</url>
    <content><![CDATA[<p><a href="https://billwuhao.com/2020/08/08/zhuye/#more" title="诗和远方都在脚下"><img src="/images/dbj.jpg"></a></p>
<h2 id="自然原理"><a href="#自然原理" class="headerlink" title="自然原理"></a>自然原理</h2><h3 id="⚫"><a href="#⚫" class="headerlink" title="⚫ "></a>⚫ <a href="/principle/space-4e1b661cc9fa/" title="&lt;font color&#x3D;#AE6011 &gt;四维空间长什么样?&lt;&#x2F;font&gt;"><font color=#AE6011 >四维空间长什么样?</font></a></h3><h3 id="⚫-1"><a href="#⚫-1" class="headerlink" title="⚫ "></a>⚫ <a href="/principle/Fibonacci-sequence-golden-section-8a231ce05614/" title="&lt;font color&#x3D;#AE6011 &gt;黄金分割&lt;&#x2F;font&gt;"><font color=#AE6011 >黄金分割</font></a></h3><br>

<h2 id="社会原则"><a href="#社会原则" class="headerlink" title="社会原则"></a>社会原则</h2><h3 id="⚫-2"><a href="#⚫-2" class="headerlink" title="⚫ "></a>⚫ <a href="/principle/37percent-principle-72142339141f/" title="&lt;font color&#x3D;#AE6011 &gt;百分之三十七原则--选择的策略&lt;&#x2F;font&gt;"><font color=#AE6011 >百分之三十七原则--选择的策略</font></a></h3><br>

<h2 id="心理知识"><a href="#心理知识" class="headerlink" title="心理知识"></a>心理知识</h2><h3 id="⚫-3"><a href="#⚫-3" class="headerlink" title="⚫ "></a>⚫ <a href="/principle/Frog_effect-efcc6f353da2/" title="&lt;font color&#x3D;#AE6011 &gt;温水煮青蛙&lt;&#x2F;font&gt;"><font color=#AE6011 >温水煮青蛙</font></a></h3><br>

<br>]]></content>
  </entry>
  <entry>
    <title>其他文章</title>
    <url>/other/other-a63373b9752b/</url>
    <content><![CDATA[<p><a href="https://billwuhao.com/2020/08/08/zhuye/#more" title="诗和远方都在脚下"><img src="/images/dbj.jpg"></a></p>
<p>记录好玩的折腾，问题的解决，学习和生活的有趣发现等。</p>
<h2 id="⚫"><a href="#⚫" class="headerlink" title="⚫ "></a>⚫ <a href="/other/Build-a-blog-ed67779a8537/" title="&lt;font color&#x3D;#AE6011 &gt;腾讯&#x2F;阿里云服务器 + Hexo 部署个人网站&lt;&#x2F;font&gt;"><font color=#AE6011 >腾讯/阿里云服务器 + Hexo 部署个人网站</font></a></h2><h2 id="⚫-1"><a href="#⚫-1" class="headerlink" title="⚫ "></a>⚫ <a href="/other/Read_only_official_documents-f61253601646/" title="&lt;font color&#x3D;#AE6011 &gt;学编程，为什么一定要读官方文档？&lt;&#x2F;font&gt;"><font color=#AE6011 >学编程，为什么一定要读官方文档？</font></a></h2><br>

<br>]]></content>
  </entry>
  <entry>
    <title>学编程，为什么一定要读官方文档？</title>
    <url>/other/Read_only_official_documents-f61253601646/</url>
    <content><![CDATA[<p>对零基础的小白，读一两本大家公认的入门好书，是明智且必要的。不会一上来就打击积极性，学习由浅入深有成就感，进一步深入学习的动力更足。</p>
<p>入门之后，真的一定要读官方文档，并且只读官方文档。</p>
<p><strong>不读官方文档吃大亏：</strong></p>
<ol>
<li><p>打开官方文档，浏览一下各个模块的各个目录结构，了解整体框架，你都会大有收获。学习重点，学习方向，都会逐渐清晰起来。</p>
</li>
<li><p>学编程其实就是学一门语言，而官方文档对建立清晰且准确的概念及其概念之间的关联无出其右。我相信通过建立清晰且准确的概念，理清事物内在逻辑，才能达到运用自如，学一门语言更是如此，不然说句话都说不清楚。初学 python 时，对各个基础概念，真的是 “剪不断，理越乱”，大脑一团浆糊，现在回头看看自己当初的学习笔记，不忍直视。</p>
</li>
<li><p>任何一本书无法做的面面俱到，只有官方文档最准确，最全面。python 举几个令人惊喜的小例子：</p>
</li>
</ol>
<ul>
<li>python 是强类型语言，不同类型之间不能进行运算是吧。为什么 False + 1 可以运算？</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">print(<span class="built_in">type</span>(<span class="literal">False</span>),<span class="built_in">type</span>(<span class="number">1</span>))</span><br><span class="line"><span class="literal">False</span> + <span class="number">1</span></span><br></pre></td></tr></table></figure>

<pre><code>&lt;class &#39;bool&#39;&gt; &lt;class &#39;int&#39;&gt;

1</code></pre>
<p>你网上搜索，是很难找到答案的，官方文档的答案清晰明了：<strong>布尔值属于整数的子类型。</strong></p>
<ul>
<li>一个非常大的整数，想要让它更易读，例如 <code>1234567890</code>，怎么把它三位三位分开？</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>_234_567_890</span><br></pre></td></tr></table></figure>

<pre><code>1234567890</code></pre>
<ul>
<li>一个非常长的正则表达式，整体不能逗号分开，也不能用反斜杠 <code>\</code> 截断，怎么办？</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line">t = <span class="string">&#x27;22:20:02&#x27;</span></span><br><span class="line">r = (<span class="string">r&#x27;^(0[0-9]|1[0-9]|2[0-3]|[0-9])\:&#x27;</span></span><br><span class="line">     <span class="string">r&#x27;(0[0-9]|1[0-9]|2[0-9]|3[0-9]|4[0-9]|5[0-9]|[0-9])\:&#x27;</span></span><br><span class="line">     <span class="string">r&#x27;(0[0-9]|1[0-9]|2[0-9]|3[0-9]|4[0-9]|5[0-9]|[0-9])$&#x27;</span>)</span><br><span class="line">re.match(r, t).groups()</span><br></pre></td></tr></table></figure>

<pre><code>(&#39;22&#39;, &#39;20&#39;, &#39;02&#39;)</code></pre>
<p>神不神奇，惊不惊喜，官方文档里藏着太多你其他地方看不到，也查不到的<strong>秘密</strong>。更何况，你想要比绝大多数人更有底气，除了啃别人不愿啃的官方文档，还有更好的选择吗？</p>
<ol start="4">
<li>科技进步飞速，技术文档日新月异，时效性非常强，不看官方文档，你网上搜出来的东西，千篇一律，甚至很多是过时的，折腾半天也解决不了问题，费时费命。想走捷径，反其道而行之，笨办法啃官方文档反而是捷径。</li>
</ol>
<p><strong>只通过查阅官方文档解决问题</strong></p>
<p>很多大神的建议：入门之后，一定要读官方文档，掌握一手资料，遇到问题，只通过查阅官方文档解决。然后反反复复查阅很多遍，终会烂熟于胸，学好编程，水到渠成。因为你曾经遇到的所有问题，熟读官方文档之后，都会在字里行间显现出来，而且你每一次突破或飞跃，都深藏在对官方文档逐字逐句的理解之中。</p>
<p>最后分享一下我的 python 入门书籍<a href="https://xue.cn/visitor/reader?bookId=1&mode=visitor&path=the-craft-of-selfteaching/Part.1.G.The-Python-Tutorial-local.ipynb">《自学是门手艺》</a>。“不听老人言，吃亏在眼前”，年过而立之后深有感触，书中很多建议真的是高瞻远瞩，又拳拳到肉。高人指点，步步为营。</p>
<p>一个刚入门的编程小白的心得和感受，与大家共勉。</p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>建站</tag>
      </tags>
  </entry>
  <entry>
    <title>野诗三百首</title>
    <url>/poetry/poetry-272f7965d2fe/</url>
    <content><![CDATA[<p><a href="https://billwuhao.com/2020/08/08/zhuye/#more" title="诗和远方都在脚下"><img src="/images/dbj.jpg"></a></p>
<blockquote>
<p>梦想, 美好, 困苦, 绝望, 轮回, 迷途, 沉思 … …，可爱，可悲，可泣，可怜，可敬… …</p>
</blockquote>
<p>每一首诗都像一幅旧照片, 虽然拍的丑, 还是整理留作纪念吧。</p>
<hr>
<h2 id="⚫"><a href="#⚫" class="headerlink" title="⚫ "></a>⚫ <a href="/poetry/poetry1-6891ece0699b/" title="&lt;font color&#x3D;#AE6011 &gt;我要发光&lt;&#x2F;font&gt;"><font color=#AE6011 >我要发光</font></a></h2><h2 id="⚫-1"><a href="#⚫-1" class="headerlink" title="⚫ "></a>⚫ <a href="/poetry/poetry2-4572e9824c44/" title="&lt;font color&#x3D;#AE6011 &gt;念奴娇 · 笼鸟归林&lt;&#x2F;font&gt;"><font color=#AE6011 >念奴娇 · 笼鸟归林</font></a></h2><h2 id="⚫-2"><a href="#⚫-2" class="headerlink" title="⚫ "></a>⚫ <a href="/poetry/poetry3-25f8487f1fd1/" title="&lt;font color&#x3D;#AE6011 &gt;离人泪&lt;&#x2F;font&gt;"><font color=#AE6011 >离人泪</font></a></h2><h2 id="⚫-3"><a href="#⚫-3" class="headerlink" title="⚫ "></a>⚫ <a href="/poetry/poetry4-43f4e440b335/" title="&lt;font color&#x3D;#AE6011 &gt;心门掩·叹息&lt;&#x2F;font&gt;"><font color=#AE6011 >心门掩·叹息</font></a></h2><h2 id="⚫-4"><a href="#⚫-4" class="headerlink" title="⚫ "></a>⚫ <a href="/poetry/poetry5-853893c97603/" title="&lt;font color&#x3D;#AE6011 &gt;梦境狂·落魂&lt;&#x2F;font&gt;"><font color=#AE6011 >梦境狂·落魂</font></a></h2><h2 id="⚫-5"><a href="#⚫-5" class="headerlink" title="⚫ "></a>⚫ <a href="/poetry/poetry6-70b29e6d546e/" title="&lt;font color&#x3D;#AE6011 &gt;苏幕遮·早行怀父&lt;&#x2F;font&gt;"><font color=#AE6011 >苏幕遮·早行怀父</font></a></h2><h2 id="⚫-6"><a href="#⚫-6" class="headerlink" title="⚫ "></a>⚫ <a href="/poetry/poetry7-caa908281f62/" title="&lt;font color&#x3D;#AE6011 &gt;自我寻&lt;&#x2F;font&gt;"><font color=#AE6011 >自我寻</font></a></h2><h2 id="⚫-7"><a href="#⚫-7" class="headerlink" title="⚫ "></a>⚫ <a href="/poetry/poetry8-7d8edfebf87a/" title="&lt;font color&#x3D;#AE6011 &gt;树叶&lt;&#x2F;font&gt;"><font color=#AE6011 >树叶</font></a></h2><h2 id="⚫-8"><a href="#⚫-8" class="headerlink" title="⚫ "></a>⚫ <a href="/poetry/poetry9-7b84797e4f72/" title="&lt;font color&#x3D;#AE6011 &gt;给你自由&lt;&#x2F;font&gt;"><font color=#AE6011 >给你自由</font></a></h2><h2 id="⚫-9"><a href="#⚫-9" class="headerlink" title="⚫ "></a>⚫ <a href="/poetry/poetry10-7893faf46ede/" title="&lt;font color&#x3D;#AE6011 &gt;想象&lt;&#x2F;font&gt;"><font color=#AE6011 >想象</font></a></h2><h2 id="⚫-10"><a href="#⚫-10" class="headerlink" title="⚫ "></a>⚫ <a href="/poetry/poetry11-4707210a4a03/" title="&lt;font color&#x3D;#AE6011 &gt;寒光&lt;&#x2F;font&gt;"><font color=#AE6011 >寒光</font></a></h2><h2 id="⚫-11"><a href="#⚫-11" class="headerlink" title="⚫ "></a>⚫ <a href="/poetry/poetry12-c537b3354e3b/" title="&lt;font color&#x3D;#AE6011 &gt;贫瘠的土地&lt;&#x2F;font&gt;"><font color=#AE6011 >贫瘠的土地</font></a></h2><h2 id="⚫-12"><a href="#⚫-12" class="headerlink" title="⚫ "></a>⚫ <a href="/poetry/poetry13-dbff4b29c3e7/" title="&lt;font color&#x3D;#AE6011 &gt;我愿沉醉&lt;&#x2F;font&gt;"><font color=#AE6011 >我愿沉醉</font></a></h2><h2 id="⚫-13"><a href="#⚫-13" class="headerlink" title="⚫ "></a>⚫ <a href="/poetry/poetry14-22ae98e03e61/" title="&lt;font color&#x3D;#AE6011 &gt;年轻的心&lt;&#x2F;font&gt;"><font color=#AE6011 >年轻的心</font></a></h2><h2 id="⚫-14"><a href="#⚫-14" class="headerlink" title="⚫ "></a>⚫ <a href="/poetry/poetry15-403e9f7cd36e/" title="&lt;font color&#x3D;#AE6011 &gt;不会伤痛&lt;&#x2F;font&gt;"><font color=#AE6011 >不会伤痛</font></a></h2><h2 id="⚫-15"><a href="#⚫-15" class="headerlink" title="⚫ "></a>⚫ <a href="/poetry/poetry16-8bb2e1333128/" title="&lt;font color&#x3D;#AE6011 &gt;我好恨&lt;&#x2F;font&gt;"><font color=#AE6011 >我好恨</font></a></h2><h2 id="⚫-16"><a href="#⚫-16" class="headerlink" title="⚫ "></a>⚫ <a href="/poetry/poetry17-a14d0b273d7e/" title="&lt;font color&#x3D;#AE6011 &gt;上帝为我作证&lt;&#x2F;font&gt;"><font color=#AE6011 >上帝为我作证</font></a></h2><h2 id="⚫-17"><a href="#⚫-17" class="headerlink" title="⚫ "></a>⚫ <a href="/poetry/poetry18-7992129799a1/" title="&lt;font color&#x3D;#AE6011 &gt;我怕过什么怕过谁？&lt;&#x2F;font&gt;"><font color=#AE6011 >我怕过什么怕过谁？</font></a></h2><h2 id="⚫-18"><a href="#⚫-18" class="headerlink" title="⚫ "></a>⚫ <a href="/poetry/poetry19-b7b1b01920a5/" title="&lt;font color&#x3D;#AE6011 &gt;孤独的时光&lt;&#x2F;font&gt;"><font color=#AE6011 >孤独的时光</font></a></h2><h2 id="⚫-19"><a href="#⚫-19" class="headerlink" title="⚫ "></a>⚫ <a href="/poetry/poetry20-a422ae85e047/" title="&lt;font color&#x3D;#AE6011 &gt;柳絮与桃花&lt;&#x2F;font&gt;"><font color=#AE6011 >柳絮与桃花</font></a></h2><h2 id="⚫-20"><a href="#⚫-20" class="headerlink" title="⚫ "></a>⚫ <a href="/poetry/poetry21-60bf59e74854/" title="&lt;font color&#x3D;#AE6011 &gt;晴天游林&lt;&#x2F;font&gt;"><font color=#AE6011 >晴天游林</font></a></h2><h2 id="⚫-21"><a href="#⚫-21" class="headerlink" title="⚫ "></a>⚫ <a href="/poetry/poetry22-8aa5fbf68780/" title="&lt;font color&#x3D;#AE6011 &gt;自家乡小曲&lt;&#x2F;font&gt;"><font color=#AE6011 >自家乡小曲</font></a></h2><h2 id="⚫-22"><a href="#⚫-22" class="headerlink" title="⚫ "></a>⚫ <a href="/poetry/poetry23-37b9f5f6f926/" title="&lt;font color&#x3D;#AE6011 &gt;活&lt;&#x2F;font&gt;"><font color=#AE6011 >活</font></a></h2><h2 id="⚫-23"><a href="#⚫-23" class="headerlink" title="⚫ "></a>⚫ <a href="/poetry/poetry24-150ba3490586/" title="&lt;font color&#x3D;#AE6011 &gt;无尽的快乐&lt;&#x2F;font&gt;"><font color=#AE6011 >无尽的快乐</font></a></h2><h2 id="⚫-24"><a href="#⚫-24" class="headerlink" title="⚫ "></a>⚫ <a href="/poetry/poetry25-ce52f91b675e/" title="&lt;font color&#x3D;#AE6011 &gt;时代九言&lt;&#x2F;font&gt;"><font color=#AE6011 >时代九言</font></a></h2><h2 id="⚫-25"><a href="#⚫-25" class="headerlink" title="⚫ "></a>⚫ <a href="/poetry/poetry26-a55cefdf613c/" title="&lt;font color&#x3D;#AE6011 &gt;以诗会友&lt;&#x2F;font&gt;"><font color=#AE6011 >以诗会友</font></a></h2><h2 id="⚫-26"><a href="#⚫-26" class="headerlink" title="⚫ "></a>⚫ <a href="/poetry/poetry27-70019d725910/" title="&lt;font color&#x3D;#AE6011 &gt;我是谁&lt;&#x2F;font&gt;"><font color=#AE6011 >我是谁</font></a></h2><h2 id="⚫-27"><a href="#⚫-27" class="headerlink" title="⚫ "></a>⚫ <a href="/poetry/poetry28-f318593f69f2/" title="&lt;font color&#x3D;#AE6011 &gt;实事求是&lt;&#x2F;font&gt;"><font color=#AE6011 >实事求是</font></a></h2><h2 id="⚫-28"><a href="#⚫-28" class="headerlink" title="⚫ "></a>⚫ <a href="/poetry/poetry29-fdaa29ec3bd0/" title="&lt;font color&#x3D;#AE6011 &gt;明心见性&lt;&#x2F;font&gt;"><font color=#AE6011 >明心见性</font></a></h2><h2 id="⚫-29"><a href="#⚫-29" class="headerlink" title="⚫ "></a>⚫ <a href="/poetry/poetry30-58d94c391e76/" title="&lt;font color&#x3D;#AE6011 &gt;过年&lt;&#x2F;font&gt;"><font color=#AE6011 >过年</font></a></h2><h2 id="⚫-30"><a href="#⚫-30" class="headerlink" title="⚫ "></a>⚫ <a href="/poetry/poetry31-88100919e038/" title="&lt;font color&#x3D;#AE6011 &gt;春节大黑山天乐&lt;&#x2F;font&gt;"><font color=#AE6011 >春节大黑山天乐</font></a></h2><h2 id="⚫-31"><a href="#⚫-31" class="headerlink" title="⚫ "></a>⚫ <a href="/poetry/poetry32-d59bcc93f946/" title="&lt;font color&#x3D;#AE6011 &gt;倒计时&lt;&#x2F;font&gt;"><font color=#AE6011 >倒计时</font></a></h2>]]></content>
      <categories>
        <category>白话野诗</category>
      </categories>
      <tags>
        <tag>诗词</tag>
      </tags>
  </entry>
  <entry>
    <title>我要发光</title>
    <url>/poetry/poetry1-6891ece0699b/</url>
    <content><![CDATA[<p><font color=#00BB00>&gt;<center></p>
<p>我要发光</p>
<p>年少闯江湖<br>奴役为理想<br>人生路上绝不彷徨<br>大海我的胸膛<br>拥抱着阳光<br>世界是我的家乡<br>上善若水，厚德载物<br>烙在我的心上<br>言行举止为助我发光<br>前进的方向良心来导航<br>你给我的讥笑和悲伤<br>抛在道路旁<br>捧着爱心为你指路疗伤<br>爬出世俗的城墙<br>观看着天亮<br>我爱的人啊<br>我在你心上  </p>
<p>&emsp;&emsp;&emsp;&emsp; 2007年 . 高三</p>
<p><img src="/images/mx.jpg">  </p>
</center></font>

]]></content>
      <categories>
        <category>白话野诗</category>
      </categories>
      <tags>
        <tag>诗词</tag>
      </tags>
  </entry>
  <entry>
    <title>想象</title>
    <url>/poetry/poetry10-7893faf46ede/</url>
    <content><![CDATA[<p><font color=#00BB00>&gt;<center></p>
<p>想象</p>
<p>天地这只大眼睛闭上了<br>星星是想象出来的<br>再次睁开眼<br>又是一天美好时光  </p>
<p>生活的眼睛闭上了<br>想象一些星星吧<br>再次睁开眼<br>又是前途光明  </p>
<p>&emsp;&emsp;&emsp;&emsp;2008</p>
</center></font>
]]></content>
      <categories>
        <category>白话野诗</category>
      </categories>
      <tags>
        <tag>诗词</tag>
      </tags>
  </entry>
  <entry>
    <title>寒光</title>
    <url>/poetry/poetry11-4707210a4a03/</url>
    <content><![CDATA[<p><font color=#00BB00>&gt;<center></p>
<p>寒光</p>
<p>月亮明媚的晚上<br>却感觉不到一丝丝温暖  </p>
<p>&emsp;&emsp;&emsp;&emsp;2008</p>
</center></font>
]]></content>
      <categories>
        <category>白话野诗</category>
      </categories>
      <tags>
        <tag>诗词</tag>
      </tags>
  </entry>
  <entry>
    <title>贫瘠的土地</title>
    <url>/poetry/poetry12-c537b3354e3b/</url>
    <content><![CDATA[<p><font color=#00BB00>&gt;<center></p>
<p>贫瘠的土地</p>
<p>这里有障碍<br>这里有悲哀<br>这里有没落<br>这里燃烧不出希望与光彩<br>我因不相信而苦恼  </p>
<p>有人说<br>这里出不了人才<br>那他一定很愚蠢<br>因为我的心跳还在  </p>
<p>&emsp;&emsp;&emsp;&emsp;2008</p>
</center></font>
]]></content>
      <categories>
        <category>白话野诗</category>
      </categories>
      <tags>
        <tag>诗词</tag>
      </tags>
  </entry>
  <entry>
    <title>年轻的心</title>
    <url>/poetry/poetry14-22ae98e03e61/</url>
    <content><![CDATA[<p><font color=#00BB00>&gt;<center></p>
<p>年轻的心</p>
<p>年轻的心如火<br>热烈地燃烧整个世界<br>年轻的心如水<br>温柔地沐浴美人<br>年轻的心如冰<br>残酷地冻结美丽的湖面<br>年轻的心如雾<br>朦胧地遮住远山<br>年轻的心如云缝中的斜阳<br>好奇地偷视每个角落  </p>
<p>&emsp;&emsp;&emsp;&emsp;2008</p>
</center></font>
]]></content>
      <categories>
        <category>白话野诗</category>
      </categories>
      <tags>
        <tag>诗词</tag>
      </tags>
  </entry>
  <entry>
    <title>我愿沉醉</title>
    <url>/poetry/poetry13-dbff4b29c3e7/</url>
    <content><![CDATA[<p><font color=#00BB00>&gt;<center></p>
<p>我愿沉醉</p>
<p>人生<br>每次清醒过来<br>再也找寻不到意义  </p>
<p>生活<br>每次醉在其中<br>甚至不知道自己是谁<br>还是那么冲动与美丽  </p>
<p>&emsp;&emsp;&emsp;&emsp;2008</p>
</center></font>
]]></content>
      <categories>
        <category>白话野诗</category>
      </categories>
      <tags>
        <tag>诗词</tag>
      </tags>
  </entry>
  <entry>
    <title>不会伤痛</title>
    <url>/poetry/poetry15-403e9f7cd36e/</url>
    <content><![CDATA[<p><font color=#00BB00>&gt;<center></p>
<p>不会伤痛</p>
<p>不想做太多的梦<br>有你存在就是成功<br>飘荡的世界<br>我也不会伤痛<br>轻狂是现实的光荣<br>捧着青春当落红<br>单纯的青春<br>吹满邪恶的风<br>谁说执着是傻瓜的奋勇<br>人间哪有三心二意的珍重<br>谁说不必在乎任何的行踪<br>那如何圆我们甜美的梦<br>埋下幸福快乐的种<br>挂上洁净彩虹<br>拍打着翅膀<br>飞舞在无边晴空<br>谁都应该相信<br>尊严还存在于生活中  </p>
<p>&emsp;&emsp;&emsp;&emsp;2008</p>
</center></font>
]]></content>
      <categories>
        <category>白话野诗</category>
      </categories>
      <tags>
        <tag>诗词</tag>
      </tags>
  </entry>
  <entry>
    <title>我好恨</title>
    <url>/poetry/poetry16-8bb2e1333128/</url>
    <content><![CDATA[<p><font color=#00BB00>&gt;<center></p>
<p>我好恨</p>
<p>我不相信缘分<br>但如何解释我痴情的心<br>我好恨<br>恨你邂逅的眼神<br>我知道爱难永恒<br>可如何还我单纯的心灵<br>我好恨<br>恨你无情的倩影<br>我这辈子注定要在恨泪中度过  </p>
<p>&emsp;&emsp;&emsp;&emsp;2008</p>
</center></font>
]]></content>
      <categories>
        <category>白话野诗</category>
      </categories>
      <tags>
        <tag>诗词</tag>
      </tags>
  </entry>
  <entry>
    <title>上帝为我作证</title>
    <url>/poetry/poetry17-a14d0b273d7e/</url>
    <content><![CDATA[<p><font color=#00BB00>&gt;<center></p>
<p>上帝为我作证</p>
<p>我决不让自己落后<br>作为摇摆不定的尾巴<br>我要做首<br>或者至少做身<br>哪怕吃苦、熬夜、疯狂······  </p>
<p>上帝为我作证<br>我决不让自己孤独<br>作为天边的孤鸿<br>我要飞向太阳<br>飞向自由的蓝天<br>哪怕朴素、执着、强求······</p>
<p>上帝为我作证<br>我决不让自己受饿、受辱<br>作为沿街乞讨的乞丐<br>我要自强、自爱、自尊<br>步入辉煌的殿堂<br>哪怕冒险、打拼、牺牲······</p>
<p>上帝为我作证<br>我会不顾一切<br>扯破衣服扑向我热爱的那片热土<br>并且绝不后悔······  </p>
<p>&emsp;&emsp;&emsp;&emsp;2009</p>
</center></font>
]]></content>
      <categories>
        <category>白话野诗</category>
      </categories>
      <tags>
        <tag>诗词</tag>
      </tags>
  </entry>
  <entry>
    <title>我怕过什么怕过谁？</title>
    <url>/poetry/poetry18-7992129799a1/</url>
    <content><![CDATA[<p><font color=#00BB00>&gt;<center></p>
<p>我怕过什么怕过谁？</p>
<p>我怕过什么怕过谁？<br>四次生死离别<br>三次从死神逃离<br>爬过万重山<br>涉过长江黄河水  </p>
<p>想吃我的赶早<br>因为我会膨胀<br>与日月同辉。。。。。。  </p>
<p>&emsp;&emsp;&emsp;&emsp;2010</p>
</center></font>
]]></content>
      <categories>
        <category>白话野诗</category>
      </categories>
      <tags>
        <tag>诗词</tag>
      </tags>
  </entry>
  <entry>
    <title>孤独的时光</title>
    <url>/poetry/poetry19-b7b1b01920a5/</url>
    <content><![CDATA[<p><font color=#00BB00>&gt;<center></p>
<p>孤独的时光</p>
<p>时光悄悄的来了<br>她偷偷看了你一眼<br>你在上网<br>游戏<br>聊天<br>她心痛<br>她惋惜<br>她揉着泪水轻轻离开<br>时光是孤独的<br>可是<br>原来<br>你比时光还孤独<br>时光多么爱你<br>你却从未发现   </p>
<p>&emsp;&emsp;&emsp;&emsp;2013</p>
</center></font>
]]></content>
      <categories>
        <category>白话野诗</category>
      </categories>
      <tags>
        <tag>诗词</tag>
      </tags>
  </entry>
  <entry>
    <title>念奴娇 · 笼鸟归林</title>
    <url>/poetry/poetry2-4572e9824c44/</url>
    <content><![CDATA[<p><font color=#00BB00>&gt;<center></p>
<p>念奴娇 · 笼鸟归林</p>
<p>千古江山，艳无比，迷醉纵情人儿。<br>城边一峰，青松照。<br>佛园曰凤山寺，匿蝉幽鸣，灵鼠戏枝，林动山更静。<br>登高远眺，胸怀云海景。<br>忆想书海鸟笼，绳索缚心愁。<br>无地倾发，血情冷冰。<br>每失意，魂飞魄散殆尽。<br>笼鸟归林，欣无羁纵情。<br>高歌云端，昂首哈哈，倒丛草喜吟。  </p>
<p>&emsp;&emsp;&emsp;&emsp; 2006年 . 高二</p>
</center></font>]]></content>
      <categories>
        <category>白话野诗</category>
      </categories>
      <tags>
        <tag>诗词</tag>
      </tags>
  </entry>
  <entry>
    <title>晴天游林</title>
    <url>/poetry/poetry21-60bf59e74854/</url>
    <content><![CDATA[<p><font color=#00BB00>&gt;<center></p>
<p>晴天游林</p>
<p>长松老木抱相护，不遮花儿向云天。<br>芳华碧空遥相望。此景何处觅人间？  </p>
<p>&emsp;&emsp;&emsp;&emsp;2015</p>
</center></font>
]]></content>
      <categories>
        <category>白话野诗</category>
      </categories>
      <tags>
        <tag>诗词</tag>
      </tags>
  </entry>
  <entry>
    <title>柳絮与桃花</title>
    <url>/poetry/poetry20-a422ae85e047/</url>
    <content><![CDATA[<p><font color=#00BB00>&gt;<center></p>
<p>柳絮与桃花  </p>
<p>癫狂柳絮随风去，轻薄桃花逐水流。<br>自由柳絮随风扬，烂漫桃花逐水荡。<br>圣洁柳絮扬风起，傲骨桃花荡水明。  </p>
<p>&emsp;&emsp;&emsp;&emsp;2014</p>
</center></font>
]]></content>
      <categories>
        <category>白话野诗</category>
      </categories>
      <tags>
        <tag>诗词</tag>
      </tags>
  </entry>
  <entry>
    <title>家乡小曲</title>
    <url>/poetry/poetry22-8aa5fbf68780/</url>
    <content><![CDATA[<p><font color=#00BB00>&gt;<center></p>
<p>家乡小曲  </p>
<p>一川东西两山开,<br>山头山尾村落排.<br>几句鸟唱惊绿起,<br>越关门窗越进来.  </p>
<p>&emsp;&emsp;&emsp;&emsp;2015</p>
</center></font>
]]></content>
      <categories>
        <category>白话野诗</category>
      </categories>
      <tags>
        <tag>诗词</tag>
      </tags>
  </entry>
  <entry>
    <title>活</title>
    <url>/poetry/poetry23-37b9f5f6f926/</url>
    <content><![CDATA[<p><font color=#00BB00>&gt;<center></p>
<p>活</p>
<p><em>上篇诗友作:</em><br>酒淡风清我自如,<br>沏杯茶水看沉浮.<br>熙熙攘攘天边事,<br>岁岁年年有作无.</p>
<p>酒浓风劲我自如,<br>激浊扬清主沉浮.<br>熙熙攘攘身边事,<br>年年岁岁作有无.  </p>
<p>&emsp;&emsp;&emsp;&emsp;2015末</p>
</center></font>
]]></content>
      <categories>
        <category>白话野诗</category>
      </categories>
      <tags>
        <tag>诗词</tag>
      </tags>
  </entry>
  <entry>
    <title>无尽的快乐</title>
    <url>/poetry/poetry24-150ba3490586/</url>
    <content><![CDATA[<p><font color=#00BB00>&gt;<center></p>
<p>无尽的快乐</p>
<p>我以为看到了海,<br>却曾想是一片茫茫沙漠.<br>快乐就像沙漏里的沙子,<br>翻过来就漏下去,<br>翻过来就漏下去.<br>多想拥有这片沙漠,<br>放到沙漏中,<br>让它在一生中慢慢漏完.  </p>
<p>&emsp;&emsp;&emsp;&emsp;2015</p>
</center></font>
]]></content>
      <categories>
        <category>白话野诗</category>
      </categories>
      <tags>
        <tag>诗词</tag>
      </tags>
  </entry>
  <entry>
    <title>时代九言</title>
    <url>/poetry/poetry25-ce52f91b675e/</url>
    <content><![CDATA[<p><font color=#00BB00>&gt;<center></p>
<p>时代九言</p>
<p>地铁公交匆匆挤工作,<br>微信抖音茫茫点人生.<br>迷与情纠缠工业科技,<br>人与物苟合奸情难分.  </p>
<p>&emsp;&emsp;&emsp;&emsp;15年作, 20年改</p>
</center></font>
]]></content>
      <categories>
        <category>白话野诗</category>
      </categories>
      <tags>
        <tag>诗词</tag>
      </tags>
  </entry>
  <entry>
    <title>以诗会友</title>
    <url>/poetry/poetry26-a55cefdf613c/</url>
    <content><![CDATA[<p><font color=#00BB00>&gt;<center></p>
<p>以诗会友</p>
<p>梅兰竹菊各自喻，<br>舞文弄墨贵无欺。<br>翻弄经阁相斗趣，<br>心心相惜引古今。  </p>
<p>&emsp;&emsp;&emsp;&emsp;2015</p>
</center></font>
]]></content>
      <categories>
        <category>白话野诗</category>
      </categories>
      <tags>
        <tag>诗词</tag>
      </tags>
  </entry>
  <entry>
    <title>我是谁</title>
    <url>/poetry/poetry27-70019d725910/</url>
    <content><![CDATA[<p><font color=#00BB00>&gt;<center></p>
<p>我是谁 </p>
<p>天地生万物，吾本是尘埃。<br>尘埃落入土，润物春自来。<br>春来春还去，春去春又生。<br>春处即我处，无我处处春。  </p>
<p>&emsp;&emsp;&emsp;&emsp;2015</p>
</center></font>
]]></content>
      <categories>
        <category>白话野诗</category>
      </categories>
      <tags>
        <tag>诗词</tag>
      </tags>
  </entry>
  <entry>
    <title>实事求是</title>
    <url>/poetry/poetry28-f318593f69f2/</url>
    <content><![CDATA[<p><font color=#00BB00>&gt;<center></p>
<p>实事求是</p>
<p>应勤富贵路，穷研诗哲经。<br>自诩如来是，酸气弄平生。<br>莫寻生死道，大志笑乾坤，<br>待到临终时，如来即自身。</p>
<p><em>中篇诗友作:</em><br>自古富贵路，都在诗哲经。<br>如来何必是，青灯了平生。<br>生死各有道，立志向乾坤。<br>歧路多无为，不负如来身。</p>
<p>富贵不见路，诗哲亦无经。<br>如来又如去，本无如来身。<br>生死自然道，何须向乾坤。<br>无为无不为，为为但求真。  </p>
<p>&emsp;&emsp;&emsp;&emsp;2015</p>
</center></font>
]]></content>
      <categories>
        <category>白话野诗</category>
      </categories>
      <tags>
        <tag>诗词</tag>
      </tags>
  </entry>
  <entry>
    <title>明心见性</title>
    <url>/poetry/poetry29-fdaa29ec3bd0/</url>
    <content><![CDATA[<p><font color=#00BB00>&gt;<center></p>
<p>明心见性</p>
<p>拉长时空隧道，截断历史变迁。<br>激扬社会道动，感应人情深浅。<br>剥离万象森罗，坐拥天地规律。<br>空寂物我存在，全部如实观照。  </p>
<p>&emsp;&emsp;&emsp;&emsp;2015</p>
</center></font>
]]></content>
      <categories>
        <category>白话野诗</category>
      </categories>
      <tags>
        <tag>诗词</tag>
      </tags>
  </entry>
  <entry>
    <title>离人泪</title>
    <url>/poetry/poetry3-25f8487f1fd1/</url>
    <content><![CDATA[<p><font color=#00BB00>&gt;<center></p>
<p>离人泪  </p>
<p>狂雨飞冰雷过城，浑水污泥踏行人。<br>愁绪缕缕伤疾病，呜咽电话断泪痕。  </p>
<p>或言多泪眼清明，哪堪雨泪染霜林。<br>母亲孤独难安心，弟弟厮混总伤情。  </p>
<p>&emsp;&emsp;&emsp;&emsp; 2007年 . 弟入狱</p>
</center></font>

]]></content>
      <categories>
        <category>白话野诗</category>
      </categories>
      <tags>
        <tag>诗词</tag>
      </tags>
  </entry>
  <entry>
    <title>过年</title>
    <url>/poetry/poetry30-58d94c391e76/</url>
    <content><![CDATA[<p><font color=#00BB00>&gt;<center></p>
<p>过年</p>
<p>颠沛流离处, 肝肠寸断时.<br>岁末残残归, 新天盎盎红.  </p>
<p>&emsp;&emsp;&emsp;&emsp;2016年春</p>
</center></font>
]]></content>
      <categories>
        <category>白话野诗</category>
      </categories>
      <tags>
        <tag>诗词</tag>
      </tags>
  </entry>
  <entry>
    <title>春节大黑山天乐</title>
    <url>/poetry/poetry31-88100919e038/</url>
    <content><![CDATA[<p><font color=#00BB00>&gt;<center></p>
<p>春节大黑山天乐</p>
<p>万物复新晨，只手弄轻云。<br>空寂一声喊，回响山山应。<br>爆竹声声鼓，万鸟箫齐鸣。<br>紫气微风舞，艳阳闪碧盈。  </p>
<p>&emsp;&emsp;&emsp;&emsp;2016年春</p>
</center></font>
]]></content>
      <categories>
        <category>白话野诗</category>
      </categories>
      <tags>
        <tag>诗词</tag>
      </tags>
  </entry>
  <entry>
    <title>倒计时</title>
    <url>/poetry/poetry32-d59bcc93f946/</url>
    <content><![CDATA[<p><font color=#00BB00>&gt;<center></p>
<p>倒计时  </p>
<p>星辰大海需要门票,<br>诗和远方路途遥远,<br>不管走过多少弯路,<br>每一步都在倒计时. </p>
<p>&emsp;&emsp;&emsp;2020</p>
</center></font>
]]></content>
      <categories>
        <category>白话野诗</category>
      </categories>
      <tags>
        <tag>诗词</tag>
      </tags>
  </entry>
  <entry>
    <title>心门掩·叹息</title>
    <url>/poetry/poetry4-43f4e440b335/</url>
    <content><![CDATA[<p><font color=#00BB00>&gt;<center></p>
<p>心门掩·叹息  </p>
<p>风高云远，天下春聚。<br>校园巢，莫敢弃。<br>心掩世界，壮志压书底。  </p>
<p>叹息无人理，谁来理？<br>他日一鸣，但求惊人语！  </p>
<p>&emsp;&emsp;&emsp;&emsp;2007</p>
</center></font>
]]></content>
      <categories>
        <category>白话野诗</category>
      </categories>
      <tags>
        <tag>诗词</tag>
      </tags>
  </entry>
  <entry>
    <title>梦境狂·落魂</title>
    <url>/poetry/poetry5-853893c97603/</url>
    <content><![CDATA[<p><font color=#00BB00>&gt;<center></p>
<p>梦境狂·落魂</p>
<p>云涛汹涌，翻腾蛟龙，飞羽匿无踪，细叶摇清风。<br>万般寂静，难奈何，心潮躁动。  </p>
<p>大志纵火，世事浇油，焚古今名流，狂欲王宇宙。<br>昼梦辉煌，才惊魂，如坠万千搂。  </p>
<p>&emsp;&emsp;&emsp;&emsp;2007</p>
</center></font>]]></content>
      <categories>
        <category>白话野诗</category>
      </categories>
      <tags>
        <tag>诗词</tag>
      </tags>
  </entry>
  <entry>
    <title>自我寻</title>
    <url>/poetry/poetry7-caa908281f62/</url>
    <content><![CDATA[<p><font color=#00BB00>&gt;<center></p>
<p>自我寻  </p>
<p>自我无处寻，乱昏昏沉沉。<br>才怨学未成，增又世难平。<br>试问怨何生？高考一方人。<br>无取光明路，何以报爱心。  </p>
<p>&emsp;&emsp;&emsp;&emsp;2007</p>
</center></font>
]]></content>
      <categories>
        <category>白话野诗</category>
      </categories>
      <tags>
        <tag>诗词</tag>
      </tags>
  </entry>
  <entry>
    <title>苏幕遮·早行怀父</title>
    <url>/poetry/poetry6-70b29e6d546e/</url>
    <content><![CDATA[<p><font color=#00BB00>&gt;<center></p>
<p>苏幕遮·早行怀父  </p>
<p>早行间，父子现，车送手牵，唯望子成龙。<br>撩动忆梦喜少年：怀里神仙，小调唱无边。<br>弹指间，痛三千。<br>慈父成仙，抛妻儿去远。<br>何日飞龙等云天？金光闪闪，南天门叙念。  </p>
<p>&emsp;&emsp;&emsp;&emsp;2007</p>
</center></font>
]]></content>
      <categories>
        <category>白话野诗</category>
      </categories>
      <tags>
        <tag>诗词</tag>
      </tags>
  </entry>
  <entry>
    <title>树叶</title>
    <url>/poetry/poetry8-7d8edfebf87a/</url>
    <content><![CDATA[<p><font color=#00BB00>&gt;<center></p>
<p>树叶</p>
<p>秋的季节<br>静净的湖水<br>静净的叶<br>微风轻轻吹<br>你婀娜的身影飘飞<br>天使般笑着跳着飘飞<br>和风儿一道把湖水揉碎<br>就这样<br>你唤开我的心扉<br>映在我心的每一页<br>真美<br>我如痴如醉<br>你轻轻飘落岸边<br>靠着大地的背<br>诉说着你流过的泪<br>我曾盼望着涨起洪水<br>把你卷入我的世界<br>但那时<br>没了静净的湖水<br>没了静净的叶<br>我固执地认为<br>——距离产生美  </p>
<p>&emsp;&emsp;&emsp;&emsp;2008</p>
</center></font>
]]></content>
      <categories>
        <category>白话野诗</category>
      </categories>
      <tags>
        <tag>诗词</tag>
      </tags>
  </entry>
  <entry>
    <title>给你自由</title>
    <url>/poetry/poetry9-7b84797e4f72/</url>
    <content><![CDATA[<p><font color=#00BB00>&gt;<center></p>
<p>给你自由  </p>
<p>天笼罩着乌云<br>一大片一大片的<br>不停地寻找着出路<br>想冲破这坚硬的思想的铁板<br>想找到自由<br>冲啊 冲啊<br>铁板在晃动<br>裂了<br>裂了 同志<br>裂了啊<br>飞吧 飞吧<br>飞向宇宙  </p>
<p>&emsp;&emsp;&emsp;&emsp;2008复读高三</p>
</center></font>
]]></content>
      <categories>
        <category>白话野诗</category>
      </categories>
      <tags>
        <tag>诗词</tag>
      </tags>
  </entry>
  <entry>
    <title>通俗易懂正则表达式</title>
    <url>/data/regex-95e69c7b339c/</url>
    <content><![CDATA[<blockquote>
<p>正则表达式, 也叫规则表达式, 是强大的文本字符串处理工具, 通常用来验证, 查找, 筛选, 提取, 替换那些符合某个规则的文本字符串</p>
</blockquote>
<h2 id="1-匹配规则"><a href="#1-匹配规则" class="headerlink" title="1, 匹配规则"></a>1, 匹配规则</h2><p>正则表达式的核心就是设计一个规则, 按照这个规则”按图索骥”, 去寻找符合这个规则的字符串, 并将它按需处理</p>
<p>先以一个最简单的例子进行探索:</p>
<p><code>re</code>: 正则表达式模块<br><code>findall</code>: 模块的一个方法, 传入 正则表达式 和 要去匹配字符串 将匹配结果以列表形式返回, 没有匹配结果返回空列表<br><code>\d</code>: 定义的规则, 表示匹配任意一个 0~9 的数字<br><code>198\d年</code>: 匹配符合 <code>198某年</code> 的字符串   </p>
<p>然后按照规则去匹配字符串: <code>&#39;1988年 2000年 2020年 1980年&#39;</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 导入模块 re</span></span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line"><span class="comment"># 按规则 r&#x27;198\d年&#x27; 匹配, r 的作用在 python 基础部分已介绍</span></span><br><span class="line">re.findall(<span class="string">r&#x27;198\d年&#x27;</span>, <span class="string">&#x27;1988年 2000年 2020年 1980年&#x27;</span>)</span><br></pre></td></tr></table></figure>




<pre><code>[&#39;1988年&#39;, &#39;1980年&#39;]</code></pre>
<p><code>\d</code> 是其中一个规则定义符, 可以和其他字符组合成正则表达式, 它自身也是一个正则表达式</p>
<p>而且任意一个字符都可以作为匹配它自身的正则表达式, 包括空字符<code>&#39;&#39;</code>, 只是要匹配规则定义符, 需要用 <code>\</code> 进行转义</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">re.findall(<span class="string">&#x27;&#x27;</span>, <span class="string">&#x27;a&#x27;</span>), re.findall(<span class="string">r&#x27;\\d.+\[a]&#x27;</span>, <span class="string">r&#x27;a\d.+[a]&#x27;</span>)</span><br></pre></td></tr></table></figure>




<pre><code>([&#39;&#39;, &#39;&#39;], [&#39;\\d.+[a]&#39;])</code></pre>
<h2 id="2-常用规则定义符"><a href="#2-常用规则定义符" class="headerlink" title="2, 常用规则定义符"></a>2, 常用规则定义符</h2><h3 id="2-01-定义类别匹配"><a href="#2-01-定义类别匹配" class="headerlink" title="2.01, 定义类别匹配"></a>2.01, 定义类别匹配</h3><p><code>\w</code> 匹配任意一个字母, 数字及下划线, <code>\W</code> 匹配任意一个非字母, 数字及下划线</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = <span class="string">r&#x27;my\wname&#x27;</span></span><br><span class="line">b = <span class="string">r&#x27;my\Wname&#x27;</span></span><br><span class="line">c = <span class="string">&#x27;my1name, my_name, my.name, myaname&#x27;</span></span><br><span class="line">re.findall(a, c), re.findall(b, c)</span><br></pre></td></tr></table></figure>




<pre><code>([&#39;my1name&#39;, &#39;my_name&#39;, &#39;myaname&#39;], [&#39;my.name&#39;])</code></pre>
<p><code>\d</code> 匹配任意一个 0~9 的数字, <code>\D</code> 匹配任意任意一个非数字</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = <span class="string">r&#x27;01\d-\D123&#x27;</span></span><br><span class="line">b = <span class="string">&#x27;010-0123, 010-爱123, 01o-0123&#x27;</span></span><br><span class="line">re.findall(a, b)</span><br></pre></td></tr></table></figure>




<pre><code>[&#39;010-爱123&#39;]</code></pre>
<p><code>\s</code> 匹配一个空白字符, <code>\S</code> 匹配一个非空白字符, 空白包括一个空格 <code> </code>, <code>\f</code> 分页符, <code>\n</code> <code>\r</code> 换行符, <code>\t</code> 制表符, <code>\v</code> 纵向制表符</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = <span class="string">r&#x27;a\sb\Sc&#x27;</span></span><br><span class="line">b = <span class="string">&#x27;a b c, a bcc, a  bcc&#x27;</span></span><br><span class="line">re.findall(a, b)</span><br></pre></td></tr></table></figure>




<pre><code>[&#39;a bcc&#39;]</code></pre>
<p><code>.</code> 匹配除换行符 <code>\r</code> <code>\n</code> 之外的任意一个字符</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = <span class="string">r&#x27;a.b&#x27;</span></span><br><span class="line">b = <span class="string">&#x27;&#x27;&#x27;a</span></span><br><span class="line"><span class="string">b, a-b, a b, a  b&#x27;&#x27;&#x27;</span></span><br><span class="line">re.findall(a, b)</span><br></pre></td></tr></table></figure>




<pre><code>[&#39;a-b&#39;, &#39;a b&#39;]</code></pre>
<h3 id="2-02-定义范围匹配"><a href="#2-02-定义范围匹配" class="headerlink" title="2.02, 定义范围匹配"></a>2.02, 定义范围匹配</h3><p>用括号 <code>[]</code> 将字符(表达式)包围起来, 表示在括号内指定的范围内匹配任意一个</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">re.findall(<span class="string">&#x27;[abc]&#x27;</span>, <span class="string">&#x27;bill&#x27;</span>)</span><br></pre></td></tr></table></figure>




<pre><code>[&#39;b&#39;]</code></pre>
<p>在 <code>[]</code> 内, 以 <code>^</code> 开头, 表示排除括号内的字符(表达式)范围匹配</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">re.findall(<span class="string">&#x27;[^abc]&#x27;</span>, <span class="string">&#x27;abcd&#x27;</span>)</span><br></pre></td></tr></table></figure>




<pre><code>[&#39;d&#39;]</code></pre>
<p>在 <code>[]</code> 内, 数字或字母之间用 <code>-</code> 连接, 表示在两者(包含)之间的范围内匹配</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">re.findall(<span class="string">&#x27;[a-d0-5]&#x27;</span>, <span class="string">&#x27;af357&#x27;</span>)</span><br></pre></td></tr></table></figure>




<pre><code>[&#39;a&#39;, &#39;3&#39;, &#39;5&#39;]</code></pre>
<h3 id="2-03-定义边界匹配"><a href="#2-03-定义边界匹配" class="headerlink" title="2.03, 定义边界匹配"></a>2.03, 定义边界匹配</h3><p><code>^</code> 或 <code>\A</code>, 表示必须以接下来的字符(表达式)开头才能被匹配, 换行开头也不能匹配</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = <span class="string">&#x27;^b\d[bc]&#x27;</span></span><br><span class="line">b = <span class="string">&#x27;&#x27;&#x27;a2b</span></span><br><span class="line"><span class="string">b2b&#x27;&#x27;&#x27;</span></span><br><span class="line">c = <span class="string">&#x27;b2bcd&#x27;</span></span><br><span class="line">re.findall(a, b), re.findall(a, c)</span><br></pre></td></tr></table></figure>




<pre><code>([], [&#39;b2b&#39;])</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = <span class="string">&#x27;\Ab\d[bc]&#x27;</span></span><br><span class="line">b = <span class="string">&#x27;&#x27;&#x27;a2b</span></span><br><span class="line"><span class="string">b2b&#x27;&#x27;&#x27;</span></span><br><span class="line">c = <span class="string">&#x27;b2bcd&#x27;</span></span><br><span class="line">re.findall(a, b), re.findall(a, c)</span><br></pre></td></tr></table></figure>




<pre><code>([], [&#39;b2b&#39;])</code></pre>
<p><code>$</code> 或 <code>\Z</code>表示必须以其前面的字符(表达式)结尾才能被匹配, 换行之前的结束也不能匹配</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">re.findall(<span class="string">&#x27;a\w$&#x27;</span>, <span class="string">&#x27;ab&#x27;</span>), re.findall(<span class="string">&#x27;a\w\Z&#x27;</span>, <span class="string">&#x27;a=&#x27;</span>)</span><br></pre></td></tr></table></figure>




<pre><code>([&#39;ab&#39;], [])</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">re.findall(<span class="string">&#x27;a\w\Z&#x27;</span>, <span class="string">&#x27;ab&#x27;</span>), re.findall(<span class="string">&#x27;a\w\Z&#x27;</span>, <span class="string">&#x27;ab%&#x27;</span>)</span><br></pre></td></tr></table></figure>




<pre><code>([&#39;ab&#39;], [])</code></pre>
<p><code>\b</code> 表示必须以其前面的字符(表达式)结尾才能被匹配, 但是只要有符号(<code>_</code>除外)隔开都算结尾, <code>\B</code> 与 <code>\b</code> 相反</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">re.findall(<span class="string">r&#x27;b\b&#x27;</span>, <span class="string">&#x27;ab_ab,ab-ab&#x27;</span>) <span class="comment"># 只匹配后三个 b</span></span><br></pre></td></tr></table></figure>




<pre><code>[&#39;b&#39;, &#39;b&#39;, &#39;b&#39;]</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">re.findall(<span class="string">r&#x27;中国\B&#x27;</span>, <span class="string">&#x27;中国中国中国)的中国&#x27;</span>) <span class="comment"># 只匹配前两个 中国</span></span><br></pre></td></tr></table></figure>




<pre><code>[&#39;中国&#39;, &#39;中国&#39;]</code></pre>
<h3 id="2-04-定义数量匹配"><a href="#2-04-定义数量匹配" class="headerlink" title="2.04, 定义数量匹配"></a>2.04, 定义数量匹配</h3><p><code>+</code> 其前面的字符(表达式)至少有一个的都能匹配</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">re.findall(<span class="string">r&#x27;10+&#x27;</span>, <span class="string">&#x27;110, 100, 1001&#x27;</span>)</span><br></pre></td></tr></table></figure>




<pre><code>[&#39;10&#39;, &#39;100&#39;, &#39;100&#39;]</code></pre>
<p><code>?</code> 其前面的字符(表达式)最多有一个的才能匹配</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">re.findall(<span class="string">r&#x27;10?&#x27;</span>, <span class="string">&#x27;1, 10, 100&#x27;</span>)</span><br></pre></td></tr></table></figure>




<pre><code>[&#39;1&#39;, &#39;10&#39;, &#39;10&#39;]</code></pre>
<p><code>*</code> 其前面的字符(表达式)没有或有多个都可以匹配</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">re.findall(<span class="string">r&#x27;10*&#x27;</span>, <span class="string">&#x27;1, 10, 1001&#x27;</span>)</span><br></pre></td></tr></table></figure>




<pre><code>[&#39;1&#39;, &#39;10&#39;, &#39;100&#39;, &#39;1&#39;]</code></pre>
<p><code>&#123;n&#125;</code> 其前面的字符(表达式)有 n 个才能匹配</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">re.findall(<span class="string">r&#x27;1\d&#123;3&#125;&#x27;</span>, <span class="string">&#x27;12, 123, 1a23, 1234&#x27;</span>)</span><br></pre></td></tr></table></figure>




<pre><code>[&#39;1234&#39;]</code></pre>
<p><code>&#123;n,&#125;</code> 其前面的字符(表达式)有至少 n 个才能匹配, <code>&#123;m,n&#125;</code> 则表示有 m~n 个才能匹配, m 和 n 之间只有 <code>,</code> 号而不能有空格</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">re.findall(<span class="string">r&#x27;1\d&#123;2,&#125;&#x27;</span>, <span class="string">&#x27;12, 123, 1234, 12345&#x27;</span>)</span><br></pre></td></tr></table></figure>




<pre><code>[&#39;123&#39;, &#39;1234&#39;, &#39;12345&#39;]</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">re.findall(<span class="string">r&#x27;1\d&#123;2,3&#125;&#x27;</span>, <span class="string">&#x27;12, 123, 1234, 12345&#x27;</span>)</span><br></pre></td></tr></table></figure>




<pre><code>[&#39;123&#39;, &#39;1234&#39;, &#39;1234&#39;]</code></pre>
<h3 id="2-05-或-匹配符"><a href="#2-05-或-匹配符" class="headerlink" title="2.05, 或 匹配符 |"></a>2.05, <code>或</code> 匹配符 <code>|</code></h3><p>符号 <code>|</code> 两边的内容, 有一边匹配 或 两边都匹配都可以, 但当 <code>|</code> 在括号 <code>[]</code> 中则无此作用, 只代表它自身</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">re.findall(<span class="string">r&#x27;aa|bb&#x27;</span>, <span class="string">&#x27;aacbbcaabbab&#x27;</span>)</span><br></pre></td></tr></table></figure>




<pre><code>[&#39;aa&#39;, &#39;bb&#39;, &#39;aa&#39;, &#39;bb&#39;]</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">re.findall(<span class="string">r&#x27;a[|]b&#x27;</span>, <span class="string">&#x27;ab, a|b&#x27;</span>)</span><br></pre></td></tr></table></figure>




<pre><code>[&#39;a|b&#39;]</code></pre>
<h3 id="2-06-定义组合匹配"><a href="#2-06-定义组合匹配" class="headerlink" title="2.06, 定义组合匹配"></a>2.06, 定义组合匹配</h3><p>用 <code>()</code> 将多个字符组合成一个整体来匹配, 不管 <code>()</code> 外是否有数量匹配符, 都只返回 <code>()</code> 内的内容, 如果表达式内有多个 <code>()</code> 封装的内容, 匹配结果以元组形式返回. </p>
<p>当 <code>()</code> 在 <code>[]</code> 中则无此作用, 只代表它自身</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 匹配的是 ab 和 abab 但只返回括号内的 ab</span></span><br><span class="line">re.findall(<span class="string">r&#x27;(ab)+&#x27;</span>, <span class="string">&#x27;ab11abab&#x27;</span>) </span><br></pre></td></tr></table></figure>




<pre><code>[&#39;ab&#39;, &#39;ab&#39;]</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 匹配的是后面的 abab 返回元组</span></span><br><span class="line">re.findall(<span class="string">r&#x27;(ab)(ab)&#x27;</span>, <span class="string">&#x27;ab11abab&#x27;</span>) </span><br></pre></td></tr></table></figure>




<pre><code>[(&#39;ab&#39;, &#39;ab&#39;)]</code></pre>
<p>将贪婪匹配转为非贪婪匹配</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 贪婪匹配 \d+ 使得无法将 000 取出</span></span><br><span class="line">re.findall(<span class="string">r&#x27;(\d+)(0*)$&#x27;</span>, <span class="string">&#x27;123000&#x27;</span>)</span><br></pre></td></tr></table></figure>




<pre><code>[(&#39;123000&#39;, &#39;&#39;)]</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># + 后面加个 ? 号</span></span><br><span class="line">re.findall(<span class="string">r&#x27;(\d+?)(0*)$&#x27;</span>, <span class="string">&#x27;123000&#x27;</span>)</span><br></pre></td></tr></table></figure>




<pre><code>[(&#39;123&#39;, &#39;000&#39;)]</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">re.findall(<span class="string">r&#x27;[(ab)]&#x27;</span>, <span class="string">&#x27;ab, (ab)&#x27;</span>)</span><br></pre></td></tr></table></figure>




<pre><code>[&#39;a&#39;, &#39;b&#39;, &#39;(&#39;, &#39;a&#39;, &#39;b&#39;, &#39;)&#39;]</code></pre>
<p>如果 <code>()</code> 内以 <code>?:</code> 开头, 则在 <code>()</code> 外面的数量匹配符, 返回匹配到的相应数量字符</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">re.findall(<span class="string">r&#x27;(?:ab)+&#x27;</span>, <span class="string">&#x27;ab11abab&#x27;</span>) </span><br></pre></td></tr></table></figure>




<pre><code>[&#39;ab&#39;, &#39;abab&#39;]</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 匹配的是后面的 abab, 但只返回前一个 () 内的内容</span></span><br><span class="line">re.findall(<span class="string">r&#x27;(ab)(?:ab)+&#x27;</span>, <span class="string">&#x27;ab11abab&#x27;</span>) </span><br></pre></td></tr></table></figure>




<pre><code>[&#39;ab&#39;]</code></pre>
<p>如果 <code>()</code> 内以 <code>?=</code> 开头, 则 <code>()</code> 内的内容只是用来匹配, 不返回也不消耗匹配的字符, 也就是说, 匹配完了, 后面的字符需要继续匹配</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">re.findall(<span class="string">r&#x27;a(?=bc)bc&#x27;</span>, <span class="string">&#x27;ab, abc, abcde&#x27;</span>)</span><br></pre></td></tr></table></figure>




<pre><code>[&#39;abc&#39;, &#39;abc&#39;]</code></pre>
<p>如果 <code>()</code> 内以 <code>?!</code> 开头, 则 <code>()</code> 内的内容只是用来排除, 也就是说, 排除括号内的内容都可以匹配, 不占字符, 匹配完了, 后面的字符需要继续匹配</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># a 后面除了 bc 都可以匹配</span></span><br><span class="line">re.findall(<span class="string">r&#x27;a(?!bc)\w+&#x27;</span>, <span class="string">&#x27;abc, acb, abde&#x27;</span>)</span><br></pre></td></tr></table></figure>




<pre><code>[&#39;acb&#39;, &#39;abde&#39;]</code></pre>
<p><code>(?&lt;=...)</code> 和 <code>(?&lt;!...)</code>, 与上面两个类似, 只是方向相反</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">re.findall(<span class="string">r&#x27;\w(?&lt;=bc)b&#x27;</span>, <span class="string">&#x27;ab, bcb, abcd&#x27;</span>)</span><br></pre></td></tr></table></figure>




<pre><code>[&#39;cb&#39;]</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 只能匹配后一个 a</span></span><br><span class="line">re.findall(<span class="string">r&#x27;(?&lt;!bc)a&#x27;</span>, <span class="string">&#x27;bca, cba&#x27;</span>)</span><br></pre></td></tr></table></figure>




<pre><code>[&#39;a&#39;]</code></pre>
<h3 id="2-07-匹配规则修正符"><a href="#2-07-匹配规则修正符" class="headerlink" title="2.07, 匹配规则修正符"></a>2.07, 匹配规则修正符</h3><p>介绍几个常用的规则修正符</p>
<p><code>re.I</code> 大小写不敏感匹配</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">re.findall(<span class="string">r&#x27;aA&#x27;</span>,<span class="string">&#x27;aA, aa&#x27;</span>, re.I)</span><br></pre></td></tr></table></figure>




<pre><code>[&#39;aA&#39;, &#39;aa&#39;]</code></pre>
<p><code>re.S</code> 使 <code>.</code> 匹配任何字符, 包括换行符</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = <span class="string">&#x27;&#x27;&#x27;a</span></span><br><span class="line"><span class="string">b, a-b&#x27;&#x27;&#x27;</span></span><br><span class="line">re.findall(<span class="string">r&#x27;a.b&#x27;</span>, a, re.S)</span><br></pre></td></tr></table></figure>




<pre><code>[&#39;a\nb&#39;, &#39;a-b&#39;]</code></pre>
<p><code>re.M</code> 使得 <code>^</code> 和 <code>$</code> 能匹配换行的开始或换行前的结束</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = <span class="string">&#x27;^b\d[bc]&#x27;</span></span><br><span class="line">b = <span class="string">&#x27;&#x27;&#x27;a2b</span></span><br><span class="line"><span class="string">b2b&#x27;&#x27;&#x27;</span></span><br><span class="line">re.findall(a, b, re.M)</span><br></pre></td></tr></table></figure>




<pre><code>[&#39;b2b&#39;]</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = <span class="string">&#x27;a\d[bc]$&#x27;</span></span><br><span class="line">b = <span class="string">&#x27;&#x27;&#x27;a2b</span></span><br><span class="line"><span class="string">a2c&#x27;&#x27;&#x27;</span></span><br><span class="line">re.findall(a, b, re.M)</span><br></pre></td></tr></table></figure>




<pre><code>[&#39;a2b&#39;, &#39;a2c&#39;]</code></pre>
<h2 id="3-匹配和处理方法"><a href="#3-匹配和处理方法" class="headerlink" title="3, 匹配和处理方法"></a>3, 匹配和处理方法</h2><p><code>match</code> 从字符串起始位置匹配, 匹配到的字符返回为 match 对象, 相当于一个数据容器, 可以用方法加以获取</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = re.match(<span class="string">r&#x27;ab&#x27;</span>, <span class="string">&#x27;abc&#x27;</span>)</span><br><span class="line">b = re.match(<span class="string">r&#x27;a(bc)d(ef)g&#x27;</span>, <span class="string">&#x27;abcdefgh&#x27;</span>)</span><br><span class="line">c = re.match(<span class="string">r&#x27;ab&#x27;</span>, <span class="string">&#x27;bab&#x27;</span>)</span><br><span class="line">a, b, c</span><br></pre></td></tr></table></figure>




<pre><code>(&lt;re.Match object; span=(0, 2), match=&#39;ab&#39;&gt;,
 &lt;re.Match object; span=(0, 7), match=&#39;abcdefg&#39;&gt;,
 None)</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># group() 获取匹配的全部字符, </span></span><br><span class="line"><span class="comment"># group(1) 获取 () 内匹配的第一个, 以此类推</span></span><br><span class="line">a.group(), b.group(), b.group(<span class="number">1</span>), b.group(<span class="number">2</span>)</span><br></pre></td></tr></table></figure>




<pre><code>(&#39;ab&#39;, &#39;abcdefg&#39;, &#39;bc&#39;, &#39;ef&#39;)</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># start 获取匹配开始的位置</span></span><br><span class="line">a.start(), b.start()</span><br></pre></td></tr></table></figure>




<pre><code>(0, 0)</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># end 获取匹配结束的位置</span></span><br><span class="line">a.end(), b.end()</span><br></pre></td></tr></table></figure>




<pre><code>(2, 7)</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># span 获取 (开始, 结束) 元组</span></span><br><span class="line">a.span(), b.span()</span><br></pre></td></tr></table></figure>




<pre><code>((0, 2), (0, 7))</code></pre>
<p><code>compile</code> 编译正则表达式, 返回一个 Pattern 对象(后面简写为p), 然后可以用该对象调用方法, 原来用 <code>re</code> 调用的方法的参数已经变了</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">p = re.<span class="built_in">compile</span>(<span class="string">&#x27;\d+&#x27;</span>)</span><br><span class="line">p</span><br></pre></td></tr></table></figure>




<pre><code>re.compile(r&#39;\d+&#39;, re.UNICODE)</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 调用上面的 match 方法, 可以指定开始和结束位置</span></span><br><span class="line">a = p.match(<span class="string">&#x27;12a21&#x27;</span>, <span class="number">3</span>)</span><br><span class="line">a</span><br></pre></td></tr></table></figure>




<pre><code>&lt;re.Match object; span=(3, 5), match=&#39;21&#39;&gt;</code></pre>
<p><code>re.search</code> 扫描整个字符串, 第一个匹配的字符串返回为 match 对象<br><code>p.search</code> 扫描指定范围, 不指定就全部扫描</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">r = <span class="string">&#x27;python\d.\d&#x27;</span></span><br><span class="line">s = <span class="string">&#x27;python3.0, python3.8&#x27;</span></span><br><span class="line">p = re.<span class="built_in">compile</span>(r)</span><br><span class="line">a = re.search(r, s)</span><br><span class="line">b = p.search(s)</span><br><span class="line">c = p.search(s, <span class="number">1</span>)</span><br><span class="line">a, b, c</span><br></pre></td></tr></table></figure>




<pre><code>(&lt;re.Match object; span=(0, 9), match=&#39;python3.0&#39;&gt;,
 &lt;re.Match object; span=(0, 9), match=&#39;python3.0&#39;&gt;,
 &lt;re.Match object; span=(11, 20), match=&#39;python3.8&#39;&gt;)</code></pre>
<p><code>sub</code> 替换字符串中的匹配项, 可以控制替换次数, 还可传入函数高级替换</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">r = <span class="string">&#x27;[,.]&#x27;</span></span><br><span class="line">s = <span class="string">&#x27;去掉,逗号和.句号.&#x27;</span></span><br><span class="line">p = re.<span class="built_in">compile</span>(r)</span><br><span class="line">re.sub(p, <span class="string">&#x27;&#x27;</span>, s), p.sub(<span class="string">&#x27;&#x27;</span>, s, <span class="number">2</span>)</span><br></pre></td></tr></table></figure>




<pre><code>(&#39;去掉逗号和句号&#39;, &#39;去掉逗号和句号.&#39;)</code></pre>
<p><code>findall</code> 已经介绍过</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">r = <span class="string">r&#x27;\D+(\d+)\D+(\d+)\D+(\d+)*&#x27;</span></span><br><span class="line">s = <span class="string">&#x27;分组提取123所有456数字78.&#x27;</span></span><br><span class="line">p = re.<span class="built_in">compile</span>(r)</span><br><span class="line">re.findall(p, s), p.findall(s, <span class="number">8</span>)</span><br></pre></td></tr></table></figure>




<pre><code>([(&#39;123&#39;, &#39;456&#39;, &#39;78&#39;)], [(&#39;456&#39;, &#39;78&#39;, &#39;&#39;)])</code></pre>
<p><code>finditer</code> 和 <code>findall</code>类似, 只是返回的是一个 match 的迭代器(可以理解为数据容器)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line">r = <span class="string">r&#x27;\D+(\d+)\D+(\d+)\D+(\d+)*&#x27;</span></span><br><span class="line">s = <span class="string">&#x27;分组提取123所有456数字78.&#x27;</span></span><br><span class="line">p = re.<span class="built_in">compile</span>(r)</span><br><span class="line">a = re.finditer(p, s)</span><br><span class="line">b = p.finditer(s, <span class="number">8</span>)</span><br><span class="line">a, b</span><br></pre></td></tr></table></figure>




<pre><code>(&lt;callable_iterator at 0x2d83f2fbac8&gt;, &lt;callable_iterator at 0x2d83f3033c8&gt;)</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i, j <span class="keyword">in</span> <span class="built_in">zip</span>(a, b):</span><br><span class="line">    print(i, j)</span><br><span class="line">    print(i.group(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>), j.group())</span><br></pre></td></tr></table></figure>

<pre><code>&lt;re.Match object; span=(0, 16), match=&#39;分组提取123所有456数字78&#39;&gt; &lt;re.Match object; span=(8, 17), match=&#39;有456数字78.&#39;&gt;
(&#39;123&#39;, &#39;456&#39;, &#39;78&#39;) 有456数字78.</code></pre>
<p><code>split</code> 用匹配到的字符(或字符串), 将整个字符串分割返回列表, 可设置最大拆分数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">r = <span class="string">&#x27;[\s\,-]&#x27;</span></span><br><span class="line">s = <span class="string">&#x27;将,每 个-字 拆,开&#x27;</span></span><br><span class="line">p = re.<span class="built_in">compile</span>(r)</span><br><span class="line">re.split(p, s), p.split(s, <span class="number">2</span>)</span><br></pre></td></tr></table></figure>




<pre><code>([&#39;将&#39;, &#39;每&#39;, &#39;个&#39;, &#39;字&#39;, &#39;拆&#39;, &#39;开&#39;], [&#39;将&#39;, &#39;每&#39;, &#39;个-字 拆,开&#39;])</code></pre>
]]></content>
      <categories>
        <category>数据分析</category>
      </categories>
      <tags>
        <tag>正则表达式</tag>
      </tags>
  </entry>
  <entry>
    <title>描述统计</title>
    <url>/data/statistics1-24ca6e122f33/</url>
    <content><![CDATA[<blockquote>
<p>文章主要内容和思路来源: <strong>开课吧</strong>学习笔记</p>
</blockquote>
<p><font color=#00A600 >2020年6月4日更新</font></p>
<h2 id="一-数理统计介绍"><a href="#一-数理统计介绍" class="headerlink" title="一, 数理统计介绍"></a>一, 数理统计介绍</h2><p>数理统计以概率论为基础, 研究大量随机现象的统计规律性. 分为<strong>描述统计</strong>和<strong>推断统计</strong>, 在数据分析领域具有非常重要的地位 </p>
<h2 id="二-描述统计"><a href="#二-描述统计" class="headerlink" title="二, 描述统计"></a>二, 描述统计</h2><p>描述统计, 就是从总体数据中提取变量的主要信息(总和, 均值, 最大, 最多等), 从而从总体层面上, 对数据进行统计性描述. 通常配合绘制相关统计图进行辅助</p>
<h3 id="2-01-统计学的变量类型"><a href="#2-01-统计学的变量类型" class="headerlink" title="2.01, 统计学的变量类型"></a>2.01, 统计学的变量类型</h3><p>统计学中的变量指研究对象的特征(属性), 每个变量都有变量值和类型, 类型可分为:</p>
<p><strong>类别变量</strong>: 对研究对象定性, 分类</p>
<p>类别变量又可分为: </p>
<ul>
<li>有序类别变量: 描述对象等级或顺序等, 例如, 优良中差</li>
<li>无序类别变量: 仅做分类, 例如 A, B 血型, 男女</li>
</ul>
<p><strong>数值变量</strong>: 对研究对象定量描述</p>
<p>数值变量又可分为:</p>
<ul>
<li>离散变量: 取值只能用自然数或整数个单位计算, 例如统计人数</li>
<li>连续变量: 在一定区间内可以任意取值, 例如计算身高</li>
</ul>
<p>数值变量对加, 减, 求平均等操作有意义, 而类别变量无意义</p>
<h3 id="2-02-统计量"><a href="#2-02-统计量" class="headerlink" title="2.02, 统计量"></a>2.02, 统计量</h3><p>描述统计所提取的统计信息, 称为统计量, 主要包括: </p>
<ul>
<li>类别分析: 频数, 频率</li>
<li>集中趋势分析: 均值, 中位数, 众数, 分位数</li>
<li>离散程度分析: 极差, 方差, 标准差</li>
<li>描述分布形状: 偏度, 峰度</li>
</ul>
<p>准备数据:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> seaborn <span class="keyword">as</span> sns</span><br><span class="line"></span><br><span class="line">plt.rcParams[<span class="string">&#x27;font.family&#x27;</span>] = <span class="string">&#x27;SimHei&#x27;</span></span><br><span class="line">plt.rcParams[<span class="string">&#x27;axes.unicode_minus&#x27;</span>] = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 正态分布</span></span><br><span class="line">data1 = np.around(np.random.normal(<span class="number">10</span>, <span class="number">3</span>, <span class="number">600</span>)).reshape(<span class="number">-1</span>, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 左偏</span></span><br><span class="line">t1 = np.random.randint(<span class="number">1</span>, <span class="number">21</span>, size=<span class="number">100</span>)</span><br><span class="line">t2 = np.random.randint(<span class="number">21</span>, <span class="number">31</span>, size=<span class="number">500</span>)</span><br><span class="line">left_data = np.concatenate([t1, t2]).reshape(<span class="number">-1</span>, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 右偏</span></span><br><span class="line">t3 = np.random.randint(<span class="number">1</span>, <span class="number">11</span>, size=<span class="number">500</span>)</span><br><span class="line">t4 = np.random.randint(<span class="number">11</span>, <span class="number">21</span>, size=<span class="number">100</span>)</span><br><span class="line">right_data = np.concatenate([t3, t4]).reshape(<span class="number">-1</span>, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 类别</span></span><br><span class="line">type_data = np.random.randint(<span class="number">0</span>, <span class="number">2</span>, size=<span class="number">600</span>).reshape(<span class="number">-1</span>, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">data = np.concatenate([data1, left_data, right_data, type_data], axis=<span class="number">1</span>)</span><br><span class="line">data = pd.DataFrame(data,</span><br><span class="line">                   columns=[<span class="string">&#x27;data1&#x27;</span>, <span class="string">&#x27;left_data&#x27;</span>, <span class="string">&#x27;right_data&#x27;</span>, <span class="string">&#x27;type_data&#x27;</span>])</span><br><span class="line"><span class="comment"># 随机取 10 条数据</span></span><br><span class="line">data.sample(<span class="number">10</span>)</span><br></pre></td></tr></table></figure>




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

<pre><code>.dataframe tbody tr th &#123;
    vertical-align: top;
&#125;

.dataframe thead th &#123;
    text-align: right;
&#125;</code></pre>
<p></style></p>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>data1</th>
      <th>left_data</th>
      <th>right_data</th>
      <th>type_data</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>83</th>
      <td>12.0</td>
      <td>11.0</td>
      <td>3.0</td>
      <td>0.0</td>
    </tr>
    <tr>
      <th>391</th>
      <td>4.0</td>
      <td>29.0</td>
      <td>10.0</td>
      <td>0.0</td>
    </tr>
    <tr>
      <th>450</th>
      <td>9.0</td>
      <td>25.0</td>
      <td>10.0</td>
      <td>1.0</td>
    </tr>
    <tr>
      <th>303</th>
      <td>12.0</td>
      <td>22.0</td>
      <td>3.0</td>
      <td>0.0</td>
    </tr>
    <tr>
      <th>542</th>
      <td>12.0</td>
      <td>25.0</td>
      <td>17.0</td>
      <td>1.0</td>
    </tr>
    <tr>
      <th>19</th>
      <td>8.0</td>
      <td>6.0</td>
      <td>6.0</td>
      <td>0.0</td>
    </tr>
    <tr>
      <th>232</th>
      <td>6.0</td>
      <td>27.0</td>
      <td>2.0</td>
      <td>1.0</td>
    </tr>
    <tr>
      <th>456</th>
      <td>16.0</td>
      <td>29.0</td>
      <td>10.0</td>
      <td>1.0</td>
    </tr>
    <tr>
      <th>478</th>
      <td>10.0</td>
      <td>23.0</td>
      <td>5.0</td>
      <td>1.0</td>
    </tr>
    <tr>
      <th>298</th>
      <td>10.0</td>
      <td>28.0</td>
      <td>1.0</td>
      <td>1.0</td>
    </tr>
  </tbody>
</table>
</div>



<h4 id="a-频数"><a href="#a-频数" class="headerlink" title="a, 频数"></a>a, 频数</h4><p>数据中某个类别出现的次数称为该类别的频数</p>
<p>例如, 计算上述两个类别(<code>0.0</code> 和 <code>1.0</code>)出现的频数:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">frequency = data[<span class="string">&#x27;type_data&#x27;</span>].value_counts()</span><br><span class="line">frequency</span><br></pre></td></tr></table></figure>




<pre><code>0.0    315
1.0    285
Name: type_data, dtype: int64</code></pre>
<h4 id="b-频率"><a href="#b-频率" class="headerlink" title="b, 频率"></a>b, 频率</h4><p>数据中某个类别出现次数与总次数的比值称为该类别的频率</p>
<p>例如, 计算上述两个类别(<code>0.0</code> 和 <code>1.0</code>)出现的频率:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">percentage = frequency * <span class="number">100</span> / <span class="built_in">len</span>(data)</span><br><span class="line">percentage</span><br></pre></td></tr></table></figure>




<pre><code>0.0    52.5
1.0    47.5
Name: type_data, dtype: float64</code></pre>
<h4 id="c-均值"><a href="#c-均值" class="headerlink" title="c, 均值"></a>c, 均值</h4><p>平均值, 一组数据的总和除以数据的个数</p>
<h4 id="d-中位数"><a href="#d-中位数" class="headerlink" title="d, 中位数"></a>d, 中位数</h4><p>将一组数据按顺序排列, 位于最中间位置的值, 即是中位数, 如果数据个数为偶数, 取中间两个的平均值</p>
<h4 id="e-众数"><a href="#e-众数" class="headerlink" title="e, 众数"></a>e, 众数</h4><p>一组数据中出现次数最多的值</p>
<p>通常三者的关系如下图所示:</p>
<p><img src="/images/mathematical-statistics/fenbu.png"></p>
<p><strong>注意点</strong>:<br>数值变量通常使用均值和中值表示集中趋势, 类别变量则通常使用众数<br>正态分布下, 数据量足够多, 三者相同<br>均值使用所有数据计算, 容易受极端值影响, 中位数和众数则不会<br>众数在一组数据中可能不唯一</p>
<p>例, 计算字段 <code>data1</code> 的均值, 中位数和众数:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">mean = data[<span class="string">&#x27;data1&#x27;</span>].mean()</span><br><span class="line">median = data[<span class="string">&#x27;data1&#x27;</span>].median()</span><br><span class="line">mode = data[<span class="string">&#x27;data1&#x27;</span>].mode()</span><br><span class="line">print(<span class="string">f&#x27;均值:<span class="subst">&#123;mean&#125;</span> 中位数:<span class="subst">&#123;median&#125;</span>\n众数:\n<span class="subst">&#123;mode&#125;</span>&#x27;</span>)</span><br></pre></td></tr></table></figure>

<pre><code>均值:9.973333333333333 中位数:10.0
众数:
0    10.0
dtype: float64</code></pre>
<p>还可以使用 <code>scipy</code> 中的 <code>stats</code> 模块来求一组数据的众数:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> scipy <span class="keyword">import</span> stats</span><br><span class="line">stats.mode(data[<span class="string">&#x27;data1&#x27;</span>]).mode</span><br></pre></td></tr></table></figure>




<pre><code>array([10.])</code></pre>
<p>求众数方法两者对比: 前者的返回值类型是 Serise, 后者的返回值类型是 array. 如果众数的值不唯一，前者都会显示，后者只显示一个</p>
<h4 id="f-分位数"><a href="#f-分位数" class="headerlink" title="f, 分位数"></a>f, 分位数</h4><p>通过 n - 1 个分位, 将升序排列的数据分为 n 个区间, 使得每个区间数值个数相等(或近似相等), 则每个分位对应的数, 就是该 n 分位的分位数. 常用的有四分位数和百分位数</p>
<p>以四分位数为例:<br>第一个分位称为 1/4 分位(下四分位), 第二个称为 2/4 分位(中四分位), 第三个称为 3/4 分位(上四分位), 其中中四分位数, 其实就是中位数</p>
<p>求四分位的值:  </p>
<ul>
<li><p>首先计算各个分位的位置<br>index1 = (n - 1) * 0.25<br>index2 = (n - 1) * 0.5<br>index3 = (n - 1) * 0.75<br>(index 从 0 开始, n 为元素的个数)</p>
</li>
<li><p>根据位置计算各个分位的值<br>index 为整数, 值就是相应的 index 对应的元素<br>index 不为整数, 四分位位置介于 ceil(index) 和 floor(index) 之间, 加权计算分位值</p>
</li>
</ul>
<p>例, 求 x 的四分位数:<br><strong>index 为整数</strong>  </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x = np.arange(<span class="number">0</span>, <span class="number">9</span>)</span><br><span class="line">n = <span class="built_in">len</span>(x)</span><br><span class="line"></span><br><span class="line">index1 = (n - <span class="number">1</span>) * <span class="number">0.25</span></span><br><span class="line">index2 = (n - <span class="number">1</span>) * <span class="number">0.5</span>  </span><br><span class="line">index3 = (n - <span class="number">1</span>) * <span class="number">0.75</span>  </span><br><span class="line"></span><br><span class="line">index = np.array([index1, index2, index3]).astype(np.int32)</span><br><span class="line">x[index]</span><br></pre></td></tr></table></figure>




<pre><code>array([2, 4, 6])</code></pre>
<p><strong>index 不是整数</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x = np.arange(<span class="number">0</span>, <span class="number">10</span>)</span><br><span class="line">n = <span class="built_in">len</span>(x)</span><br><span class="line"></span><br><span class="line">index1 = (n - <span class="number">1</span>) * <span class="number">0.25</span></span><br><span class="line">index2 = (n - <span class="number">1</span>) * <span class="number">0.5</span>  </span><br><span class="line">index3 = (n - <span class="number">1</span>) * <span class="number">0.75</span>  </span><br><span class="line"></span><br><span class="line">index = np.array([index1, index2, index3])</span><br><span class="line">left = np.floor(index).astype(np.int32)</span><br><span class="line">right = np.ceil(index).astype(np.int32)</span><br><span class="line">weight, _ = np.modf(index) <span class="comment"># 获取 index 整数和小数部分</span></span><br><span class="line"></span><br><span class="line">result = x[left] * (<span class="number">1</span> - weight) + x[right] * weight</span><br><span class="line">result</span><br></pre></td></tr></table></figure>




<pre><code>array([2.25, 4.5 , 6.75])</code></pre>
<p><strong>注意点:</strong><br>Numpy 中计算分位数可直接用方法 <code>np.quantile</code> 和 <code>np.percentile</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">np.quantile(x, q=[<span class="number">0.25</span>, <span class="number">0.5</span>, <span class="number">0.75</span>]), np.percentile(x, q=[<span class="number">25</span>, <span class="number">50</span>, <span class="number">75</span>])</span><br></pre></td></tr></table></figure>




<pre><code>(array([2.25, 4.5 , 6.75]), array([2.25, 4.5 , 6.75]))</code></pre>
<p>Pandas 中计算分位数可利用 <code>describe</code> (默认 4 分位)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s = pd.Series(x)</span><br><span class="line">s.describe()</span><br></pre></td></tr></table></figure>




<pre><code>count    10.00000
mean      4.50000
std       3.02765
min       0.00000
25%       2.25000
50%       4.50000
75%       6.75000
max       9.00000
dtype: float64</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s.describe().iloc[<span class="number">4</span>:<span class="number">7</span>]</span><br></pre></td></tr></table></figure>




<pre><code>25%    2.25
50%    4.50
75%    6.75
dtype: float64</code></pre>
<p>可自定义分位:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s.describe(percentiles=[<span class="number">0.15</span>, <span class="number">0.4</span>, <span class="number">0.8</span>])</span><br></pre></td></tr></table></figure>




<pre><code>count    10.00000
mean      4.50000
std       3.02765
min       0.00000
15%       1.35000
40%       3.60000
50%       4.50000
80%       7.20000
max       9.00000
dtype: float64</code></pre>
<h4 id="g-极差"><a href="#g-极差" class="headerlink" title="g, 极差"></a>g, 极差</h4><p>一组数据中, 最大值与最小值之差</p>
<h4 id="h-方差"><a href="#h-方差" class="headerlink" title="h, 方差"></a>h, 方差</h4><p>方差体现一组数据中, 每个元素与均值的偏离程度</p>
<p>$$\sigma^{2}=\frac{1}{n-1} \sum_{i=1}^{n}\left(x_{i}-\bar{x}\right)^{2}$$</p>
<p>$x_{i}:$ 数组中的每个元素<br>$n:$ 数组元素的个数<br>$\bar{x}:$ 数组中所有元素的均值  </p>
<h4 id="i-标准差"><a href="#i-标准差" class="headerlink" title="i, 标准差"></a>i, 标准差</h4><p>标准差为方差的开方. 方差和标准差可以体现数据的分散性, 越大越分散, 越小越集中. 也可体现数据波动性(稳定性), 越大波动越大, 反之亦然  </p>
<p>当数据足够多时, 可用 n 代替 n - 1</p>
<p>例, 计算 <code>left_data</code> 字段的极差, 方差, 标准差:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">sub = np.ptp(data[<span class="string">&#x27;left_data&#x27;</span>])</span><br><span class="line">var = data[<span class="string">&#x27;left_data&#x27;</span>].var()</span><br><span class="line">std = data[<span class="string">&#x27;left_data&#x27;</span>].std()</span><br><span class="line">sub, var, std</span><br></pre></td></tr></table></figure>




<pre><code>(29.0, 41.241399554813675, 6.42194671068)</code></pre>
<p>绘图对比 <code>data1</code> 和 <code>left_data</code> 的分散程度</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">plt.figure(figsize=(<span class="number">11</span>, <span class="number">1</span>))</span><br><span class="line">plt.ylim(<span class="number">-0.5</span>, <span class="number">1.5</span>)</span><br><span class="line">plt.plot(data[<span class="string">&#x27;data1&#x27;</span>], np.zeros(<span class="built_in">len</span>(data)), ls=<span class="string">&#x27;&#x27;</span>, marker=<span class="string">&#x27;o&#x27;</span>, color=<span class="string">&#x27;r&#x27;</span>, label=<span class="string">&#x27;data1&#x27;</span>)</span><br><span class="line">plt.plot(data[<span class="string">&#x27;left_data&#x27;</span>], np.ones(<span class="built_in">len</span>(data)), ls=<span class="string">&#x27;&#x27;</span>, marker=<span class="string">&#x27;o&#x27;</span>, color=<span class="string">&#x27;g&#x27;</span>, label=<span class="string">&#x27;left_data&#x27;</span>)</span><br><span class="line">plt.axvline(data[<span class="string">&#x27;data1&#x27;</span>].mean(), ls=<span class="string">&#x27;--&#x27;</span>, color=<span class="string">&#x27;r&#x27;</span>, label=<span class="string">&#x27;data1均值&#x27;</span>)</span><br><span class="line">plt.axvline(data[<span class="string">&#x27;left_data&#x27;</span>].mean(), ls=<span class="string">&#x27;--&#x27;</span>, color=<span class="string">&#x27;g&#x27;</span>, label=<span class="string">&#x27;left_data均值&#x27;</span>)</span><br><span class="line">plt.legend()</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>


<p><img src="/images/mathematical-statistics/output_25_0.png" alt="png"></p>
<h4 id="j-偏度"><a href="#j-偏度" class="headerlink" title="j, 偏度"></a>j, 偏度</h4><p>统计数据分布偏斜方向和程度的度量, 统计数据分布非对称程度的数字特征, 偏度为 0 , 对称分布, 小于 0, 左偏分别, 大于 0, 右偏分布</p>
<h4 id="k-峰度"><a href="#k-峰度" class="headerlink" title="k, 峰度"></a>k, 峰度</h4><p>表征概率密度分布曲线在平均值处峰值高低的特征数. 直观看来, 峰度反映了峰部的尖度, 峰度高意味着标准差增大是由低频度的大于或小于平均值的极端差值引起的. 在相同的标准差下，峰度越大，分布就有更多的极端值，那么其余值必然要更加集中在众数周围，其分布必然就更加陡峭</p>
<p>样本的峰度是和正态分布相比较而言的统计量, 符合正态分布的峰度为 0</p>
<p>例, 计算 <code>data</code> 中前三个字段的偏度, 峰度与标准差, 并绘图比较:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">print(<span class="string">&#x27;偏度:&#x27;</span>, data[<span class="string">&#x27;data1&#x27;</span>].skew(), data[<span class="string">&#x27;left_data&#x27;</span>].skew(), data[<span class="string">&#x27;right_data&#x27;</span>].skew())</span><br><span class="line">print(<span class="string">&#x27;峰度:&#x27;</span>, data[<span class="string">&#x27;data1&#x27;</span>].kurt(), data[<span class="string">&#x27;left_data&#x27;</span>].kurt(), data[<span class="string">&#x27;right_data&#x27;</span>].kurt())</span><br><span class="line">print(<span class="string">&#x27;标准差:&#x27;</span>, data[<span class="string">&#x27;data1&#x27;</span>].std(), data[<span class="string">&#x27;left_data&#x27;</span>].std(), data[<span class="string">&#x27;right_data&#x27;</span>].std())</span><br></pre></td></tr></table></figure>

<pre><code>偏度: 0.01863368573517327 -1.6482232780416728 0.8893682831648914
峰度: 0.01734807363555335 2.3817050408202034 0.16006510575975996
标准差: 3.0585748897401723 6.42194671068 4.940541290899053</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">sns.kdeplot(data[<span class="string">&#x27;data1&#x27;</span>], shade=<span class="literal">True</span>, label=<span class="string">&#x27;正态&#x27;</span>)</span><br><span class="line">sns.kdeplot(data[<span class="string">&#x27;left_data&#x27;</span>], shade=<span class="literal">True</span>, label=<span class="string">&#x27;左偏&#x27;</span>)</span><br><span class="line">sns.kdeplot(data[<span class="string">&#x27;right_data&#x27;</span>], shade=<span class="literal">True</span>, label=<span class="string">&#x27;右偏&#x27;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>


<p><img src="/images/mathematical-statistics/output_28_0.png" alt="png"></p>
<br>

]]></content>
      <categories>
        <category>数据分析</category>
      </categories>
      <tags>
        <tag>数理统计</tag>
      </tags>
  </entry>
  <entry>
    <title>推断统计</title>
    <url>/data/statistics2-136ca00916f8/</url>
    <content><![CDATA[<blockquote>
<p>文章主要内容和思路来源: <strong>开课吧</strong>学习笔记</p>
</blockquote>
<h2 id="三-推断统计"><a href="#三-推断统计" class="headerlink" title="三, 推断统计"></a>三, 推断统计</h2><p>推断统计, 通过样本推断总体的统计方法, 包括对总体的未知参数进行估计; 对关于参数的假设进行检查; 对总体进行预测预报等. 推断统计的基本问题可以分为两大类：一类是<strong>参数估计</strong>问题; 另一类是<strong>假设检验</strong>问题</p>
<h3 id="1-总体-个体与样本"><a href="#1-总体-个体与样本" class="headerlink" title="1, 总体, 个体与样本"></a>1, 总体, 个体与样本</h3><p>总体, 要研究对象的所有数据, 获取通常比较困难. 总体中的某个数据, 就是个体. 从总体中抽取部分个体, 就构成了样本, 样本中的个体数, 称为样本容量.</p>
<h3 id="2-参数估计"><a href="#2-参数估计" class="headerlink" title="2, 参数估计"></a>2, 参数估计</h3><p>参数估计, 用样本指标(统计量)估计总体指标(参数). 参数估计有<strong>点估计</strong>和<strong>区间估计</strong>两种</p>
<h4 id="2-01-点估计"><a href="#2-01-点估计" class="headerlink" title="2.01, 点估计"></a>2.01, 点估计</h4><p>点估计是依据样本统计量估计总体中的未知参数. 通常它们是总体的某个特征值，如数学期望, 方差和相关系数等. 点估计问题就是要构造一个只依赖于样本的量，作为总体未知参数的估计值.</p>
<h4 id="2-02-区间估计"><a href="#2-02-区间估计" class="headerlink" title="2.02, 区间估计"></a>2.02, 区间估计</h4><p>区间估计是根据样本的统计量, 计算出一个可能的区间(置信区间) 和 概率(置信度), 表示总体的未知参数有多少概率位于该区间. </p>
<p><strong>注意:</strong><br>点估计使用一个值来作为总体参数值, 能给出具体值, 但易受随机抽样影响, 准确性不够<br>区间估计使用一个置信区间和置信度, 表示总体参数值有多少可能(置信度)会在该范围(置信区间)内, 能给出合理的范围和信心指数, 不能给出具体值</p>
<h4 id="2-03-中心极限定理"><a href="#2-03-中心极限定理" class="headerlink" title="2.03, 中心极限定理"></a>2.03, 中心极限定理</h4><p>要确定置信区间与置信度, 我们先要知道总体与样本之间, 在分布上有着怎样的联系. 中心极限定理(独立同分布的中心极限定理)给出了它们之间的联系:</p>
<p>如果总体均值为 $\mu$, 方差为 $\sigma^{2}$, 我们进行随机抽样, 样本容量为 n, 当 n 增大时，则样本均值 $\bar{X}$ 逐渐趋近服从均值为 $\mu$, 方差为 $\sigma^{2} / n$ 的正态分布：</p>
<p>$$\bar{X} \sim N\left(\mu, \sigma^{2} / n\right)$$</p>
<p><strong>说明:</strong><br>进行多次抽样，每次抽样会得到一个均值, 这些均值会围绕在总体均值左右，呈正态分布<br>当样本容量 n 足够大时, 抽样样本均值的均值 ≈ 样本均值 $\bar{X}$ ≈ 总体均值 $\mu$, 样本均值分布的标准差等于 $\sigma / \sqrt{n}$<br>样本均值分布的标准差, 称为标准误差, 简称标准误  </p>
<p>模拟证明:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 定义非正态分布总体(也可以是正态分布)</span></span><br><span class="line">data = np.random.normal(<span class="number">20</span>, <span class="number">5</span>, size=<span class="number">10000</span>)</span><br><span class="line">data.sort()</span><br><span class="line">all_ = np.random.choice(data[<span class="number">0</span>:<span class="number">8000</span>], size=<span class="number">10000</span>)</span><br><span class="line">sns.distplot(all_, label=<span class="string">&#x27;总体分布&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将总体的均值和标准差设为已知条件</span></span><br><span class="line">print(<span class="string">&#x27;总体均值:&#x27;</span>, all_.mean(), <span class="string">&#x27;总体标准差:&#x27;</span>, all_.std())</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建存放每次抽样的平均值的数组(初始值为 0)</span></span><br><span class="line">mean_arr = np.zeros(<span class="number">1000</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 循环抽取 1000 个样本, 每次抽 100 个</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(mean_arr)):</span><br><span class="line">    mean_arr[i] = np.random.choice(all_, size=<span class="number">100</span>, replace=<span class="literal">False</span>).mean()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 验证结果</span></span><br><span class="line">print(<span class="string">&#x27;样本均值:&#x27;</span>, mean_arr[<span class="number">1</span>], <span class="string">&#x27;样本均值的均值:&#x27;</span>, mean_arr.mean(), </span><br><span class="line">      <span class="string">&#x27;标准误差:&#x27;</span>, mean_arr.std(), <span class="string">&#x27;偏度:&#x27;</span>, pd.Series(mean_arr).skew(), sep=<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">sns.distplot(mean_arr, label=<span class="string">&#x27;样本均值分布&#x27;</span>)</span><br><span class="line">plt.legend()</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>

<pre><code>总体均值: 18.21972188896503 总体标准差: 3.746872923755833
样本均值:
18.227008580631708
样本均值的均值:
18.221448457496017
标准误差:
0.3638614618535304
偏度:
-0.15476133964256097</code></pre>
<p><img src="/images/mathematical-statistics/output_1_1.png" alt="png"></p>
<h4 id="2-04-正态分布的特性"><a href="#2-04-正态分布的特性" class="headerlink" title="2.04, 正态分布的特性"></a>2.04, 正态分布的特性</h4><p>正态分布: $X \sim N\left(\mu, \sigma^{2}\right)$</p>
<p><img src="/images/mathematical-statistics/zttx.png" alt="png"></p>
<p>以均值为中心:<br>在 1 倍标准差内包含约 68.2% 的样本数据<br>在 2 倍标准差内包含约 95.4% 的样本数据<br>在 3 倍标准差内包含约 99.7% 的样本数据</p>
<p>证明:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 定义标准差</span></span><br><span class="line">scale = <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义数据</span></span><br><span class="line">x = np.random.normal(<span class="number">0</span>, scale, size=<span class="number">100000</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算</span></span><br><span class="line"><span class="keyword">for</span> times <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">4</span>):</span><br><span class="line">    y = x[(x &gt; -times * scale) &amp; (x &lt; times * scale)]</span><br><span class="line">    print(<span class="string">f&#x27;<span class="subst">&#123;times&#125;</span>倍的标准差:&#x27;</span>)</span><br><span class="line">    print(<span class="string">f&#x27;<span class="subst">&#123;<span class="built_in">len</span>(y) * <span class="number">100</span> / <span class="built_in">len</span>(x)&#125;</span>%&#x27;</span>)</span><br></pre></td></tr></table></figure>

<pre><code>1倍的标准差:
68.075%
2倍的标准差:
95.446%
3倍的标准差:
99.737%</code></pre>
<h4 id="2-05-重要结论"><a href="#2-05-重要结论" class="headerlink" title="2.05, 重要结论"></a>2.05, 重要结论</h4><p>根据中心极限定理和正态分布的特性, 如果总体标准差为$\sigma$, 对总体进行一次抽样, 如果样本足够大, 则样品均值 $\bar{X}$ 服从正态分布, 该均值约有 95.4% 的概率会在 2 倍的标准误差 ($\mu - 2\sigma / \sqrt{n}, \mu + 2\sigma / \sqrt{n}$) 范围内, 并且该样本均值约等于总体均值 $\mu$. 从而, 可以利用这一结论, 对总体均值进行区间估计.</p>
<p><strong>结论验证:</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 随机生成总体均值, 其值未知</span></span><br><span class="line">mean = np.random.randint(<span class="number">0</span>, <span class="number">10000</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 总体的标准差已知为 50</span></span><br><span class="line">std = <span class="number">50</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义总体数据</span></span><br><span class="line">all_ = np.random.normal(mean, std, size=<span class="number">100000</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 从总体抽取 100 个元素构成样本</span></span><br><span class="line">sample = np.random.choice(all_, size=<span class="number">100</span>, replace=<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算样本均值</span></span><br><span class="line">sample_mean = sample.mean()</span><br><span class="line">print(<span class="string">&#x27;样本均值:&#x27;</span>, sample_mean)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算样本的标准误差</span></span><br><span class="line">se = std / np.sqrt(n)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算置信区间 95%置信度</span></span><br><span class="line">min_ = sample_mean - <span class="number">1.96</span> * se</span><br><span class="line">max_ = sample_mean + <span class="number">1.96</span> * se</span><br><span class="line">print(<span class="string">&#x27;置信区间(95%置信度):&#x27;</span>, (min_, max_))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 区间估计</span></span><br><span class="line">print(<span class="string">f&#x27;总体均值有 95% 的概率在<span class="subst">&#123;(min_, max_)&#125;</span>区间内&#x27;</span>)</span><br><span class="line">print(<span class="string">&#x27;总体均值:&#x27;</span>, mean)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 绘图辅助</span></span><br><span class="line">plt.plot(mean, <span class="number">0</span>, marker=<span class="string">&#x27;*&#x27;</span>, color=<span class="string">&#x27;orange&#x27;</span>, ms=<span class="number">12</span>, label=<span class="string">&#x27;总体均值&#x27;</span>)</span><br><span class="line">plt.plot(sample_mean, <span class="number">0</span>, marker=<span class="string">&#x27;o&#x27;</span>, color=<span class="string">&#x27;r&#x27;</span>, label=<span class="string">&#x27;样本均值&#x27;</span>)</span><br><span class="line">plt.hlines(<span class="number">0</span>, xmin=min_, xmax=max_, color=<span class="string">&#x27;b&#x27;</span>, label=<span class="string">&#x27;置信区间&#x27;</span>)</span><br><span class="line">plt.axvline(min_, <span class="number">0.4</span>, <span class="number">0.6</span>, color=<span class="string">&#x27;r&#x27;</span>, ls=<span class="string">&#x27;--&#x27;</span>, label=<span class="string">&#x27;左边界&#x27;</span>)</span><br><span class="line">plt.axvline(max_, <span class="number">0.4</span>, <span class="number">0.6</span>, color=<span class="string">&#x27;g&#x27;</span>, ls=<span class="string">&#x27;--&#x27;</span>, label=<span class="string">&#x27;右边界&#x27;</span>)</span><br><span class="line">plt.legend()</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>

<pre><code>样品均值: 3792.704816801116
置信区间(95%置信度): (3761.714495731466, 3823.6951378707663)
总体均值有 95% 的概率在(3761.714495731466, 3823.6951378707663)区间内
总体均值: 3789</code></pre>
<p><img src="/images/mathematical-statistics/output_5_1.png" alt="png"></p>
<h3 id="3-假设检验"><a href="#3-假设检验" class="headerlink" title="3, 假设检验"></a>3, 假设检验</h3><p>假设检验(显著性检验), 先对总体做出假设, 然后通过判断样本与总体之间是否存在显著性差异, 来验证总体的假设</p>
<p>假设检验使用了一种类似于 “反证法” 的推理方法，它的特点是：</p>
<ul>
<li><p>先对总体做出两个完全相反的假设, 原假设(设为真) 和 备择假设, 计算后导致不合理现象产生，则拒绝原假设, 接受备择假设, 反之接受原假设, 放弃备择假设</p>
</li>
<li><p>这种 “反证法” 不同于一般的反证法. 所谓不合理现象产生，并非指形式逻辑上的绝对矛盾，而是基于小概率原理：概率很小的事件在一次试验中几乎是不可能发生的，若发生了，就是不合理的.   </p>
</li>
<li><p>怎样才算 “小概率”, 通常可将概率不超过 0.05 的事件称为 “小概率事件” ，也可视具体情形而取 0.1 或 0.01 等. 在假设检验中常记这个概率为 α，称为显著性水平</p>
</li>
</ul>
<p>假设检验可分为正态分布检验, 正态总体均值检验, 非参数检验三类, 本文只介绍<strong>正态总体均值检验</strong>, 包括 Z检验 和 t检验 两种情况</p>
<h4 id="3-01-关键概念"><a href="#3-01-关键概念" class="headerlink" title="3.01, 关键概念:"></a>3.01, 关键概念:</h4><p>对总体参数做出两个完全对立的假设, 分别为:<br><strong>原假设(零假设) $H_{0}$<br>备择假设(对立假设) $H_{1}$</strong></p>
<p><strong>双边假设检验</strong>:<br>$H_{0}: \mu=\mu_{0}, H_{1}: \mu \neq \mu_{0}$ </p>
<p><strong>单边假设检验</strong>:<br>$H_{0}: \mu \geq \mu_{0}, H_{1}: \mu&lt;\mu_{0}$ (**左边检验**)<br>$H_{0}: \mu \leq \mu_{0}, H_{1}: \mu&gt;\mu_{0}$ (<strong>右边检验</strong>)<br>$\mu$ 为总体均值, $\mu_{0}$ 为假设均值 </p>
<p><strong>显著性水平</strong>: 根据需要设定的小概率事件的概率 α (1 - α 为置信度)</p>
<p><strong>检验统计量</strong>(Z 和 t): 用来判断样本均值与总体均值是否存在显著性差异</p>
<p><strong>P值:</strong> 通过检验统计量计算而得的概率值, 表示原假设可被拒绝的最小值(或可支持原假设的概率):<br>P ≤ α, 原假设可被拒绝的最小值比显著性水平还低, 原假设可被拒绝, 则拒绝原假设<br>P &gt; α, 原假设可被拒绝的最小值大于显著性水平, 原假设不可被拒绝, 支持原假设</p>
<h4 id="3-02-假设检验的步骤"><a href="#3-02-假设检验的步骤" class="headerlink" title="3.02, 假设检验的步骤"></a>3.02, 假设检验的步骤</h4><p>设置原假设与备择假设<br>设置显著性水平 α<br>根据问题选择假设检验的方式<br>计算统计量(Z 或 t)<br>计算 P值(Z 或 t 围成的分布面积)<br>根据 P值 与 α值, 决定接受原假设还是备择假设</p>
<p>例, 某车间用一台包装机包装葡萄糖. 袋装糖的净重是一个随机变量，它服从正态分布. 当机器正常时，其均值为 0.5kg，标准差为 0.015kg. 某日开工后为检验包装机是否正常，随机地抽取它所包装的糖 9 袋，称得净重为(kg):<br>0.497, 0.506, 0.518, 0.524, 0.498, 0.511, 0.520, 0.515, 0.512<br>判断下面说法是否正确:<br>(1) 机器正常    </p>
<p>例, 某车间用包装机包装葡萄糖. 袋装糖的净重是一个随机变量，它服从正态分布. 随机地抽取糖 9 袋，称得净重为(kg):<br>0.497, 0.506, 0.518, 0.524, 0.498, 0.511, 0.520, 0.515, 0.512<br>判断下面说法是否正确:<br>(2) 该车间袋装糖净重均值为 0.5kg<br>(3) 该车间袋装糖净重均值不少于 0.5kg<br>(4) 该车间袋装糖净重均值不多于 0.5kg</p>
<h4 id="3-03-Z检验"><a href="#3-03-Z检验" class="headerlink" title="3.03, Z检验"></a>3.03, Z检验</h4><p>Z检验适用于: 总体正态分布且方差已知, 样本容量较大(一般 ≥ 30)</p>
<p>Z统计量计算公式:</p>
<p>$$Z=\frac{\bar{x}-\mu_{0}}{S_{\bar{x}}}=\frac{\bar{x}-\mu_{0}}{\sigma / \sqrt{n}}$$</p>
<p>$\bar{x}$: 样本均值<br>$\mu_{0}$: 假设的总体均值<br>$S_{\bar{x}}$: 样本的标准误差<br>$\sigma$: 总体的标准差<br>$n$: 样本容量  </p>
<p>检验说法(1): 机器正常 </p>
<p>双边检验:<br>原假设机器正常: $H_{0}: \mu=\mu_{0}=0.5kg$<br>备择假设机器不正常: $H_{1}: \mu \neq \mu_{0} \neq 0.5kg$<br>设置显著性水平: α = 0.05</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> scipy <span class="keyword">import</span> stats</span><br><span class="line"></span><br><span class="line"><span class="comment"># 样本已知</span></span><br><span class="line">a = np.array([<span class="number">0.497</span>, <span class="number">0.506</span>, <span class="number">0.518</span>, <span class="number">0.524</span>, <span class="number">0.498</span>, <span class="number">0.511</span>, <span class="number">0.520</span>, <span class="number">0.515</span>, <span class="number">0.512</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 总体均值和标准差已知</span></span><br><span class="line">mean, std = <span class="number">0.5</span>, <span class="number">0.015</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算样本均值</span></span><br><span class="line">sample_mean = a.mean()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算样本标准误差</span></span><br><span class="line">se = std / np.sqrt(<span class="built_in">len</span>(a))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算 Z统计量</span></span><br><span class="line">Z = (sample_mean - mean) / se</span><br><span class="line">print(<span class="string">&#x27;Z统计量:&#x27;</span>, Z)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算 P值, 双边检验: Z值与其右边曲线围成的面积的 2 倍</span></span><br><span class="line">P = <span class="number">2</span> * stats.norm.sf(<span class="built_in">abs</span>(Z))</span><br><span class="line"></span><br><span class="line">print(<span class="string">&#x27;P值:&#x27;</span> , P)</span><br></pre></td></tr></table></figure>

<pre><code>Z统计量: 2.244444444444471
P值: 0.02480381963225589</code></pre>
<p><img src="/images/mathematical-statistics/mianji.png"></p>
<p>由结果可知, Z值 超过了 1.96, 由 Z值 与其右边曲线围成的面积的 2 倍, 必然小于 α(1.96 与其右边曲线围成的面积的 2 倍), 计算结果 P &lt; α, 因此拒绝原假设, 接受备择假设, 机器不正常</p>
<h4 id="3-04-t检验"><a href="#3-04-t检验" class="headerlink" title="3.04, t检验"></a>3.04, t检验</h4><p>t检验适用于: 总体正态分布, 方差未知, 样本数量较少(一般 &lt; 30), 但是随着样本容量的增加, 分布逐渐趋于正态分布</p>
<p><img src="/images/mathematical-statistics/tzyd.png"></p>
<p>t统计量计算公式:</p>
<p>$$t=\frac{\bar{x}-\mu_{0}}{S_{\bar{x}}}=\frac{\bar{x}-\mu_{0}}{S / \sqrt{n}}$$</p>
<p>$\bar{x}$: 样本均值<br>$\mu_{0}$: 假设的总体均值<br>$S_{\bar{x}}$: 样本的标准误差<br>$S$: 样本的标准差<br>$n$: 样本容量  </p>
<p><strong>双边检验</strong>:<br>检验说法(2): 该车间袋装糖净重均值为 0.5kg </p>
<p>原假设, 该车间袋装糖净重均值为 0.5kg: $H_{0}: \mu=\mu_{0}=0.5kg$<br>备择假设, 该车间袋装糖净重均值不为 0.5kg: $H_{1}: \mu \neq \mu_{0} \neq 0.5kg$<br>设置显著性水平: α = 0.05</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 样本已知</span></span><br><span class="line">a = np.array([<span class="number">0.497</span>, <span class="number">0.506</span>, <span class="number">0.518</span>, <span class="number">0.524</span>, <span class="number">0.498</span>, <span class="number">0.511</span>, <span class="number">0.520</span>, <span class="number">0.515</span>, <span class="number">0.512</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 假设的总体均值已知</span></span><br><span class="line">mean = <span class="number">0.5</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算样本均值</span></span><br><span class="line">sample_mean = a.mean()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算样本标准差</span></span><br><span class="line">std = a.std()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算 t统计量</span></span><br><span class="line">t = (sample_mean - mean) / ( std / np.sqrt(<span class="built_in">len</span>(a)))</span><br><span class="line">print(<span class="string">&#x27;t统计量:&#x27;</span>, t)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算 P值, df 是自由度: 样本变量可自由取值的个数</span></span><br><span class="line">P = <span class="number">2</span> * stats.t.sf(<span class="built_in">abs</span>(t), df=<span class="built_in">len</span>(a) - <span class="number">1</span>)</span><br><span class="line">print(<span class="string">&#x27;P值:&#x27;</span>, P)</span><br></pre></td></tr></table></figure>

<pre><code>t统计量: 3.802382179137283
P值: 0.005218925008708613</code></pre>
<p>P &lt; α, 拒绝原假设, 接受备择假设: 该车间袋装糖净重均值不为 0.5kg</p>
<p>还可以通过 scipy 提供的方法 <code>ttest_1samp</code> 来进行 t检验计算:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">stats.ttest_1samp(a, <span class="number">0.5</span>)</span><br></pre></td></tr></table></figure>




<pre><code>Ttest_1sampResult(statistic=3.584920298041139, pvalue=0.007137006417828698)</code></pre>
<p><strong>左边检验</strong>:<br>检验说法(3): 该车间袋装糖净重均值不少于 0.5kg  </p>
<p>原假设, 该车间袋装糖净重均值不少于 0.5kg: $H_{0}: \mu \geq \mu_{0}$<br>备择假设, 该车间袋装糖净重均值少于 0.5kg: $H_{1}: \mu&lt;\mu_{0}$<br>设置显著性水平: α = 0.05  </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># t统计量上述已经计算, 只需计算 P值: t统计量与其左边曲线围成的面积</span></span><br><span class="line">P = stats.t.cdf(t, df=<span class="built_in">len</span>(a) - <span class="number">1</span>)</span><br><span class="line">print(<span class="string">&#x27;P值:&#x27;</span>, P)</span><br></pre></td></tr></table></figure>

<pre><code>P值: 0.9973905374956458</code></pre>
<p>P &gt; α, 接受原假设, 该车间袋装糖净重均值不少于 0.5kg</p>
<p><strong>右边检验</strong>:<br>检验说法(4): 该车间袋装糖净重均值不多于 0.5kg  </p>
<p>原假设, 该车间袋装糖净重均值不多于 0.5kg: $H_{0}: \mu \leq \mu_{0}$<br>备择假设, 该车间袋装糖净重均值多于 0.5kg: $H_{1}: \mu&gt;\mu_{0}$<br>设置显著性水平: α = 0.05 </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 计算 P值: t统计量与其右边曲线围成的面积</span></span><br><span class="line">P = stats.t.sf(t, df=<span class="built_in">len</span>(a) - <span class="number">1</span>)</span><br><span class="line">print(<span class="string">&#x27;P值:&#x27;</span>, P)</span><br></pre></td></tr></table></figure>

<pre><code>P值: 0.0026094625043543065</code></pre>
<p>P &lt; α, 拒绝原假设, 接受备择假设, 该车间袋装糖净重均值多于 0.5kg</p>
<br>
]]></content>
      <categories>
        <category>数据分析</category>
      </categories>
      <tags>
        <tag>数理统计</tag>
      </tags>
  </entry>
  <entry>
    <title>线性回归</title>
    <url>/data/statistics3-1967a7845ced/</url>
    <content><![CDATA[<blockquote>
<p>文章主要内容和思路来源: <strong>开课吧</strong>学习笔记</p>
</blockquote>
<h2 id="四-线性回归"><a href="#四-线性回归" class="headerlink" title="四, 线性回归"></a>四, 线性回归</h2><h3 id="1-模型"><a href="#1-模型" class="headerlink" title="1, 模型"></a>1, 模型</h3><p>模型是指对于某个(类)实际问题的求解或客观事物运行规律进行抽象后的一种形式化表达方式, 可以理解为一个函数(一种映射规则)</p>
<p>任何模型都是由三个部分组成: 目标, 变量和关系. 建模时明确了模型的目标，才能进一步确定影响目标(因变量)的各关键变量(自变量)，进而确定变量之间的关系(函数关系)</p>
<p>通过大量数据检验(训练)模型, 将模型(函数)的各个参数求解, 当参数确定之后, 便可利用模型对未知数据进行求值, 预测</p>
<p>用于训练模型的样本数据中的每个属性称为特征, 用 x 表示, 样本中的每条数据经过模型计算得到的输出值称为标签(监督学习), 用 y 表示, 从而得到 y = f(x) 的函数关系</p>
<h3 id="2-回归分析"><a href="#2-回归分析" class="headerlink" title="2, 回归分析"></a>2, 回归分析</h3><p>在统计学中, 回归分析指的是确定两种或两种以上变量间相互依赖的定量关系的一种统计分析方法</p>
<p>回归分析按照涉及的变量的多少，分为一元回归分析和多元回归分析；按照因变量的多少，可分为简单回归分析和多重回归分析；按照自变量和因变量之间的关系类型，可分为线性回归分析和非线性回归分析</p>
<p>回归分析解释自变量 x 发生改变, 因变量 y 会如何改变</p>
<p><strong>拟合</strong>, 插值 和 逼近 是数值分析的三大基础工具. 线性回归和非线性回归, 也叫线性拟合和非线性拟合, 拟合就是从整体上靠近已知点列，构造一种算法(模型或函数), 使得算法能够更加符合真实数据</p>
<h3 id="3-简单线性回归"><a href="#3-简单线性回归" class="headerlink" title="3, 简单线性回归"></a>3, 简单线性回归</h3><p>线性回归分析的自变量和因变量之间是线性关系, 只有一个自变量时称为<strong>简单线性回归</strong>, 多个自变量时称为<strong>多元线性回归</strong></p>
<p>简单线性回归方程:</p>
<p>$$\hat{y}=w * x+b$$</p>
<p>$\hat{y}$ 为因变量, x 为自变量, w 为比例关系, b 为截距, w 和 b 就是模型的参数. 例如房屋价格与房屋面积的正比例关系</p>
<h3 id="4-多元线性回归"><a href="#4-多元线性回归" class="headerlink" title="4, 多元线性回归"></a>4, 多元线性回归</h3><p>现实生活中自变量通常不止一个, 例如影响房屋价格的, 除了房屋面积, 还有交通, 地段, 新旧, 楼层等等因素. 不同的因素对房屋的价格影响力度(权重)不同, 因此使用多个因素来分析房屋的价格(各个因素与房屋价格近似线性关系), 可以得出多元线性回归方程:</p>
<p>$\hat{y}=w_{1} * x_{1}+w_{2} * x_{2}+w_{3} * x_{3}+\cdots+w_{n} * x_{n}+b$</p>
<p>$x$: 影响因素, 特征<br>$w$: 每个 x 的影响力度<br>$n$: 特征个数<br>$\hat{y}$: 房屋的预测价格  </p>
<p>令:</p>
<p>$$\left{\begin{array}{l}<br>x_{0}=1 \<br>w_{0}=b<br>\end{array}\right.$$</p>
<p>设 $\vec{w}$ 和 $\vec{x}$ 为两个向量如下:</p>
<p>$$\begin{array}{l}<br>\vec{w}=\left(w_{0}, w_{1}, w_{2}, w_{3}, \ldots, w_{n}\right)^{T} \<br>\vec{x}=\left(x_{0}, x_{1}, x_{2}, x_{3}, \ldots, x_{n}\right)^{T}<br>\end{array}$$</p>
<p>则方程可表示为: </p>
<p>$$\begin{aligned}<br>\hat{y} &amp;=w_{0} * x_{0}+w_{1} * x_{1}+w_{2} * x_{2}+w_{3} * x_{3}+\ldots \ldots+w_{n} * x_{n} \<br>&amp;=\sum_{j=0}^{n} w_{j} * x_{j} \<br>&amp;=\vec{w}^{T} \cdot \vec{x}<br>\end{aligned}$$</p>
<p>接下来只需要计算出参数 $\vec{w}^{T}$, 便可以建立模型</p>
<h3 id="5-损失函数"><a href="#5-损失函数" class="headerlink" title="5, 损失函数"></a>5, 损失函数</h3><p>损失函数, 用来衡量模型预测值与真实值之间的差异的函数, 也称目标函数或代价函数. 损失函数的值越小, 表示预测值与真实值之间的差异越小.</p>
<p>因此, 求解上述模型的参数 $\vec{w}^{T}$, 就是要建立一个关于模型参数的损失函数(以模型参数 $\vec{w}^{T}$ 为自变量的函数), 然而 $\vec{w}^{T}$ 的取值组合是无限的, 目标就是通过机器学习, 求出一组最佳组合, 使得损失函数的值最小</p>
<p>在线性回归中, 使用平方损失函数(最小二乘法), 用 J(w) 表示:</p>
<p>$$\begin{array}{l}<br>J(w)=\frac{1}{2} \sum_{i=1}^{m}\left(y^{(i)}-\hat{y}^{(i)}\right)^{2} \<br>=\frac{1}{2} \sum_{i=1}^{m}\left(y^{(i)}-\vec{w}^{T} \vec{x}^{(i)}\right)^{2}<br>\end{array}$$</p>
<p>m: 样本(训练集)数据的条数<br>$y^{(i)}$: 样本第 i 条数据的真实值<br>$\hat{y}^{(i)}$: 样本第 i 条数据的预测值<br>$\vec{x}^{(i)}$: 样本第 i 条数据的特征  </p>
<p>m, $y^{(i)}$ 和 $\vec{x}^{(i)}$ 已知, 要使 J(w) 最小, 对 $\vec{w}^{T}$ 求导并令导数等于 0 , 便可求得 $\vec{w}^{T}$, 然后将样本(训练集)输入通过机器学习计算出具体的 $\vec{w}^{T}$</p>
<h3 id="6-回归模型评估"><a href="#6-回归模型评估" class="headerlink" title="6, 回归模型评估"></a>6, 回归模型评估</h3><p>建立模型之后, 模型的效果如何, 需要进行评估, 对于回归模型, 可用如下指标来衡量:</p>
<p><strong>MSE</strong>:<br>平均平方误差, 所有样本数据误差的平方和取均值:</p>
<p>$$M S E=\frac{1}{m} \sum_{i=1}^{m}\left(y^{(i)}-\hat{y}^{(i)}\right)^{2}$$</p>
<p><strong>RMSE</strong>:<br>平均平方误差的平方根:</p>
<p>$$R M S E=\sqrt{M S E}=\sqrt{\frac{1}{m} \sum_{i=1}^{m}\left(y^{(i)}-\hat{y}^{(i)}\right)^{2}}$$</p>
<p><strong>MAE</strong>:<br>平均绝对值误差, 所有样本数据误差的绝对值的和取均值:</p>
<p>$$M A E=\frac{1}{m} \sum_{i=1}^{m}\left|y^{(i)}-\hat{y}^{(i)}\right|$$</p>
<p>上述指标越小越好, 小到什么程度, 不同的对象建立的模型不一样</p>
<p><strong>R²</strong>:<br>决定系数，反应因变量的全部变异能通过回归关系被自变量解释的比例. 如 R²=0.8，则表示回归关系可以解释因变量 80% 的变异. 换句话说，如果我们能控制自变量不变，则因变量的变异程度会减少 80%</p>
<p>在训练集中 R² 取值范围为 [0, 1], 在测试集(未知数据)中, R² 的取值范围为 [-∞, 1], R² 的值越大, 模型拟合越好</p>
<p>R² 的计算公式: </p>
<p>$$R^{2}=1-\frac{R S S}{T S S}=1-\frac{\sum_{i=1}^{m}\left(y^{(i)}-\hat{y}^{(i)}\right)^{2}}{\sum_{i=1}^{m}\left(y^{(i)}-\bar{y}\right)^{2}}$$</p>
<p>$\bar{y}$: 样本(测试集)的平均值</p>
<p>不管何种对象建立的模型, R² 都是越大模拟越好</p>
<p><strong>例一, 简单线性回归模型: 求鸢尾花花瓣长度和宽度的关系</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment"># 导入用于线性回归的类</span></span><br><span class="line"><span class="keyword">from</span> sklearn.linear_model <span class="keyword">import</span> LinearRegression</span><br><span class="line"></span><br><span class="line"><span class="comment"># 切分训练集与测试集的模块</span></span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line"></span><br><span class="line"><span class="comment"># 鸢尾花数据集</span></span><br><span class="line"><span class="keyword">from</span> sklearn.datasets <span class="keyword">import</span> load_iris</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置输出数据的精度为 2 (默认是8)</span></span><br><span class="line">np.set_printoptions(precision=<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取花瓣长度 x, 宽度 y</span></span><br><span class="line">iris = load_iris()</span><br><span class="line">x, y = iris.data[:, <span class="number">2</span>].reshape(<span class="number">-1</span>, <span class="number">1</span>), iris.data[:, <span class="number">3</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将数据拆分为训练集和测试集, 指定测试集占比 test_size</span></span><br><span class="line"><span class="comment"># 指定随机种子 random_state(可以任意值但必须确定), 锁定拆分行为</span></span><br><span class="line">x_train, x_test, y_train, y_test = train_test_split(</span><br><span class="line">    x, y, test_size=<span class="number">0.25</span>, random_state=<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用训练集训练模型</span></span><br><span class="line">lr = LinearRegression()</span><br><span class="line">lr.fit(x_train, y_train)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 求得模型参数</span></span><br><span class="line">print(<span class="string">&#x27;权重 w:&#x27;</span>, lr.coef_, <span class="string">&#x27;截距 b:&#x27;</span>, lr.intercept_)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 调用模型进行预测</span></span><br><span class="line">y_hat = lr.predict(x_test)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果可视化</span></span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">plt.rcParams[<span class="string">&#x27;font.family&#x27;</span>] = <span class="string">&#x27;SimHei&#x27;</span></span><br><span class="line">plt.rcParams[<span class="string">&#x27;axes.unicode_minus&#x27;</span>] = <span class="literal">False</span></span><br><span class="line">plt.rcParams[<span class="string">&#x27;font.size&#x27;</span>] = <span class="number">10</span></span><br><span class="line"></span><br><span class="line">plt.scatter(x_train, y_train, c=<span class="string">&#x27;orange&#x27;</span>, label=<span class="string">&#x27;训练集&#x27;</span>)</span><br><span class="line">plt.scatter(x_test, y_test, c=<span class="string">&#x27;g&#x27;</span>, marker=<span class="string">&#x27;D&#x27;</span>, label=<span class="string">&#x27;测试集&#x27;</span>)</span><br><span class="line">plt.plot(x, lr.predict(x), <span class="string">&#x27;r-&#x27;</span>)</span><br><span class="line">plt.legend()</span><br><span class="line">plt.xlabel(<span class="string">&#x27;花瓣长度&#x27;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;花瓣宽度&#x27;</span>)</span><br><span class="line">plt.show()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 模型评估</span></span><br><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> mean_squared_error, mean_absolute_error, r2_score</span><br><span class="line"></span><br><span class="line">print(<span class="string">&#x27;MSE:&#x27;</span>, mean_squared_error(y_test, y_hat))</span><br><span class="line">print(<span class="string">&#x27;RMSE:&#x27;</span>, np.sqrt(mean_squared_error(y_test, y_hat)))</span><br><span class="line">print(<span class="string">&#x27;MAE:&#x27;</span>, mean_absolute_error(y_test, y_hat))</span><br><span class="line">print(<span class="string">&#x27;训练集R²:&#x27;</span>, r2_score(y_train, lr.predict(x_train))) <span class="comment"># 可换成 lr.score(x_train, y_train)</span></span><br><span class="line">print(<span class="string">&#x27;测试集R²:&#x27;</span>, r2_score(y_test, y_hat)) <span class="comment"># 可换成 lr.score(x_test, y_test)</span></span><br></pre></td></tr></table></figure>

<pre><code>权重 w: [0.42] 截距 b: -0.370615595909495</code></pre>
<p><img src="/images/mathematical-statistics/output_1_101.png"></p>
<pre><code>MSE: 0.047866747643216113
RMSE: 0.21878470614559903
MAE: 0.1543808898175286
训练集R²: 0.9317841638431329
测试集R²: 0.9119955391492289</code></pre>
<p><strong>列二, 多元线性回归模型: 波士顿房价预测</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> sklearn.linear_model <span class="keyword">import</span> LinearRegression</span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line"><span class="keyword">from</span> sklearn.datasets <span class="keyword">import</span> load_boston</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line">boston = load_boston()</span><br><span class="line">x, y = boston.data, boston.target</span><br><span class="line">df = pd.DataFrame(np.concatenate([x, y.reshape(<span class="number">-1</span>, <span class="number">1</span>)], axis=<span class="number">1</span>), </span><br><span class="line">                 columns=boston.feature_names.tolist() + [<span class="string">&#x27;MEDV&#x27;</span>])</span><br><span class="line"><span class="comment"># 部分数据</span></span><br><span class="line">df.head(<span class="number">3</span>)</span><br></pre></td></tr></table></figure>




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

<pre><code>.dataframe tbody tr th &#123;
    vertical-align: top;
&#125;

.dataframe thead th &#123;
    text-align: right;
&#125;</code></pre>
<p></style></p>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>CRIM</th>
      <th>ZN</th>
      <th>INDUS</th>
      <th>CHAS</th>
      <th>NOX</th>
      <th>RM</th>
      <th>AGE</th>
      <td>...</td>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>0.00632</td>
      <td>18.0</td>
      <td>2.31</td>
      <td>0.0</td>
      <td>0.538</td>
      <td>6.575</td>
      <td>65.2</td>
      <td>...</td>
    </tr>
    <tr>
      <th>1</th>
      <td>0.02731</td>
      <td>0.0</td>
      <td>7.07</td>
      <td>0.0</td>
      <td>0.469</td>
      <td>6.421</td>
      <td>78.9</td>
      <td>...</td>
    </tr>
    <tr>
      <th>2</th>
      <td>0.02729</td>
      <td>0.0</td>
      <td>7.07</td>
      <td>0.0</td>
      <td>0.469</td>
      <td>7.185</td>
      <td>61.1</td>
      <td>...</td>
    </tr>
  </tbody>
</table>
</div>




<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x_train, x_test, y_train, y_test = train_test_split(</span><br><span class="line">    x, y, test_size=<span class="number">0.25</span>, random_state=<span class="number">5</span>)</span><br><span class="line">lr = LinearRegression()</span><br><span class="line">lr.fit(x_train, y_train)</span><br><span class="line">print(<span class="string">&#x27;权重:&#x27;</span>, lr.coef_)</span><br><span class="line">print(<span class="string">&#x27;截距:&#x27;</span>, lr.intercept_)</span><br><span class="line">y_hat = lr.predict(x_test)</span><br><span class="line">print(<span class="string">&#x27;训练集R²:&#x27;</span>, lr.score(x_train, y_train))</span><br><span class="line">print(<span class="string">&#x27;测试集R²:&#x27;</span>, lr.score(x_test, y_test)) </span><br><span class="line"></span><br><span class="line"><span class="comment"># 假如获取了一间房屋的数据, 预测其房价</span></span><br><span class="line">room_data = np.array([<span class="number">0.00732</span>, <span class="number">17.0</span>, <span class="number">1.31</span>, <span class="number">1.0</span>, <span class="number">0.638</span>, <span class="number">7.575</span>, <span class="number">62.2</span>, <span class="number">5.0900</span>,</span><br><span class="line">                      <span class="number">1.0</span>, <span class="number">296.0</span>, <span class="number">15.3</span>, <span class="number">396.90</span>, <span class="number">4.98</span>]).reshape(<span class="number">1</span>, <span class="number">-1</span>)</span><br><span class="line">y_price = lr.predict(room_data)</span><br><span class="line">print(<span class="string">&#x27;房屋价格:&#x27;</span>, y_price)</span><br></pre></td></tr></table></figure>

<pre><code>权重: [-1.53004848e-01  4.79388437e-02 -8.60131597e-03  2.57986675e+00
 -1.46325645e+01  3.96283436e+00 -7.92357629e-03 -1.46078023e+00
  3.45431204e-01 -1.24503134e-02 -9.19092768e-01  1.32203623e-02
 -5.17255347e-01]
截距: 32.214120389743606
训练集R²: 0.7468034208269784
测试集R²: 0.7059096071098042
房屋价格: [33.62048527]</code></pre>
<p>多元线性回归在空间中, 可表示为一个超平面去拟合空间中的数据点</p>
<br>
]]></content>
      <categories>
        <category>数据分析</category>
      </categories>
      <tags>
        <tag>数理统计</tag>
      </tags>
  </entry>
  <entry>
    <title>逻辑回归</title>
    <url>/data/statistics4-344a69d01fea/</url>
    <content><![CDATA[<blockquote>
<p>文章主要内容和思路来源: <strong>开课吧</strong>学习笔记</p>
</blockquote>
<h2 id="五-逻辑回归"><a href="#五-逻辑回归" class="headerlink" title="五, 逻辑回归"></a>五, 逻辑回归</h2><p>逻辑回归和线性回归有类似之处, 都是利用线性加权计算的模型, 但逻辑回归是分类算法, 例如对是否患癌症进行预测, 因变量就是 <strong>是</strong> 和 <strong>否</strong>, 两个类别, 自变量可以是年龄, 性别, 饮食, 作息, 病菌感染等, 自变量既可以是数值变量, 也可以是类别变量</p>
<h3 id="1-逻辑回归二分类推导"><a href="#1-逻辑回归二分类推导" class="headerlink" title="1, 逻辑回归二分类推导"></a>1, 逻辑回归二分类推导</h3><p>和线性回归类似, 设自变量为 x, 每个自变量的权重为 w, 令:</p>
<p>$$\begin{array}{l}<br>z=w_{1} x_{1}+w_{2} x_{2}+\cdots+w_{n} x_{n}+b \<br>=\sum_{j=1}^{n} w_{j} x_{j}+b \<br>=\sum_{j=0}^{n} w_{j} x_{j} \<br>=\vec{w}^{T} \cdot \vec{x}<br>\end{array}$$</p>
<p>z 是一个连续值, 取值范围(-∞, +∞), 为了实现分类, 一般设置阈值 z = 0, 当 z &gt; 0 时, 将样本判定为一个类别(正例), 该类别设为 1, 当 z ≤ 0 时, 判定为另一个类别(负例), 该类别设为 0, 再设因变量为 y, 从而逻辑回归方程可表示为:</p>
<p>$$y=\left{\begin{array}{ll}<br>1 &amp; z&gt;0 \<br>0 &amp; z \leq 0<br>\end{array}\right.$$</p>
<p>上述方程虽然实现了分类, 但提供的信息有限, 因此引入 <strong>sigmoid函数</strong>(也叫 Logistic函数), 将 z 映射到 (0, 1) 区间，可以实现二分类的同时, 还能体现将样本分为某个类的可能性, 这个可能性设为 p:</p>
<p>$$p=\operatorname{sigmoid}(z)=\frac{1}{1+e^{-z}}$$</p>
<p>sigmoid 函数图像如下:</p>
<p><img src="/images/mathematical-statistics/sigmoid.png"></p>
<p>于是, 逻辑回归方程又可表示为:</p>
<p>$$y=\left{\begin{array}{ll}<br>1 &amp; p&gt;0.5 \<br>0 &amp; 1-p \geq 0.5<br>\end{array}\right.$$</p>
<p>从而可见, 通过比较 p 和 1-p 哪个更大(z 的阈值不取 0 时做出调整即可), 预测结果就是对应的一类</p>
<h3 id="2-逻辑回归的损失函数"><a href="#2-逻辑回归的损失函数" class="headerlink" title="2, 逻辑回归的损失函数"></a>2, 逻辑回归的损失函数</h3><p>通过上述推导过程可知, 要得到逻辑回归模型, 最终就是要求得参数 $\vec{w}^{T}$, 于是将 p 和 1-p 统一, 构造一个损失函数来求 $\vec{w}^{T}$:</p>
<p>$$\begin{array}{l}<br>p(y=1 | x ; w)=s(z) \<br>p(y=0 | x ; w)=1-s(z)<br>\end{array}$$</p>
<p>合并:</p>
<p>$$p(y | x ; w)=s(z)^{y}(1-s(z))^{1-y}$$</p>
<p>上式表示一个样本的概率, 我们要求解能够使所有样本联合概率密度最大的 $\vec{w}^{T}$ 值, 根据极大似然估计, 所有样本的联合概率密度函数(似然函数)为:</p>
<p>$$\begin{array}{l}<br>L(w)=\prod_{i=1}^{m} p\left(y^{(i)} | x^{(i)} ; w\right) \<br>=\prod_{i=1}^{m} s\left(z^{(i)}\right)^{y^{(i)}}\left(1-s\left(z^{(i)}\right)\right)^{1-y^{(i)}}<br>\end{array}$$</p>
<p>取对数, 让累积乘积变累积求和:</p>
<p>$$\begin{array}{l}<br>\ln L(w)=\ln \left(\prod_{i=1}^{m} s\left(z^{(i)}\right)^{y^{(i)}}\left(1-s\left(z^{(i)}\right)^{1-y^{(i)}}\right)\right) \<br>=\sum_{i=1}^{m}\left(y^{(i)} \ln s\left(z^{(i)}\right)+\left(1-y^{(i)}\right) \ln \left(1-s\left(z^{(i)}\right)\right)\right)<br>\end{array}$$</p>
<p>要求上式最大值, 取反变成求最小值, 就作为逻辑回归的损失函数(交叉熵损失函数):</p>
<p>$$J(w)=-\sum_{i=1}^{m}\left(y^{(i)} \ln s\left(z^{(i)}\right)+\left(1-y^{(i)}\right) \ln \left(1-s\left(z^{(i)}\right)\right)\right)$$</p>
<p>利用梯度下降法最终求得 $\vec{w}^{T}$ (省略)</p>
<p>例, 对鸢尾花实现二分类并分析:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.linear_model <span class="keyword">import</span> LogisticRegression</span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line"><span class="keyword">from</span> sklearn.datasets <span class="keyword">import</span> load_iris</span><br><span class="line"><span class="keyword">import</span> warnings</span><br><span class="line"></span><br><span class="line">warnings.filterwarnings(<span class="string">&#x27;ignore&#x27;</span>)</span><br><span class="line"></span><br><span class="line">iris = load_iris()</span><br><span class="line">x, y = iris.data, iris.target</span><br><span class="line"></span><br><span class="line"><span class="comment"># 鸢尾花数据集有 3 个类别, 4 个特性, 取两个类别, 两个特性</span></span><br><span class="line">x = x[y!=<span class="number">0</span>, <span class="number">2</span>:]</span><br><span class="line">y = y[y!=<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 拆分训练集与测试集</span></span><br><span class="line">x_train, x_test, y_train, y_test = train_test_split(x, y,</span><br><span class="line">        test_size=<span class="number">0.25</span>, random_state=<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 训练分类模型</span></span><br><span class="line">lr = LogisticRegression()</span><br><span class="line">lr.fit(x_train, y_train)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 测试</span></span><br><span class="line">y_hat = lr.predict(x_test)</span><br><span class="line">print(<span class="string">&#x27;权重:&#x27;</span>, lr.coef_)</span><br><span class="line">print(<span class="string">&#x27;偏置:&#x27;</span>, lr.intercept_)</span><br><span class="line">print(<span class="string">&#x27;真实值:&#x27;</span>, y_test)</span><br><span class="line">print(<span class="string">&#x27;预测值:&#x27;</span>, y_hat)</span><br></pre></td></tr></table></figure>

<pre><code>权重: [[2.54536368 2.15257324]]
偏置: [-16.08741502]
真实值: [2 1 2 1 1 1 1 1 1 1 2 2 2 1 1 1 1 1 2 2 1 1 2 1 2]
预测值: [2 1 1 1 1 1 1 2 1 1 2 2 2 1 1 1 1 1 2 2 1 1 2 1 2]</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 样本的真实类别可视化</span></span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line">plt.rcParams[<span class="string">&#x27;font.family&#x27;</span>] = <span class="string">&#x27;SimHei&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 取出两种鸢尾花的特征</span></span><br><span class="line">c1 = x[y==<span class="number">1</span>]</span><br><span class="line">c2 = x[y==<span class="number">2</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 绘制样本分布</span></span><br><span class="line">plt.scatter(x=c1[:, <span class="number">0</span>], y=c1[:, <span class="number">1</span>], c=<span class="string">&#x27;g&#x27;</span>, label=<span class="string">&#x27;类别1&#x27;</span>)</span><br><span class="line">plt.scatter(x=c2[:, <span class="number">0</span>], y=c2[:, <span class="number">1</span>], c=<span class="string">&#x27;r&#x27;</span>, label=<span class="string">&#x27;类别2&#x27;</span>)</span><br><span class="line">plt.xlabel(<span class="string">&#x27;花瓣长度&#x27;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;花瓣宽度&#x27;</span>)</span><br><span class="line">plt.title(<span class="string">&#x27;鸢尾花样本分布&#x27;</span>)</span><br><span class="line">plt.legend()</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>


<p><img src="/images/mathematical-statistics/output_2_0.png"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 将预测类别和真实类别可视化对比</span></span><br><span class="line">plt.figure(figsize=(<span class="number">6</span>, <span class="number">2.2</span>))</span><br><span class="line">plt.plot(y_test, marker=<span class="string">&#x27;o&#x27;</span>, ls=<span class="string">&#x27;&#x27;</span>, ms=<span class="number">10</span>, c=<span class="string">&#x27;r&#x27;</span>, label=<span class="string">&#x27;真实类别&#x27;</span>)</span><br><span class="line">plt.plot(y_hat, marker=<span class="string">&#x27;x&#x27;</span>, ls=<span class="string">&#x27;&#x27;</span>, ms=<span class="number">10</span>, c=<span class="string">&#x27;g&#x27;</span>, label=<span class="string">&#x27;预测类别&#x27;</span>)</span><br><span class="line">plt.xlabel(<span class="string">&#x27;样本序号&#x27;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;类别&#x27;</span>)</span><br><span class="line">plt.title(<span class="string">&#x27;预测结果&#x27;</span>)</span><br><span class="line">plt.legend()</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>


<p><img src="/images/mathematical-statistics/output_3_0.png"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 因预测样本所属类别时, 通过比较概率得到结果, </span></span><br><span class="line"><span class="comment"># 我们可将结果对应的概率可视化</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取预测的概率值</span></span><br><span class="line">probability = lr.predict_proba(x_test)</span><br><span class="line">print(<span class="string">&#x27;概率:&#x27;</span>, probability[:<span class="number">5</span>], sep=<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line">index = np.arange(<span class="built_in">len</span>(x_test))</span><br><span class="line">pro_0 = probability[:, <span class="number">0</span>]</span><br><span class="line">pro_1 = probability[:, <span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置预测结果标签, 对和错</span></span><br><span class="line">tick_label = np.where(y_test==y_hat, <span class="string">&#x27;对&#x27;</span>, <span class="string">&#x27;错&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 绘制堆叠图</span></span><br><span class="line">plt.figure(figsize=(<span class="number">8</span>, <span class="number">2</span>))</span><br><span class="line">plt.bar(index, height=pro_0, color=<span class="string">&#x27;g&#x27;</span>, label=<span class="string">&#x27;类别1的概率&#x27;</span>)</span><br><span class="line">plt.bar(index, height=pro_1, color=<span class="string">&#x27;r&#x27;</span>, bottom=pro_0,</span><br><span class="line">        label=<span class="string">&#x27;类别2的概率&#x27;</span>, tick_label=tick_label)</span><br><span class="line">plt.xlabel(<span class="string">&#x27;样本序号&#x27;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;各类别的概率&#x27;</span>)</span><br><span class="line">plt.title(<span class="string">&#x27;分类概率&#x27;</span>)</span><br><span class="line">plt.legend()</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>

<pre><code>概率:
[[0.46933862 0.53066138]
 [0.98282882 0.01717118]
 [0.72589695 0.27410305]
 [0.91245661 0.08754339]
 [0.80288412 0.19711588]]</code></pre>
<p><img src="/images/mathematical-statistics/output_4_1.png"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 绘制决策边界</span></span><br><span class="line"><span class="comment"># 决策边界: 不同类别的分界线</span></span><br><span class="line"><span class="keyword">from</span> matplotlib.colors <span class="keyword">import</span> ListedColormap</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义绘制函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">plot_decision_boundary</span>(<span class="params">model, x, y</span>):</span></span><br><span class="line">    color = [<span class="string">&#x27;r&#x27;</span>, <span class="string">&#x27;g&#x27;</span>, <span class="string">&#x27;b&#x27;</span>]</span><br><span class="line">    marker = [<span class="string">&#x27;o&#x27;</span>, <span class="string">&#x27;v&#x27;</span>, <span class="string">&#x27;x&#x27;</span>]</span><br><span class="line">    class_label = np.unique(y)</span><br><span class="line">    cmap = ListedColormap(color[:<span class="built_in">len</span>(class_label)])</span><br><span class="line">    x1_min, x2_min = np.<span class="built_in">min</span>(x, axis=<span class="number">0</span>)</span><br><span class="line">    x1_max, x2_max = np.<span class="built_in">max</span>(x, axis=<span class="number">0</span>)</span><br><span class="line">    x1 = np.arange(x1_min - <span class="number">1</span>, x1_max + <span class="number">1</span>, <span class="number">0.02</span>)</span><br><span class="line">    x2 = np.arange(x2_min - <span class="number">1</span>, x2_max + <span class="number">1</span>, <span class="number">0.02</span>)</span><br><span class="line">    x1, x2 = np.meshgrid(x1, x2)</span><br><span class="line">    z = model.predict(np.array([x1.ravel(), x2.ravel()]).T).reshape(x1.shape)</span><br><span class="line">    </span><br><span class="line">    plt.contourf(x1, x2, z, cmap=cmap, alpha=<span class="number">0.5</span>)</span><br><span class="line">    <span class="keyword">for</span> i, class_ <span class="keyword">in</span> <span class="built_in">enumerate</span>(class_label):</span><br><span class="line">        plt.scatter(x=x[y==class_, <span class="number">0</span>], y=x[y==class_, <span class="number">1</span>],</span><br><span class="line">                c=cmap.colors[i], label=class_, marker=marker[i])</span><br><span class="line">    plt.legend()</span><br><span class="line">    plt.show()</span><br><span class="line">    </span><br><span class="line"><span class="comment"># 绘制模型在训练集上的决策边界</span></span><br><span class="line">plot_decision_boundary(lr, x_train, y_train)</span><br></pre></td></tr></table></figure>


<p><img src="/images/mathematical-statistics/output_5_0.png"></p>
<p><strong>拓展</strong>:<br>逻辑回归实现多分类</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">iris = load_iris()</span><br><span class="line">x, y = iris.data, iris.target</span><br><span class="line">x = x[:, <span class="number">2</span>:]</span><br><span class="line">x_train, x_test, y_train, y_test = train_test_split(x, y, </span><br><span class="line">        test_size=<span class="number">0.25</span>, random_state=<span class="number">2</span>)</span><br><span class="line">lr = LogisticRegression()</span><br><span class="line">lr.fit(x_train, y_train)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 测试分类</span></span><br><span class="line">y_hat = lr.predict(x_test)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 可视化结果</span></span><br><span class="line">plt.rcParams[<span class="string">&#x27;axes.unicode_minus&#x27;</span>]=<span class="literal">False</span></span><br><span class="line">plot_decision_boundary(lr, x_test, y_test)</span><br></pre></td></tr></table></figure>


<p><img src="/images/mathematical-statistics/output_7_0.png"></p>
<br>

]]></content>
      <categories>
        <category>数据分析</category>
      </categories>
      <tags>
        <tag>数理统计</tag>
      </tags>
  </entry>
  <entry>
    <title>分类模型评估</title>
    <url>/data/statistics5-2abb7ab7c911/</url>
    <content><![CDATA[<blockquote>
<p>文章主要内容和思路来源: <strong>开课吧</strong>学习笔记</p>
</blockquote>
<h2 id="六-分类模型评估"><a href="#六-分类模型评估" class="headerlink" title="六, 分类模型评估"></a>六, 分类模型评估</h2><p>在完成模型训练之后，需要对模型的效果进行评估，根据评估结果继续调整模型的参数, 特征或者算法，以达到满意的结果</p>
<h3 id="1-混淆矩阵"><a href="#1-混淆矩阵" class="headerlink" title="1, 混淆矩阵"></a>1, 混淆矩阵</h3><p>将 真正例(TP), 假正例(FP), 真负例(TN), 假负例(FN) 统计于一个方阵中, 观察比较, 评价模型好坏, 矩阵如下:</p>
<p><img src="/images/mathematical-statistics/hxjz.png"></p>
<p>混淆矩阵统计数量, 评价不直观也有限, 基于混淆矩阵又延伸出 正确率, 精准率, 召回率, F1(调和平均值), ROC曲线和AUC等</p>
<h3 id="2-评估指标分析"><a href="#2-评估指标分析" class="headerlink" title="2, 评估指标分析"></a>2, 评估指标分析</h3><p><strong>正确率:</strong></p>
<p>$$\text { 正确率 }=\frac{T P+T N}{T P+T N+F P+F N}$$</p>
<p>正确率, 表示总体(包括正负)预测正确的比率, 在模型对正例和负例的预测准确度差异较大时, 难以评价模型的好坏, 例如正例较多, 负例较少, 正例全部预测对了, 负例只预测对几个, 正确率却可能较高</p>
<p><strong>精准率:</strong></p>
<p>$$\text { 精准率 }=\frac{T P}{T P+F P}$$</p>
<p>精准率, 表示所有预测为正例的结果中 预测正确的正例 的占比, 精准率越高, 说明正例预测正确概率越高, 因此精准率更关注”一击必中”, 比如通过预测找出上涨的概率很高的一支股票</p>
<p><strong>召回率:</strong></p>
<p>$$\text { 召回率 }=\frac{T P}{T P+F N}$$</p>
<p>召回率, 表示所有真实的正例中, 预测正确的正例 的占比, 召回率越高, 说明正例被”召回”的越多, 因此召回率更关注”宁错一千, 不放一个”, 例如通过预测尽可能将新冠肺炎患者全部隔离观察</p>
<p><strong>调和平均值 F1</strong>:</p>
<p>$$F 1=\frac{2 * \text {精准率} * \text {召回率}}{\text {精准率}+\text {召回率}}$$</p>
<p>F1 将综合了精准率和召回率, F1越高, 说明模型预测效果越好, F1 能够直接评估模型的好坏</p>
<p><strong>ROC曲线:</strong></p>
<p>ROC (Receiver Operating Characteristic) 曲线, 用图像来描述分类模型的性能好坏. 图像纵轴为 真 正例率(TPR), 横轴为 假 正例率(FPR):</p>
<p>$$\begin{array}{l}<br>T P R=\text { 召回率 }=\frac{T P}{T P+F N} \<br>F P R=\frac{F P}{F P+T N}<br>\end{array}$$</p>
<p>上述两式通过取分类模型的不同阈值, 从而计算出不同的值, 绘制出曲线, 曲线必过 (0,0)  和 (1, 1) 两个点, TPR 增长得越快, 曲线越往上凸, 模型的分类性能就越好. 如果 ROC 曲线为对角线, 可将模型理解为随机猜测; 如果 ROC 曲线在 0 点 真 正例率就达到了 1, 此时模型最完美</p>
<p><strong>AUC:</strong></p>
<p>AUC (Area Under the Curve), 是 ROC 曲线下面的面积, 因为有时通过 ROC 曲线看不出哪个分类模型性能好, 而 AUC 比较数值就不存在这样的问题</p>
<p>以鸢尾花数据集做如下练习:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> sklearn.datasets <span class="keyword">import</span> load_iris</span><br><span class="line"><span class="keyword">from</span> sklearn.linear_model <span class="keyword">import</span> LogisticRegression </span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> confusion_matrix</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> warnings</span><br><span class="line"></span><br><span class="line">plt.rcParams[<span class="string">&quot;font.family&quot;</span>] = <span class="string">&quot;SimHei&quot;</span></span><br><span class="line">plt.rcParams[<span class="string">&quot;axes.unicode_minus&quot;</span>] = <span class="literal">False</span> </span><br><span class="line">plt.rcParams[<span class="string">&quot;font.size&quot;</span>] = <span class="number">12</span> </span><br><span class="line">warnings.filterwarnings(<span class="string">&quot;ignore&quot;</span>)</span><br><span class="line"></span><br><span class="line">iris = load_iris()</span><br><span class="line">x, y = iris.data, iris.target</span><br><span class="line">x = x[y!=<span class="number">0</span>, <span class="number">2</span>:]</span><br><span class="line">y = y[y!=<span class="number">0</span>]</span><br><span class="line">x_train, x_test, y_train, y_test = train_test_split(x, y,</span><br><span class="line">                        test_size=<span class="number">0.25</span>, random_state=<span class="number">2</span>)</span><br><span class="line">lr = LogisticRegression()</span><br><span class="line">lr.fit(x_train, y_train)</span><br><span class="line">y_hat = lr.predict(x_test)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 传入真实值与预测值, 创建混淆矩阵</span></span><br><span class="line">matrix = confusion_matrix(y_true=y_test, y_pred=y_hat)</span><br><span class="line">print(matrix)</span><br><span class="line">y_hat[y_hat==<span class="number">1</span>].<span class="built_in">sum</span>()</span><br></pre></td></tr></table></figure>

<pre><code>[[15  1]
 [ 1  8]]

16</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 将混淆矩阵可视化</span></span><br><span class="line">mat = plt.matshow(matrix, cmap=plt.cm.Blues, alpha=<span class="number">0.5</span>)</span><br><span class="line">label = [<span class="string">&quot;负例&quot;</span>, <span class="string">&quot;正例&quot;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取当前的绘图对象</span></span><br><span class="line">ax = plt.gca()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置属性, 设类别 1 为负例</span></span><br><span class="line">ax.<span class="built_in">set</span>(</span><br><span class="line">    xticks=np.arange(matrix.shape[<span class="number">1</span>]), </span><br><span class="line">    yticks=np.arange(matrix.shape[<span class="number">0</span>]),</span><br><span class="line">    xticklabels=label, </span><br><span class="line">    yticklabels=label, </span><br><span class="line">    title=<span class="string">&quot;混淆矩阵可视化\n&quot;</span>, </span><br><span class="line">    ylabel=<span class="string">&quot;真实值&quot;</span>, </span><br><span class="line">    xlabel=<span class="string">&quot;预测值&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置统计值的位置</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(matrix.shape[<span class="number">0</span>]):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(matrix.shape[<span class="number">1</span>]):</span><br><span class="line">        plt.text(x=j, y=i, s=matrix[i, j], va=<span class="string">&quot;center&quot;</span>, ha=<span class="string">&quot;center&quot;</span>) </span><br><span class="line">        </span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>


<p><img src="/images/mathematical-statistics/output_2_0001.png"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 计算各个评估指标</span></span><br><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> accuracy_score, precision_score, recall_score, f1_score</span><br><span class="line"></span><br><span class="line">print(<span class="string">&quot;正确率：&quot;</span>, accuracy_score(y_test, y_hat))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 默认以 1 为正例, 我们将 2 设为正例</span></span><br><span class="line">print(<span class="string">&quot;精准率：&quot;</span>, precision_score(y_test, y_hat, pos_label=<span class="number">2</span>))</span><br><span class="line">print(<span class="string">&quot;召回率：&quot;</span>, recall_score(y_test, y_hat, pos_label=<span class="number">2</span>))</span><br><span class="line">print(<span class="string">&quot;F1：&quot;</span>, f1_score(y_test, y_hat, pos_label=<span class="number">2</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 也可以用逻辑回归模型对象的score方法计算正确率 </span></span><br><span class="line">print(<span class="string">&quot;score方法计算正确率：&quot;</span>, lr.score(x_test, y_test))</span><br></pre></td></tr></table></figure>

<pre><code>正确率： 0.92
精准率： 0.8888888888888888
召回率： 0.8888888888888888
F1： 0.8888888888888888
score方法计算正确率： 0.92</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 还可以用 classification_report 方法直接计算各个指标</span></span><br><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> classification_report</span><br><span class="line">print(classification_report(y_true=y_test, y_pred=y_hat))</span><br></pre></td></tr></table></figure>

<pre><code>              precision    recall  f1-score   support

           1       0.94      0.94      0.94        16
           2       0.89      0.89      0.89         9

    accuracy                           0.92        25
   macro avg       0.91      0.91      0.91        25
weighted avg       0.92      0.92      0.92        25</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 绘制 ROC曲线 和计算 AUC</span></span><br><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> roc_curve, auc, roc_auc_score</span><br><span class="line"></span><br><span class="line">iris = load_iris()</span><br><span class="line">x, y = iris.data, iris.target</span><br><span class="line">x = x[y!=<span class="number">0</span>, <span class="number">2</span>:]</span><br><span class="line">y = y[y!=<span class="number">0</span>]</span><br><span class="line">x_train, x_test, y_train, y_test = train_test_split(x, y,</span><br><span class="line">                            test_size=<span class="number">0.25</span>, random_state=<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置模型参数(有默认值可以不设), 并进行训练</span></span><br><span class="line"><span class="comment"># 不同的参数训练结果不一样, 需要注意参数之间关系</span></span><br><span class="line">lr = LogisticRegression(multi_class=<span class="string">&quot;ovr&quot;</span>, solver=<span class="string">&quot;liblinear&quot;</span>)</span><br><span class="line"><span class="comment"># lr = LogisticRegression(multi_class=&quot;multinomial&quot;)</span></span><br><span class="line">lr.fit(x_train, y_train)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取样本的概率</span></span><br><span class="line">probo = lr.predict_proba(x_test)</span><br><span class="line">print(<span class="string">&#x27;类别 2 的概率:&#x27;</span>, probo[:, <span class="number">1</span>][:<span class="number">5</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将概率值传入 roc_curve 方法, 从概率中选择若干个值作为阈值</span></span><br><span class="line"><span class="comment"># 同时根据阈值判定正负例, 返回 fpr, tpr 和 阈值 thresholds</span></span><br><span class="line">fpr, tpr, thresholds = roc_curve(y_true=y_test,</span><br><span class="line">                       y_score=probo[:, <span class="number">1</span>], pos_label=<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 阈值中的第一个值是第二个值 +1 得到, 为了让让曲线过 0 点</span></span><br><span class="line">print(<span class="string">&#x27;阈值:&#x27;</span>, thresholds)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算 AUC </span></span><br><span class="line">print(<span class="string">&#x27;用auc计算:&#x27;</span>, auc(fpr, tpr))</span><br><span class="line">print(<span class="string">&#x27;用roc_auc_score计算:&#x27;</span>, roc_auc_score(y_true=y_test,</span><br><span class="line">                                    y_score=probo[:, <span class="number">1</span>]))</span><br></pre></td></tr></table></figure>

<pre><code>类别 2 的概率: [0.4663913  0.28570842 0.60050037 0.3758227  0.48450719]
阈值: [1.69092453 0.69092453 0.60050037 0.54308778 0.50384451 0.49358343
 0.48450719 0.47242245 0.4663913  0.42043757 0.39590375 0.39413886
 0.3843811  0.24698327]
用auc计算: 0.8819444444444444
用roc_auc_score计算: 0.8819444444444444</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 绘制 ROC 曲线</span></span><br><span class="line">plt.figure(figsize=(<span class="number">6</span>, <span class="number">2</span>))</span><br><span class="line">plt.plot(fpr, tpr, marker=<span class="string">&quot;o&quot;</span>, label=<span class="string">&quot;ROC曲线&quot;</span>)</span><br><span class="line">plt.plot([<span class="number">0</span>,<span class="number">1</span>], [<span class="number">0</span>,<span class="number">1</span>], lw=<span class="number">2</span>, ls=<span class="string">&quot;--&quot;</span>, label=<span class="string">&quot;随机猜测&quot;</span>) </span><br><span class="line">plt.plot([<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>], [<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>], lw=<span class="number">2</span>, ls=<span class="string">&quot;-.&quot;</span>, label=<span class="string">&quot;完美预测&quot;</span>) </span><br><span class="line">plt.xlim(<span class="number">-0.01</span>, <span class="number">1.02</span>)</span><br><span class="line">plt.ylim(<span class="number">-0.01</span>, <span class="number">1.02</span>)</span><br><span class="line">plt.xticks(np.arange(<span class="number">0</span>, <span class="number">1.1</span>, <span class="number">0.2</span>))</span><br><span class="line">plt.yticks(np.arange(<span class="number">0</span>, <span class="number">1.1</span>, <span class="number">0.2</span>))</span><br><span class="line">plt.xlabel(<span class="string">&quot;FPR&quot;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&quot;TPR&quot;</span>)</span><br><span class="line">plt.grid()</span><br><span class="line">plt.title(<span class="string">f&quot;ROC曲线, AUC值为:<span class="subst">&#123;auc(fpr, tpr):<span class="number">.2</span>f&#125;</span>&quot;</span>)</span><br><span class="line">plt.legend()</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>


<p><img src="/images/mathematical-statistics/output_6_0.png"></p>
<br>

]]></content>
      <categories>
        <category>数据分析</category>
      </categories>
      <tags>
        <tag>数理统计</tag>
      </tags>
  </entry>
  <entry>
    <title>KNN 算法</title>
    <url>/data/statistics6-a328029dd5af/</url>
    <content><![CDATA[<blockquote>
<p>文章主要内容和思路来源: <strong>开课吧</strong>学习笔记</p>
</blockquote>
<h2 id="七-KNN-算法"><a href="#七-KNN-算法" class="headerlink" title="七, KNN 算法"></a>七, KNN 算法</h2><h3 id="1-关于-KNN"><a href="#1-关于-KNN" class="headerlink" title="1, 关于 KNN"></a>1, 关于 KNN</h3><p>KNN (K-Nearest Neighbor), 即 K 近邻算法, K 个最近的邻居. 当需要预测一个未知样本的时候, 就由与该样本最近的 K 个邻居来决定</p>
<p>KNN 既可以用于分类, 也可用于回归. 用来分类时, 使用 K 个邻居中, 类别数量最多(或加权最多)者, 作为预测结果; 当用来回归分析时, 使用 K 个邻居的均值(或加权均值), 作为预测结果</p>
<p>KNN 算法的原理是: 样本映射到多维空间时, 相似度较高的样本, 距离也会较接近, “近朱者赤近墨者黑”</p>
<h3 id="2-K-值"><a href="#2-K-值" class="headerlink" title="2, K 值"></a>2, K 值</h3><p>KNN 算法的 K 值是一个模型训练前就要人为指定的参数<strong>超参数</strong>, 不同于模型内部通过训练数据计算得到的参数. KNN 的超参数, 需要通常通过<strong>交叉验证</strong>的方式来选择最合适的参数组合 </p>
<p>K 值的选择非常重要, K 值较小时, 模型预测依赖附近的邻居, 敏感性高, 稳定性低, 容易导致过拟合; 反之, K 值较大, 敏感性低, 稳定性高, 容易欠拟合</p>
<p>K 值在数据量小时, 可以通过遍历所有样本(穷举)的方式找出最近的 K 个邻居, 当数据量庞大时, 穷举耗费大量时间, 此时可以采用 <strong>KD树</strong> 来找 K 个邻居</p>
<h3 id="3-交叉验证"><a href="#3-交叉验证" class="headerlink" title="3, 交叉验证"></a>3, 交叉验证</h3><p>KNN 的网格搜索交叉验证: 取不同的 K, 选择不同的距离或权重计算方式等, 将数据分为多个组, 一个组作为测试集, 其他部分作为训练集, 不断循环训练和测试, 对模型进行循环验证, 找出最佳参数组合</p>
<h3 id="4-距离的度量方式"><a href="#4-距离的度量方式" class="headerlink" title="4, 距离的度量方式"></a>4, 距离的度量方式</h3><p><strong>闵可夫斯基距离:</strong></p>
<p>设 n 维空间中两个点位 X 和 Y:</p>
<p>$X=\left(x_{1}, x_{2}, \ldots \ldots, x_{n}\right)$</p>
<p>$Y=\left(y_{1}, y_{2}, \ldots \ldots, y_{n}\right)$</p>
<p>则阁可夫斯基距离为:</p>
<p>$D(X, Y)=\left(\sum_{i=1}^{n}\left|x_{i}-y_{i}\right|^{p}\right)^{1 / p}$</p>
<p>当 p 为 1 时, 又称 <strong>曼哈顿距离</strong>; 当 p 为 2 时, 称 <strong>欧几里得距离</strong></p>
<h3 id="5-权重"><a href="#5-权重" class="headerlink" title="5, 权重"></a>5, 权重</h3><p><strong>统一权重:</strong> K 个邻居权重相同, 不管近远都是 1/K</p>
<p><strong>距离加权权重:</strong> K 个邻居的权重, 与他们各自和待测样本的距离成反比, 同时要保证权重之和为 1. 例如 3 个邻居 a, b, c 距离待测样本的距离分别为 a, b 和 c, 则 a 的权重为:</p>
<p>$$\frac{\frac{1}{a}}{\frac{1}{a}+\frac{1}{b}+\frac{1}{c}}=\frac{b c}{b c+a c+a b}$$</p>
<p>b 和 c 同理</p>
<h3 id="6-数据标准化"><a href="#6-数据标准化" class="headerlink" title="6, 数据标准化"></a>6, 数据标准化</h3><p>样本中的特征通常非常多，由于各特征的性质不同，通常具有不同的量纲(数量级). 当各特征间的量纲相差很大时，如果直接用原始特征值进行分析，就会突出数值较高的特征在综合分析中的作用，相对削弱数值较低特征的作用, 因此需要通过数据标准化, 将量纲统一, 才能客观地描述各个特征对模型的影响程度</p>
<p>线性回归和逻辑回归, 都是通过每个特征与其权重的乘积相加来进行计算, 不进行数据标准化(不考虑正则化), 对每个特征的权重影响较大, 但对结果不会造成影响, 而 KNN 是基于距离计算的, 如果特征的量纲不同, 量纲较大的特征会占据主导地位, 导致忽略量纲较小的特征, 从而对模型性能造成较大影响</p>
<h3 id="7-算法实现步骤"><a href="#7-算法实现步骤" class="headerlink" title="7, 算法实现步骤"></a>7, 算法实现步骤</h3><p>a, 确定超参数<br>  确定 K<br>  确定距离度量方式<br>  确定权重计算方式<br>  其他超参数  </p>
<p>b, 从训练集中选择距离待测样本最近的 K 个样本</p>
<p>c, 根据 K 个样本对待测样本进行预测, 如果遇到多个样本距离相同的情况, 默认选取训练集中靠前的</p>
<h3 id="8-流水线-Pipline"><a href="#8-流水线-Pipline" class="headerlink" title="8, 流水线 Pipline"></a>8, 流水线 Pipline</h3><p>流水线可以将每个评估器视为一个步骤, 然后将多个步骤作为整体依次执行. 例如数据处理工作较多时, 可能涉及更多步骤, 例如多项式扩展, One-Hot 编码, 特征选择, 数据标准化, 交叉验证等, 分别执行过于繁琐, 我们可以将数据处理与模型训练各个步骤作为一个整体来执行</p>
<p>流水线具有最后一个评估器的所有方法:</p>
<p>a, 当流水线对象调用 fit 方法时, 会从第一个评估器依次调用 fit_transform 方法, 然后到最后一个评估器调用 fit 方法</p>
<p>b, 当流水线对象调用 <em>其他</em> 方法时, 会从第一个评估器依次调用 transform 方法, 然后到最后一个评估器调用 <em>其他</em> 方法</p>
<h3 id="9-以鸢尾花为例-对逻辑回归和-KNN-进行比较"><a href="#9-以鸢尾花为例-对逻辑回归和-KNN-进行比较" class="headerlink" title="9, 以鸢尾花为例, 对逻辑回归和 KNN 进行比较:"></a>9, 以鸢尾花为例, 对逻辑回归和 KNN 进行比较:</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line"><span class="keyword">from</span> sklearn.neighbors <span class="keyword">import</span> KNeighborsClassifier</span><br><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> classification_report</span><br><span class="line"><span class="keyword">from</span> sklearn.datasets <span class="keyword">import</span> load_iris</span><br><span class="line"><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> StandardScaler</span><br><span class="line"><span class="keyword">from</span> sklearn.linear_model <span class="keyword">import</span> LogisticRegression</span><br><span class="line"><span class="keyword">import</span> matplotlib <span class="keyword">as</span> mpl</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> warnings</span><br><span class="line">warnings.filterwarnings(<span class="string">&quot;ignore&quot;</span>)</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">mpl.rcParams[<span class="string">&quot;font.family&quot;</span>] = <span class="string">&quot;SimHei&quot;</span></span><br><span class="line">mpl.rcParams[<span class="string">&quot;axes.unicode_minus&quot;</span>] = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">iris = load_iris()</span><br><span class="line">X = iris.data[:, :<span class="number">2</span>]</span><br><span class="line">y = iris.target</span><br><span class="line">X_train, X_test, y_train, y_test = train_test_split(X, y, </span><br><span class="line">                        test_size=<span class="number">0.25</span>, random_state=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 数据标准化: StandardScaler 均值标准差标准化, MinMaxScaler 最大最小值标准化</span></span><br><span class="line">ss = StandardScaler()</span><br><span class="line">X_train = ss.fit_transform(X_train)</span><br><span class="line">X_test = ss.transform(X_test)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 逻辑回归训练</span></span><br><span class="line">lr = LogisticRegression()</span><br><span class="line">lr.fit(X_train,y_train)</span><br><span class="line"></span><br><span class="line"><span class="comment"># KNN 训练</span></span><br><span class="line"><span class="comment"># n_neighbors: 邻居的数量</span></span><br><span class="line"><span class="comment"># weights：权重计算方式, 可选值为 uniform 统一权重, 与 distance 加权权重</span></span><br><span class="line">knn = KNeighborsClassifier(n_neighbors=<span class="number">3</span>, weights=<span class="string">&quot;uniform&quot;</span>)</span><br><span class="line">knn.fit(X_train, y_train)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 比较 AUC</span></span><br><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> roc_curve, auc,roc_auc_score</span><br><span class="line"></span><br><span class="line">lr_fpr, lr_tpr, lr_thresholds = roc_curve(y_test,</span><br><span class="line">                lr.predict_proba(X_test)[:,<span class="number">1</span>], pos_label=<span class="number">1</span>)</span><br><span class="line">lr_auc = auc(lr_fpr, lr_tpr)</span><br><span class="line">print(<span class="string">&#x27;Logistic 算法: AUC = %.3f&#x27;</span> % lr_auc)</span><br><span class="line"></span><br><span class="line">knn_fpr, knn_tpr, knn_thresholds = roc_curve(y_test,</span><br><span class="line">                knn.predict_proba(X_test)[:,<span class="number">1</span>], pos_label=<span class="number">1</span>)</span><br><span class="line">knn_auc = auc(knn_fpr, knn_tpr)</span><br><span class="line">print(<span class="string">&#x27;KNN 算法: AUC = %.3f&#x27;</span> % knn_auc)</span><br></pre></td></tr></table></figure>

<pre><code>Logistic 算法: AUC = 0.835
KNN 算法: AUC = 0.794</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 将 KNN 算法参数进行调优再来比较</span></span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> GridSearchCV</span><br><span class="line"></span><br><span class="line"><span class="comment"># K 值取 1~10, 并定义需要的参数组合</span></span><br><span class="line">knn = KNeighborsClassifier()</span><br><span class="line">grid = &#123;<span class="string">&#x27;n_neighbors&#x27;</span>: <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">11</span>,<span class="number">1</span>), <span class="string">&#x27;weights&#x27;</span>: [<span class="string">&#x27;uniform&#x27;</span>,<span class="string">&#x27;distance&#x27;</span>]&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 网格搜索交叉验证</span></span><br><span class="line"><span class="comment"># param_grid：需要检验的超参数组合</span></span><br><span class="line"><span class="comment"># scoring：模型评估标准, accuracy 正确率</span></span><br><span class="line"><span class="comment"># n_jobs：并发数量</span></span><br><span class="line"><span class="comment"># cv：交叉验证折数</span></span><br><span class="line"><span class="comment"># verbose：输出冗余信息</span></span><br><span class="line">gs = GridSearchCV(estimator=knn, param_grid=grid, scoring=<span class="string">&#x27;accuracy&#x27;</span>,</span><br><span class="line">                  n_jobs=<span class="number">-1</span>, cv=<span class="number">5</span>, verbose=<span class="number">0</span>)</span><br><span class="line">gs.fit(X_train, y_train)</span><br><span class="line">gs_fpr, gs_tpr, gs_thresholds = roc_curve(y_test,</span><br><span class="line">                gs.predict_proba(X_test)[:,<span class="number">1</span>], pos_label=<span class="number">1</span>)</span><br><span class="line">gs_auc = auc(gs_fpr, gs_tpr)</span><br><span class="line">print(<span class="string">&#x27;KNN 算法: AUC = %.3f&#x27;</span> % gs_auc)</span><br></pre></td></tr></table></figure>

<pre><code>KNN 算法: AUC = 0.855</code></pre>
<h3 id="10-以波士顿房价为例-对线性回归和-KNN-进行比较"><a href="#10-以波士顿房价为例-对线性回归和-KNN-进行比较" class="headerlink" title="10, 以波士顿房价为例, 对线性回归和 KNN 进行比较:"></a>10, 以波士顿房价为例, 对线性回归和 KNN 进行比较:</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.datasets <span class="keyword">import</span> load_boston</span><br><span class="line"><span class="keyword">from</span> sklearn.neighbors <span class="keyword">import</span> KNeighborsRegressor </span><br><span class="line"><span class="keyword">from</span> sklearn.linear_model <span class="keyword">import</span> LinearRegression</span><br><span class="line"></span><br><span class="line">X, y = load_boston(return_X_y=<span class="literal">True</span>)</span><br><span class="line">X_train, X_test, y_train, y_test = train_test_split(X, y,</span><br><span class="line">                        test_size=<span class="number">0.25</span>, random_state=<span class="number">0</span>)</span><br><span class="line">knn = KNeighborsRegressor(n_neighbors=<span class="number">3</span>, weights=<span class="string">&quot;distance&quot;</span>) </span><br><span class="line">knn.fit(X_train, y_train)</span><br><span class="line">print(<span class="string">&quot;KNN 算法 R²：&quot;</span>, knn.score(X_test, y_test))</span><br><span class="line">lr = LinearRegression()</span><br><span class="line">lr.fit(X_train, y_train)</span><br><span class="line">print(<span class="string">&quot;线性回归算法 R²：&quot;</span>, lr.score(X_test, y_test))</span><br></pre></td></tr></table></figure>

<pre><code>KNN 算法 R²： 0.5158073940789912
线性回归算法 R²： 0.6354638433202129</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 对 KNN 数据标准化和参数调优之后再来比较</span></span><br><span class="line">knn = KNeighborsRegressor()</span><br><span class="line">grid = &#123;<span class="string">&#x27;n_neighbors&#x27;</span>: <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">11</span>,<span class="number">1</span>), <span class="string">&#x27;weights&#x27;</span>: [<span class="string">&#x27;uniform&#x27;</span>,<span class="string">&#x27;distance&#x27;</span>]&#125;</span><br><span class="line">gs = GridSearchCV(estimator=knn, param_grid=grid, scoring=<span class="string">&#x27;r2&#x27;</span>,</span><br><span class="line">                  n_jobs=<span class="number">-1</span>, cv=<span class="number">5</span>, verbose=<span class="number">0</span>) </span><br><span class="line"></span><br><span class="line"><span class="comment"># 利用流水线处理</span></span><br><span class="line"><span class="keyword">from</span> sklearn.pipeline <span class="keyword">import</span> Pipeline</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义流水线的步骤: 类型为一个列表, 列表中的每个元素是元组类型</span></span><br><span class="line"><span class="comment"># 格式为：[(步骤名1，评估器1), (步骤名2， 评估器2), ……, (步骤名n, 评估器n)</span></span><br><span class="line">knn_steps = [(<span class="string">&quot;scaler&quot;</span>, StandardScaler()), (<span class="string">&quot;knn&quot;</span>, gs)]</span><br><span class="line">knn_p = Pipeline(knn_steps)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 可以设置流水线的参数. 所有可用的参数可以通过 get_params 获取</span></span><br><span class="line"><span class="comment"># 设置格式如下: (步骤名__参数)</span></span><br><span class="line"><span class="comment"># p.set_params(knn__n_neighbors=3, knn__weights=&quot;uniform&quot;)</span></span><br><span class="line">knn_p.fit(X_train, y_train)</span><br><span class="line">print(<span class="string">&quot;KNN 算法 R²：&quot;</span>, knn_p.score(X_test, y_test))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 线性回归数据标准化</span></span><br><span class="line">lr_steps = [(<span class="string">&quot;scaler&quot;</span>, StandardScaler()), (<span class="string">&quot;lr&quot;</span>, LinearRegression())]</span><br><span class="line">lr_p = Pipeline(lr_steps)</span><br><span class="line">lr_p.fit(X_train, y_train)</span><br><span class="line">print(<span class="string">&quot;线性回归算法 R²：&quot;</span>, lr_p.score(X_test, y_test))</span><br></pre></td></tr></table></figure>

<pre><code>KNN 算法 R²： 0.6441485149216897
线性回归算法 R²： 0.6354638433202131</code></pre>
<br>

]]></content>
      <categories>
        <category>数据分析</category>
      </categories>
      <tags>
        <tag>数理统计</tag>
      </tags>
  </entry>
  <entry>
    <title>决策树</title>
    <url>/data/statistics8-32b3a23ba9e8/</url>
    <content><![CDATA[<blockquote>
<p>文章主要内容和思路来源: <strong>开课吧</strong>学习笔记</p>
</blockquote>
<h2 id="九-决策树"><a href="#九-决策树" class="headerlink" title="九, 决策树"></a>九, 决策树</h2><h3 id="1-概念理解"><a href="#1-概念理解" class="headerlink" title="1, 概念理解"></a>1, 概念理解</h3><p>决策树: 通过数据特征的差别, 用已知数据训练将不同数据划分到不同分支(子树)中, 层层划分, 最终得到一个树型结构, 用来对未知数据进行预测, 实现分类或回归</p>
<p>例如, 有如下数据集, 预测第 11 条数据能否偿还债务:</p>
<table>
   <tr>
      <td>序号</td>
      <td>有无房产</td>
      <td>婚姻状况</td>
      <td>年收入</td>
      <td>能否偿还债务</td>
   </tr>
   <tr>
      <td>1</td>
      <td>是</td>
      <td>单身</td>
      <td>125</td>
      <td>能</td>
   </tr>
   <tr>
      <td>2</td>
      <td>否</td>
      <td>已婚</td>
      <td>100</td>
      <td>能</td>
   </tr>
   <tr>
      <td>3</td>
      <td>否</td>
      <td>单身</td>
      <td>100</td>
      <td>能</td>
   </tr>
   <tr>
      <td>4</td>
      <td>是</td>
      <td>已婚</td>
      <td>110</td>
      <td>能</td>
   </tr>
   <tr>
      <td>5</td>
      <td>是</td>
      <td>离婚</td>
      <td>60</td>
      <td>能</td>
   </tr>
   <tr>
      <td>6</td>
      <td>否</td>
      <td>离婚</td>
      <td>95</td>
      <td>不能</td>
   </tr>
   <tr>
      <td>7</td>
      <td>否</td>
      <td>单身</td>
      <td>85</td>
      <td>不能</td>
   </tr>
   <tr>
      <td>8</td>
      <td>否</td>
      <td>已婚</td>
      <td>75</td>
      <td>能</td>
   </tr>
   <tr>
      <td>9</td>
      <td>否</td>
      <td>单身</td>
      <td>90</td>
      <td>不能</td>
   </tr>
   <tr>
      <td>10</td>
      <td>是</td>
      <td>离婚</td>
      <td>220</td>
      <td>能</td>
   </tr>
   <tr>
      <td>11</td>
      <td>否</td>
      <td>已婚</td>
      <td>94</td>
      <td>?</td>
   </tr>
</table>

<p>我们可以将已知样本作如下划分(训练), 构建一颗决策树, 然后将第 11 条数据代入(测试), 落在哪一个叶子中, 它就是对应叶子的类别: 预测结果是<strong>能</strong></p>
<p><img src="https://wx2.sbimg.cn/2020/07/02/2Y8Lk.md.png"></p>
<p>上例中, 层级已经不可再分, 但如果只划分到婚姻状况就不再划分如何实现预测?</p>
<p>决策树实现预测:<br>对于分类树, 叶子节点中, 哪个类别样本数量最多, 就将其作为未知样本的类别<br>对于回归树, 使用叶子节点中, 所有样本的均值, 作为未知样本的结果</p>
<p>对于上例, 如果只划分到婚姻状况, 那对于婚姻状况这个叶子中, 不能偿还的最多, 预测结果就是<strong>不能</strong></p>
<h3 id="2-分类决策树"><a href="#2-分类决策树" class="headerlink" title="2, 分类决策树"></a>2, 分类决策树</h3><p>对上例出现的情况, 我们会有如下问题:<br>我们为什么以年收入开始划分, 依据是什么? 划分顺序怎么定?<br>年收入为什么选 97.5 为划分阈值?<br>要划分多少层才好, 是否越多越好?<br>等等…</p>
<p>下面一步步来作讨论:</p>
<h4 id="2-01-信息熵"><a href="#2-01-信息熵" class="headerlink" title="2.01, 信息熵"></a>2.01, 信息熵</h4><p><strong>信息熵</strong>: 用来描述信源的不确定度, 不确定性越大, 信息熵越大. 例如, 明天海南要下雪, 不确定性非常小, 信息熵很小, 明天海南要下雨, 不确定性大, 信息熵就大</p>
<p>设随机变量 X 具有 m 个特征值, 各个值出现的概率为 $p_{1}$, …, $p_{m}$, 且 </p>
<p>$$p_{1}+p_{2}+\cdots+p_{m} = 1$$</p>
<p>则变量 X 的信息熵(信息期望值)为:</p>
<p>$$\begin{array}{l}<br>H(X)=-p_{1} * \log <em>{2} p</em>{1}-p_{2} * \log <em>{2} p</em>{2}-\cdots-p_{m} * \log <em>{2} p</em>{m} \<br>=-\sum_{i=1}^{m} p_{i} \log <em>{2} p</em>{i}<br>\end{array}$$</p>
<h4 id="2-02-概率分布与信息商的关系"><a href="#2-02-概率分布与信息商的关系" class="headerlink" title="2.02, 概率分布与信息商的关系"></a>2.02, 概率分布与信息商的关系</h4><p>假设明天下雨的概率从 0.01<del>0.99 递增, 那么不下雨的概率就从 0.99</del>0.01 递减, 看看概率分布和信息熵的关系:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">plt.rcParams[<span class="string">&#x27;font.family&#x27;</span>] = <span class="string">&#x27;SimHei&#x27;</span></span><br><span class="line">plt.rcParams[<span class="string">&#x27;font.size&#x27;</span>] = <span class="number">14</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 下雨的概率</span></span><br><span class="line">p = np.linspace(<span class="number">0.01</span>, <span class="number">0.99</span>, <span class="number">100</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 信息熵</span></span><br><span class="line">h = -p * np.log2(p) - (<span class="number">1</span>-p) * np.log2(<span class="number">1</span>-p)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 绘制关系图</span></span><br><span class="line">plt.plot(p, h)</span><br><span class="line">plt.xlabel(<span class="string">&#x27;概率分布&#x27;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;信息熵&#x27;</span>)</span><br><span class="line">plt.title(<span class="string">&#x27;概率分布和信息熵关系图&#x27;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>


<p><img src="/images/mathematical-statistics/output_1_0100.png" alt="png"></p>
<p>可见, 概率分布越均衡, 不确定性越大, 信息熵越大, 在所有概率都相等(p下雨=p不下雨)时, 信息熵最大</p>
<p>如果把概率分布转换到决策树的数据集上, 信息熵体现的就是数据的<strong>不纯度</strong>, 即样本类别的均衡程度. 因为数据集是未分类的, 要把它分类, 样本类别越均衡, 各个类别的占比(概率)分布越均衡, 不纯度越高, 信息熵越大</p>
<h4 id="2-03-信息增益"><a href="#2-03-信息增益" class="headerlink" title="2.03, 信息增益"></a>2.03, 信息增益</h4><p>信息增益的定义如下:</p>
<p>$$I G\left(D_{p}, f\right)=I\left(D_{p}\right)-\sum_{j=1}^{n} \frac{N_{j}}{N_{p}} I\left(D_{j}\right) $$</p>
<p>$f$:  划分的特征<br>$D_{p}$:  父节点, 即使用特征  f  分割之前的节点<br>$I G\left(D_{p}, f\right)$:  父节点  $D_{p}$  使用特征  f  划分下, 获得的信息增益<br>$I\left(D_{p}\right)$：父节点不纯度, 信息熵是度量标准之一<br>$D_{j}$:  父节点 $D_{p}$ 经过分割之后, 会产生 n 个子节点,  $D_{j}$  为第  j  个子节点<br>$I\left(D_{j}\right)$：子节点不纯度<br>$N_{p}$:  父节点  $D_{p}$  包含样本的数量<br>$N_{j}$:  第  j  个子节点  $D_{j}$  包含样本的数量   </p>
<p>如果是二叉树, 即父节点最多分为左右两个子节点, 此时, 信息增益为:</p>
<p>$$I G\left(D_{p}, f\right)=I\left(D_{p}\right)-\frac{N_{l e f t}}{N_{p}} I\left(D_{l e f t}\right)-\frac{N_{r i g h t}}{N_{p}} I\left(D_{r i g h t}\right)$$</p>
<p>可见, 信息增益就是父节点的不纯度减去所有子节点的(加权)不纯度</p>
<p>父节点的不纯度是不变的, 在选择特征进行类别划分时, 应该让子节点的不纯度尽可能低, 这样训练可以更快完成, 信息增益也最大. 这正是训练决策树时, 选择特征顺序的依据</p>
<p>以开头的例子为例, 不纯度使用信息熵度量, 则根节点的信息熵为:</p>
<p>$$I\left(D_{p}\right)=-0.7 * \log _{2} 0.7-0.3 * \log _{2} 0.3=0.88$$</p>
<p>如果以”有无房产”划分, 则可计算得子节点信息熵:</p>
<p>$$\begin{array}{l}<br>I\left(D_{\text {有房产 }}\right)=0 \<br>I\left(D_{\text {无房产 }}\right)=1<br>\end{array}$$</p>
<p>从而可得根节点信息增益为:</p>
<p>$$I G(\text { 有无房产 })=0.88-0.4 * 0-0.6 * 1=0.28 $$</p>
<p>同理, </p>
<p>$$I G(\text { 婚姻状况 })=0.205 $$</p>
<p>而对于年收入, 将年收入排序后, 取不同类别的分界点年收入(75 与 85, 95 与 100)的均值进行划分, 比较哪一个信息增益大:</p>
<p>$$\begin{array}{l}<br>I\left(D_{\text {年收入 }&lt; 80}\right)=0 \<br>I\left(D_{\text { 年收入 } &gt;=80}\right)=0.954 \<br>I G(\text { 年收入 }=80)=0.88-0.2 * 0-0.8 * 0.954=0.117<br>\end{array}$$</p>
<p>同理, </p>
<p>$$I G(\text { 年收入 }=97.5)=0.395$$</p>
<p>可见, 以 年收入=97.5 划分时, 信息增益最大, 故首先选它进行划分</p>
<p>根节点划分结束, 第二层的父节点以同样的方式计算之后再次划分, 一直到划分停止</p>
<h4 id="2-04-过拟合与欠拟合"><a href="#2-04-过拟合与欠拟合" class="headerlink" title="2.04, 过拟合与欠拟合"></a>2.04, 过拟合与欠拟合</h4><p>如果不设置条件, 是不是划分深度越大越好呢?</p>
<p>下面以鸢尾花数据集为例, 看看划分深度对模型效果的影响:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.datasets <span class="keyword">import</span> load_iris</span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line"><span class="keyword">from</span> sklearn.tree <span class="keyword">import</span> DecisionTreeClassifier</span><br><span class="line"></span><br><span class="line">x, y = load_iris(return_X_y=<span class="literal">True</span>)</span><br><span class="line">x = x[:, :<span class="number">2</span>]</span><br><span class="line">x_train, x_test, y_train, y_test = train_test_split(</span><br><span class="line">    x, y, test_size=<span class="number">0.25</span>, random_state=<span class="number">0</span>)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">参数介绍:</span></span><br><span class="line"><span class="string">criterion: 不纯度度量标准, 默认基尼系数 gini, 信息熵为 entropy</span></span><br><span class="line"><span class="string">splitter: 选择划分节点的方式, 默认最好 best, 随机 random</span></span><br><span class="line"><span class="string">max_depth: 划分深度, 默认 None 不设限</span></span><br><span class="line"><span class="string">min_samples_split: 划分节点的最小样本数, 默认 2</span></span><br><span class="line"><span class="string">min_samples_leaf: 划分节点后, 叶子节点的最少样本数, 默认 1</span></span><br><span class="line"><span class="string">max_features: 划分节点时, 考虑的最大特征数, 默认 None 考虑所有, 设置数量后会随机选择</span></span><br><span class="line"><span class="string">random_state: 随机种子, 控制模型的随机行为</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">tree = DecisionTreeClassifier()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义列表, 用来储存不同深度下, 模型的分值</span></span><br><span class="line">train_score = []</span><br><span class="line">test_score = []</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置深度 1~12 开始训练</span></span><br><span class="line"><span class="keyword">for</span> depth <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">13</span>):</span><br><span class="line">    tree = DecisionTreeClassifier(criterion=<span class="string">&#x27;entropy&#x27;</span>,</span><br><span class="line">                    max_depth=depth, random_state=<span class="number">0</span>)</span><br><span class="line">    tree.fit(x_train, y_train)</span><br><span class="line">    train_score.append(tree.score(x_train, y_train))</span><br><span class="line">    test_score.append(tree.score(x_test, y_test))</span><br><span class="line">    </span><br><span class="line">plt.plot(train_score, label=<span class="string">&#x27;训练集分值&#x27;</span>)</span><br><span class="line">plt.plot(test_score, label=<span class="string">&#x27;测试集分值&#x27;</span>)</span><br><span class="line">plt.xlabel(<span class="string">&#x27;划分深度&#x27;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;分值&#x27;</span>)</span><br><span class="line">plt.legend()</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>


<p><img src="/images/mathematical-statistics/output_3_0001.png" alt="png"></p>
<p>可见, 划分深度小, 训练集和测试集的分值都小, 容易欠拟合<br>随着划分深度的增加, 分值都在增加, 模型预测效果也在变好<br>当深度增加到一定程度, 深度再增加, 训练集分值随着增加, 但造成了模型过分依赖训练集数据特征, 从而测试集分值减小, 容易过拟合</p>
<h3 id="3-不纯度度量标准"><a href="#3-不纯度度量标准" class="headerlink" title="3, 不纯度度量标准"></a>3, 不纯度度量标准</h3><p>不纯度度量标准有:</p>
<p><strong>信息熵</strong></p>
<p>$$I_{H}(D)=-\sum_{i=1}^{m} p(i \mid D) \log _{2} p(i \mid D) $$</p>
<p>m: 节点 D 中含有样本的类别数量<br>$p(i \mid D)$: 节点 D 中, 属于类别 i 的样本占节点 D 中样本总数的比例(概率)</p>
<p><strong>基尼系数</strong></p>
<p>$$I_{G}(D)=1-\sum_{i=1}^{m} p(i \mid D)^{2}$$</p>
<p><strong>错误率</strong></p>
<p>$$I_{E}(D)=1-\max {p(i \mid D)}$$</p>
<p>看看各个度量标准与概率分布的关系:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">entropy</span>(<span class="params">p</span>):</span></span><br><span class="line">    <span class="keyword">return</span> -p * np.log2(p) - (<span class="number">1</span>-p) * np.log2(<span class="number">1</span>-p)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gini</span>(<span class="params">p</span>):</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> - p**<span class="number">2</span> - (<span class="number">1</span>-p)**<span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">error</span>(<span class="params">p</span>):</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> - np.<span class="built_in">max</span>([p, <span class="number">1</span>-p], axis=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">p = np.linspace(<span class="number">0.0001</span>, <span class="number">0.9999</span>, <span class="number">200</span>)</span><br><span class="line"></span><br><span class="line">en = entropy(p)</span><br><span class="line">er = error(p)</span><br><span class="line">g = gini(p)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i, lab, ls <span class="keyword">in</span> <span class="built_in">zip</span>([en, g, er],</span><br><span class="line">                      [<span class="string">&#x27;信息熵&#x27;</span>, <span class="string">&#x27;基尼系数&#x27;</span>, <span class="string">&#x27;错误率&#x27;</span>],</span><br><span class="line">                      [<span class="string">&#x27;-&#x27;</span>, <span class="string">&#x27;:&#x27;</span>, <span class="string">&#x27;--&#x27;</span>]):</span><br><span class="line">    plt.plot(p, i, label=lab, linestyle=ls, lw=<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">plt.legend()</span><br><span class="line">plt.xlabel(<span class="string">&#x27;概率分布&#x27;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;不纯度&#x27;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>


<p><img src="https://wx2.sbimg.cn/2020/07/02/2Yx2j.png" alt="png"></p>
<p>可见, 无论选哪一种度量标准, 样本属于同一类, 不纯度都是 0; 样本中不同类别占比相同时, 不纯度最大</p>
<h3 id="4-决策树常用算法介绍"><a href="#4-决策树常用算法介绍" class="headerlink" title="4, 决策树常用算法介绍"></a>4, 决策树常用算法介绍</h3><p><strong>ID3</strong></p>
<p>ID3 (Iterative Dichotomiser3), 迭代二分法特点:<br>  -使用多叉树结构<br>  -使用信息熵作为不纯度度量, 选择信息增益最大的特征划分<br>  -经典算法, 简单, 训练快<br>局限:<br>  -不支持连续特征<br>  -不支持缺失值处理<br>  -不支持回归<br>  -倾向选择特征取值多的特征来划分, 例如按身份证号划分, 一个号码就是一个特征</p>
<p><strong>C4.5</strong></p>
<p>ID3算法改进而来, 特点:<br>  -使用多叉树结构<br>  -不支持回归<br>优化:<br>  -支持缺失值处理<br>  -连续值进行离散化处理<br>  -信息熵作为不纯度度量, 但选择<strong>信息增益率</strong>最大的特征划分   </p>
<p>信息增益率:</p>
<p>$$I G_{\text {Ratio}}\left(D_{p}, f\right)=\frac{I G_{H}\left(D_{p}, f\right)}{I_{H}(f)} $$</p>
<p>$I_{H}(f)$:  在特征 $f$ 下, 取各个特征值计算得到的信息熵之和, 其实就是特征 $f$ 的不纯度, 特征值越多, 特征不纯度越大</p>
<p>选择信息增益最大的特征来划分, 父节点的信息熵不变, 就要求信息增益的第二项 $\sum_{j=1}^{n} \frac{N_{j}}{N_{p}} I\left(D_{j}\right)$ 最小, 从而会倾向选择特征取值多的特征</p>
<p>因为, 特征取值多, 通常划分之后子节点的不纯度(信息熵)就更低, 例如极端情况, 选身份证划分, 划分之后不管什么类别, 子节点都只有一种类别, 不纯度都是 0, 第二项就是 0, 信息增益就最大</p>
<p>因此, 采用信息增益率, 将 信息增益/特征不纯度, 就避免了 特征不纯度大 造成 信息增益大 而选择类别多的特征来划分的情况</p>
<p>看看类别数量与信息熵的关系:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">en = <span class="keyword">lambda</span> p: np.<span class="built_in">sum</span>(-p * np.log2(p))</span><br><span class="line"></span><br><span class="line">a1 = np.array([<span class="number">0.3</span>, <span class="number">0.7</span>])</span><br><span class="line">a2 = np.array([<span class="number">0.3</span>, <span class="number">0.3</span>, <span class="number">0.4</span>])</span><br><span class="line">a3 = np.array([<span class="number">0.25</span>] * <span class="number">4</span>)</span><br><span class="line">a4 = np.array([<span class="number">0.1</span>] * <span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">print(en(a1), en(a2), en(a3), en(a4), sep=<span class="string">&#x27;\n&#x27;</span>)</span><br></pre></td></tr></table></figure>

<pre><code>0.8812908992306927
1.5709505944546684
2.0
3.321928094887362</code></pre>
<p><strong>CART</strong></p>
<p>CART (Classification And Regression Tree), 分类回归树, 特点如下:<br>  -使用二叉树结构<br>  -支持连续值与缺失值处理<br>  -分类时, 使用基尼系数作为不纯度度量, 选择基尼增益最大的特征划分<br>  -回归时, 使用 MSE 或 MAE 最小的特征划分</p>
<h3 id="5-回归决策树"><a href="#5-回归决策树" class="headerlink" title="5, 回归决策树"></a>5, 回归决策树</h3><p>回归决策树因变量 y 是连续的, 使用叶子节点的均值来预测未知样本, 使用 MSE 或 MAE 作为特征划分的评估指标</p>
<p>在 scikit-learn 中, 使用的是优化的 CART 算法来实现决策树</p>
<p>以波士顿房价为例来实现(参数参考分类决策树):</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.datasets <span class="keyword">import</span> load_boston</span><br><span class="line"><span class="keyword">from</span> sklearn.tree <span class="keyword">import</span> DecisionTreeRegressor</span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line"></span><br><span class="line">x, y = load_boston(return_X_y=<span class="literal">True</span>)</span><br><span class="line">x_train, x_test, y_train, y_test = train_test_split(</span><br><span class="line">            x, y, test_size=<span class="number">0.25</span>, random_state=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">tree = DecisionTreeRegressor(max_depth=<span class="number">5</span>, random_state=<span class="number">0</span>)</span><br><span class="line">tree.fit(x_train, y_train)</span><br><span class="line">print(tree.score(x_train, y_train))</span><br><span class="line">print(tree.score(x_test, y_test))</span><br></pre></td></tr></table></figure>

<pre><code>0.9204825770764915
0.8763987309111113</code></pre>
<br>
]]></content>
      <categories>
        <category>数据分析</category>
      </categories>
      <tags>
        <tag>数理统计</tag>
      </tags>
  </entry>
  <entry>
    <title>K-Means 算法</title>
    <url>/data/statistics9-37ff3fbe9723/</url>
    <content><![CDATA[<blockquote>
<p>文章主要内容和思路来源: <strong>开课吧</strong>学习笔记</p>
</blockquote>
<h2 id="十-K-Means-算法"><a href="#十-K-Means-算法" class="headerlink" title="十, K-Means 算法"></a>十, K-Means 算法</h2><h3 id="1-聚类"><a href="#1-聚类" class="headerlink" title="1, 聚类"></a>1, 聚类</h3><p>前面接触的算法, 都是<strong>监督学习</strong>, 即训练数据中自变量(特征)和因变量(结果)都是已知的, 用含有结果的训练集建立模型, 然后对未知结果的数据进行预测</p>
<p>聚类属于<strong>无监督学习</strong>, 训练数据中没有”已知结果的监督”. 聚类的目的, 就是通过已知样本数据的特征, 将数据划分为若干个类别, 每个类别成一个类簇, 使得同一个簇内的数据相似度越大, “物以类聚”, 不同簇之间的数据相似度越小, 聚类效果越好</p>
<p>聚类的样本相似度根据距离来度量</p>
<h3 id="2-K-Means"><a href="#2-K-Means" class="headerlink" title="2, K-Means"></a>2, K-Means</h3><p>即 K 均值算法, 是常见的聚类算法, 该算法将数据集分为 K 个簇, 每个簇使用簇内所有样本的均值来表示, 该均值称为”质心”</p>
<p>K-Means 算法的目标, 就是选择适合的质心, 使得每个簇内, 样本点距质心的距离尽可能的小, 从而保证簇内样本有较高相似度</p>
<p>算法实现步骤:</p>
<p>a, 从样本中选择 K 个点作为初始质心<br>b, 计算每个样本点到各个质心的距离, 将样本点划分到距离最近的质心所对应的簇中<br>c, 计算每个簇内所有样本的均值, 使用该均值作为新的质心<br>d, 重复 b 和 c, 重复一定次数质心一般会趋于稳定, 如果达到以下条件, 重复结束:<br>– 质心位置变化小于指定的阈值<br>– 达到最迭代环次数</p>
<p>对于算法的实现步骤, 我们有几个重要的疑问:</p>
<p>– 1.怎么评价质心是否达到了最佳位置?<br>– 2.初始质心随机选, 还是选在哪里?<br>– 3. K 值怎么定?  </p>
<h3 id="3-算法优化目标"><a href="#3-算法优化目标" class="headerlink" title="3, 算法优化目标"></a>3, 算法优化目标</h3><p>样本的相似度是根据距离来度量的, 一般使用簇内<strong>误差平方和</strong>(within-cluster SSE 簇惯性) 来作为优化算法的目标函数, 距离常用欧氏距离, 优化目标就是使 SSE 最小化:</p>
<p>$$S S E=\sum_{i=1}^{k} \sum_{j=1}^{m_{i}}\left(\left|x_{j}-\mu_{i}\right|^{2}\right)$$</p>
<p>k: 族的数量<br>$m_{i}$: 第 i 个簇含有的样本数量<br>${\mu}<em>{i}$: 第 i 个族的质心<br>$\left|x</em>{j}-\mu_{i}\right|$: 第 i 个族中，每个样本  $x_{j}$  与质心  $\mu_{i}$  的距离</p>
<p>同一个数据集, 相同的簇数, SSE 越小, 通常质心位置更佳, 算法模型更好</p>
<h3 id="4-初始质心的影响"><a href="#4-初始质心的影响" class="headerlink" title="4, 初始质心的影响"></a>4, 初始质心的影响</h3><p>初始质心可以随机选择, 但由于算法是通过迭代初始质心一步步实现, 初始质心的位置受随机性影响, 算法训练的最终结果也会受到影响</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> sklearn.cluster <span class="keyword">import</span> KMeans</span><br><span class="line"><span class="keyword">from</span> sklearn.datasets <span class="keyword">import</span> make_blobs</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">plt.rcParams[<span class="string">&#x27;font.family&#x27;</span>] = <span class="string">&#x27;YouYuan&#x27;</span> </span><br><span class="line">plt.rcParams[<span class="string">&#x27;font.size&#x27;</span>] = <span class="number">12</span> </span><br><span class="line">plt.rcParams[<span class="string">&#x27;axes.unicode_minus&#x27;</span>] = <span class="literal">False</span> </span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">生成数据:</span></span><br><span class="line"><span class="string">n_samples: 样本数量</span></span><br><span class="line"><span class="string">n_features: 特征数</span></span><br><span class="line"><span class="string">centers: 聚类中心</span></span><br><span class="line"><span class="string">cluster_std: 簇的标准差, 可以统一指定, 也分别指定</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">centers = [[<span class="number">1</span>, <span class="number">1</span>], [<span class="number">5</span>, <span class="number">2</span>], [<span class="number">2</span>, <span class="number">5</span>]]</span><br><span class="line">x, y = make_blobs(n_samples=<span class="number">90</span>,</span><br><span class="line">                  n_features=<span class="number">2</span>,</span><br><span class="line">                  centers=centers,</span><br><span class="line">                  cluster_std=[<span class="number">2.2</span>, <span class="number">2.5</span>, <span class="number">2</span>],</span><br><span class="line">                  random_state=<span class="number">0</span>)</span><br><span class="line"><span class="comment"># x 是特征, y 是类别标签</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 绘制原始数据</span></span><br><span class="line">plt.figure(figsize=(<span class="number">12</span>,<span class="number">8</span>))</span><br><span class="line">plt.subplot(<span class="number">221</span>)</span><br><span class="line">colors = np.array([<span class="string">&#x27;Coral&#x27;</span>, <span class="string">&#x27;SeaGreen&#x27;</span>, <span class="string">&#x27;RoyalBlue&#x27;</span>])</span><br><span class="line">plt.scatter(x[:, <span class="number">0</span>], x[:, <span class="number">1</span>], c=colors[y], marker=<span class="string">&#x27;.&#x27;</span>, label=<span class="string">&#x27;原始数据&#x27;</span>)</span><br><span class="line">plt.title(<span class="string">&#x27;原始数据&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义绘制聚类结果的函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">plot_cluster</span>(<span class="params">model, train, test=<span class="literal">None</span></span>):</span></span><br><span class="line">    <span class="keyword">global</span> colors  <span class="comment"># 使用上面的颜色</span></span><br><span class="line">    cc = model.cluster_centers_ <span class="comment"># 获取质心</span></span><br><span class="line">    label = model.labels_ <span class="comment"># 获取聚类结果的标签</span></span><br><span class="line">    <span class="comment"># 绘制质心</span></span><br><span class="line">    plt.scatter(cc[:, <span class="number">0</span>], <span class="comment"># 质心的 x 坐标</span></span><br><span class="line">                cc[:, <span class="number">1</span>], <span class="comment"># 质心的 y 坐标</span></span><br><span class="line">                marker=<span class="string">&#x27;*&#x27;</span>,</span><br><span class="line">                s=<span class="number">150</span>,</span><br><span class="line">                c=colors)</span><br><span class="line">    <span class="comment"># 绘制训练集</span></span><br><span class="line">    plt.scatter(train[:, <span class="number">0</span>], train[:, <span class="number">1</span>], marker=<span class="string">&#x27;.&#x27;</span>, c=colors[label])</span><br><span class="line">    <span class="comment"># 绘制测试集</span></span><br><span class="line">    <span class="keyword">if</span> test <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        y_hat = model.predict(test)</span><br><span class="line">        plt.scatter(test[:, <span class="number">0</span>], test[:, <span class="number">1</span>], marker=<span class="string">&#x27;+&#x27;</span>,</span><br><span class="line">                    s=<span class="number">150</span>, c=colors[y_hat])        </span><br><span class="line">    <span class="comment"># 标题</span></span><br><span class="line">    plt.title(<span class="string">f&#x27;SSE:<span class="subst">&#123;model.inertia_:<span class="number">.1</span>f&#125;</span> 迭代次数:<span class="subst">&#123;model.n_iter_&#125;</span>&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 测试集</span></span><br><span class="line">test = np.array([[<span class="number">6</span>, <span class="number">5</span>]])    </span><br><span class="line"><span class="comment"># 绘制不同初始质心的聚类结果</span></span><br><span class="line">seed = [<span class="number">1</span>, <span class="number">10</span>, <span class="number">100</span>]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, <span class="number">5</span>):</span><br><span class="line">    plt.subplot(<span class="number">2</span>, <span class="number">2</span>, i)</span><br><span class="line">    kmeans = KMeans(n_clusters=<span class="number">3</span>, <span class="comment"># 簇数</span></span><br><span class="line">                    init=<span class="string">&#x27;random&#x27;</span>, <span class="comment"># 初始化方式</span></span><br><span class="line">                    n_init=<span class="number">1</span>, <span class="comment"># 初始化质心组数</span></span><br><span class="line">                    random_state=seed[i<span class="number">-2</span>])</span><br><span class="line">    kmeans.fit(x)</span><br><span class="line">    plot_cluster(kmeans, x)</span><br><span class="line">    <span class="comment"># 测试结果</span></span><br><span class="line">    plot_cluster(kmeans, x, test)</span><br></pre></td></tr></table></figure>


<p><img src="https://wx2.sbimg.cn/2020/07/04/2O85J.md.png" alt="png"></p>
<p>从上图可以看出受初始化质心的影响, 聚类效果(SSE) 与 收敛速度(迭代次数) 会不同, 也即是可能会收敛到局部最小, 而不是整体最优; 同时, 也可以看出 SSE 越小, 整体结果越优, 越接近原始数据</p>
<h3 id="5-K-Means-优化"><a href="#5-K-Means-优化" class="headerlink" title="5, K-Means++ 优化"></a>5, K-Means++ 优化</h3><p>针对上述初始化质心造成的问题, 设置初始化多组质心可以得到缓解, 但通常限于聚类簇数较少的情况, 如果簇数较多, 可能就不会有效</p>
<p>于是有了 K-Means++, 选择初始化质心时, 不在随机选, 而是按下述步骤进行选择:</p>
<p>– 1, 从训练数据中随机选择一个样本点, 作为初始质心<br>– 2, 对任意一个非质心样本点 $x^{(i)}$, 计算 $x^{(i)}$ 与现有最近质心的距离 $D\left(x^{(i)}\right)$<br>– 3, 根据概率 $\frac{D\left(x^{(i)}\right)^{2}}{\sum_{j=1}^{m} D\left(x^{(j)}\right)^{2}}$ 最大, 来选择最远的一个样本点 $x^{(i)}$ 作为质心, m 为非质心样本点数量<br>– 4, 重复 2 和 3, 直到选择了 K 个质心为止</p>
<p>做了优化之后, 保证了初始质心不会集中, 而是分散在数据集中</p>
<p>下面用试试 K-Means++ 的聚类效果:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">kmeans = KMeans(n_clusters=<span class="number">3</span>, init=<span class="string">&#x27;k-means++&#x27;</span>, n_init=<span class="number">1</span>)</span><br><span class="line">kmeans.fit(x)</span><br><span class="line">plot_cluster(kmeans, x)</span><br></pre></td></tr></table></figure>


<p><img src="https://wx2.sbimg.cn/2020/07/04/2OnU8.png" alt="png"></p>
<h3 id="6-确定-K-值"><a href="#6-确定-K-值" class="headerlink" title="6, 确定 K 值"></a>6, 确定 K 值</h3><p>K 是超参数, 需要预先人为指定 </p>
<p>有时需要按照建模的需求和目的来选择聚类的个数, 但是 K 值选择不当, 聚类效果可能不佳. 例如实际 3 类, K 选了 10, 或者 K 无限制, 取值和样本点个数一样, 最后每个点一个类, SEE 为 0, 但是聚类已经毫无意义</p>
<p>如果不是硬性要求 K 的取值, 怎么确定最佳的 K 值呢? 一个比较好的方法就是<strong>肘部法则</strong>:</p>
<p>SEE 需要越小越好, K 又不能取太大, 我们可以看看他们之间的关系:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 设置列表储存 SSE</span></span><br><span class="line">sse = []</span><br><span class="line"><span class="comment"># K 值从 1~9 变化</span></span><br><span class="line">scope = <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">10</span>)</span><br><span class="line"><span class="keyword">for</span> k <span class="keyword">in</span> scope:</span><br><span class="line">    kmeans = KMeans(n_clusters=k)</span><br><span class="line">    kmeans.fit(x)</span><br><span class="line">    sse.append(kmeans.inertia_)</span><br><span class="line">    </span><br><span class="line">plt.xticks(scope)</span><br><span class="line">plt.plot(scope, sse, marker=<span class="string">&#x27;o&#x27;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>


<p><img src="/images/mathematical-statistics/output_70_0.png" alt="png"></p>
<p>从上图可以看出, K 增加, SSE 减小, 但当 K &gt; 3 时, K 再增加, SSE 减小变得缓慢, 所以 K 选择 3, 实际情况也是 3</p>
<h3 id="6-Mini-Batch-K-Means"><a href="#6-Mini-Batch-K-Means" class="headerlink" title="6, Mini Batch K-Means"></a>6, Mini Batch K-Means</h3><p>K-Means 每次迭代都会使用所有数据参与运算, 当数据集较大时, 会比较耗时. Mini Batch K-Means (小批量 K-Means) 算法每次迭代使用小批量样本训练, 逐批次累计的方式进行计算, 从而大大减少计算时间. 效果上, 通常只是略差于 K-Means</p>
<p>Mini Batch K-Means 算法实现步骤:</p>
<p>a, 从数据集中随机选择部分数据, 使用 K-Means 算法在这部分数据上聚类, 获取质心<br>b, 再从数据集中随机选择部分数据, 分别分配给最近的质心<br>c, 每个簇根据现有的数据集更新质心<br>d, 重复 b 和 c, 直到质心变化小于指定阈值或达到最大迭代次数</p>
<p>下面比较一下两个算法:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">from</span> sklearn.cluster <span class="keyword">import</span> MiniBatchKMeans</span><br><span class="line"><span class="keyword">from</span> sklearn.metrics.pairwise <span class="keyword">import</span> pairwise_distances_argmin</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成数据</span></span><br><span class="line">centers = [[<span class="number">1</span>, <span class="number">1</span>], [<span class="number">400</span>, <span class="number">100</span>], [<span class="number">100</span>, <span class="number">400</span>]]</span><br><span class="line">x, y = make_blobs(n_samples=<span class="number">8000</span>, n_features=<span class="number">2</span>, centers=centers,</span><br><span class="line">                  cluster_std=<span class="number">120</span>, random_state=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义函数, 用于计算模型训练时间</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">elapsed_time</span>(<span class="params">model, data</span>):</span></span><br><span class="line">    start = time.time()</span><br><span class="line">    model.fit(data)</span><br><span class="line">    end = time.time()</span><br><span class="line">    <span class="keyword">return</span> end - start</span><br><span class="line"></span><br><span class="line">n_clusters = <span class="built_in">len</span>(centers)</span><br><span class="line">kmeans = KMeans(n_clusters=n_clusters)</span><br><span class="line">mbk = MiniBatchKMeans(n_clusters=n_clusters,</span><br><span class="line">                      batch_size=<span class="number">200</span>, <span class="comment"># 小批量的大小</span></span><br><span class="line">                     n_init=<span class="number">10</span> <span class="comment"># 和 KMeans 统一为 10</span></span><br><span class="line">                     )</span><br><span class="line">kmeans_time = elapsed_time(kmeans, x)</span><br><span class="line">mbk_time = elapsed_time(mbk, x)</span><br><span class="line"></span><br><span class="line">print(<span class="string">&#x27;K-Means耗时:&#x27;</span>, kmeans_time)</span><br><span class="line">print(<span class="string">&#x27;Mini Batch K-Means耗时:&#x27;</span>, mbk_time)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 绘制聚类效果</span></span><br><span class="line">plt.figure(figsize=(<span class="number">12</span>, <span class="number">5</span>))</span><br><span class="line">model = [kmeans, mbk]</span><br><span class="line"><span class="keyword">for</span> i, m <span class="keyword">in</span> <span class="built_in">enumerate</span>(model, start=<span class="number">1</span>):</span><br><span class="line">    plt.subplot(<span class="number">1</span>, <span class="number">2</span>, i)</span><br><span class="line">    plot_cluster(m, x)</span><br></pre></td></tr></table></figure>

<pre><code>K-Means耗时: 0.08678650856018066
Mini Batch K-Means耗时: 0.05485272407531738</code></pre>
<p><img src="https://wx2.sbimg.cn/2020/07/04/2ONKU.md.png" alt="png"></p>
<p>可见, 聚类耗时 K-Means 更多, 如果数据量很大, 耗时会更明显, 而聚类效果基本一样. 但发现颜色对不上, 这是因为质心的随机性, 聚类之后质心虽然最终落在相同的位置, 但是顺序不一致, 从而聚类的结果标签不一致, 即使是同一个算法, 运行几次, 标签结果也会不一致</p>
<p>我们将相同簇用相同的颜色绘制:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">plt.figure(figsize=(<span class="number">12</span>, <span class="number">5</span>))</span><br><span class="line"><span class="comment"># 定义列表, 用来保存两个模型预测结果</span></span><br><span class="line">y_hat_list = []</span><br><span class="line"><span class="keyword">for</span> i, m <span class="keyword">in</span> <span class="built_in">enumerate</span>(model, start=<span class="number">1</span>):</span><br><span class="line">    plt.subplot(<span class="number">1</span>, <span class="number">2</span>, i)</span><br><span class="line">    y_hat = m.predict(x)</span><br><span class="line">    <span class="keyword">if</span> m == mbk:</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">        因为输出的质心顺序就是训练结果标签的顺序</span></span><br><span class="line"><span class="string">        故可以按 mbk 训练的质心, 去找 kmeans 训练的相同簇的质心</span></span><br><span class="line"><span class="string">        </span></span><br><span class="line"><span class="string">        pairwise_distances_argmin(x, y) 解释:</span></span><br><span class="line"><span class="string">        依次取出数组 X 中的元素 x, </span></span><br><span class="line"><span class="string">        计算找到数组 Y 中与 x 距离最近的元素 y 的索引, </span></span><br><span class="line"><span class="string">        返回索引构成的数组</span></span><br><span class="line"><span class="string">        &#x27;&#x27;&#x27;</span></span><br><span class="line">        <span class="comment"># 将两者相同簇的质心一一对应并按 mbk 质心的顺序封装成字典</span></span><br><span class="line">        ar = pairwise_distances_argmin(</span><br><span class="line">        mbk.cluster_centers_, kmeans.cluster_centers_)</span><br><span class="line">        dict_ = <span class="built_in">dict</span>(<span class="built_in">enumerate</span>(ar))</span><br><span class="line">        <span class="comment"># 用 mbk 的训练结果标签 y_hat 就可以寻找到对应的 kmeans 的质心</span></span><br><span class="line">        y_hat = pd.Series(y_hat).<span class="built_in">map</span>(dict_).values</span><br><span class="line">    <span class="comment"># 将预测结果加入到列表中</span></span><br><span class="line">    y_hat_list.append(y_hat)</span><br><span class="line">    </span><br><span class="line">    plt.scatter(x[:, <span class="number">0</span>], x[:, <span class="number">1</span>], c=colors[y_hat], marker=<span class="string">&#x27;.&#x27;</span>)</span><br></pre></td></tr></table></figure>


<p><img src="https://wx2.sbimg.cn/2020/07/04/2OERm.md.png" alt="png"></p>
<p>比较两个算法聚类结果的差异:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">same = y_hat_list[<span class="number">0</span>] == y_hat_list[<span class="number">1</span>]</span><br><span class="line">diff = y_hat_list[<span class="number">0</span>] != y_hat_list[<span class="number">1</span>]</span><br><span class="line">plt.scatter(x[same, <span class="number">0</span>], x[same, <span class="number">1</span>], c=<span class="string">&#x27;g&#x27;</span>, marker=<span class="string">&#x27;.&#x27;</span>, label=<span class="string">&#x27;预测相同&#x27;</span>)</span><br><span class="line">plt.scatter(x[diff, <span class="number">0</span>], x[diff, <span class="number">1</span>], c=<span class="string">&#x27;r&#x27;</span>, marker=<span class="string">&#x27;.&#x27;</span>, label=<span class="string">&#x27;预测不同&#x27;</span>)</span><br><span class="line">plt.legend()</span><br><span class="line">print(<span class="string">&#x27;相同数量:&#x27;</span>, x[same].shape[<span class="number">0</span>])</span><br><span class="line">print(<span class="string">&#x27;不同数量:&#x27;</span>, x[diff].shape[<span class="number">0</span>])</span><br></pre></td></tr></table></figure>

<pre><code>相同数量: 7983
不同数量: 17</code></pre>
<p><img src="https://wx2.sbimg.cn/2020/07/04/2Obyd.png" alt="png"></p>
<p>两个算法聚类结果只有 17 个样本点不同</p>
<br>

]]></content>
      <categories>
        <category>数据分析</category>
      </categories>
      <tags>
        <tag>数理统计</tag>
      </tags>
  </entry>
  <entry>
    <title>朴素贝叶斯</title>
    <url>/data/statistics7-09facbbd1b27/</url>
    <content><![CDATA[<blockquote>
<p>文章主要内容和思路来源: <strong>开课吧</strong>学习笔记</p>
</blockquote>
<h2 id="八-朴素贝叶斯"><a href="#八-朴素贝叶斯" class="headerlink" title="八, 朴素贝叶斯"></a>八, 朴素贝叶斯</h2><h3 id="1-概率基础"><a href="#1-概率基础" class="headerlink" title="1, 概率基础"></a>1, 概率基础</h3><p><strong>样本空间</strong>:</p>
<p>在<strong>随机试验</strong> E 中, 实验的所有可能结果组成的集合, 称为<strong>样本空间</strong> S, 样本空间的每个元素, 即 E 的每个结果, 称<strong>样本点</strong></p>
<p><strong>随机事件</strong>:</p>
<p>进行随机试验时, 满足某种条件的样本点组成的集合, S 的子集, 称作<strong>随机事件</strong>, 只有一个样本点时, 称作<strong>基本事件</strong></p>
<p><strong>概率</strong>:</p>
<p>对于随机事件 A, 概率为:</p>
<p>$P(A)=\frac{A \text { 中基本事件数 }}{S \text { 中基本事件数 }}$</p>
<p><strong>条件概率</strong>:</p>
<p>定义事件 A 发生的前提下, 事件 B 发生的概率 P(B | A) 为条件概率:</p>
<p>$$P(B \mid A)=\frac{P(A B)}{P(A)}$$</p>
<p>由条件概率的定义可得, 事件 A 和 B 同时发生的概率 P(AB) 满足如下<strong>乘法定理</strong>:</p>
<p>$$P(A B)=P(B \mid A) P(A)$$</p>
<p><strong>独立性:</strong></p>
<p>定义 A 和 B 两个事件, 如果满足:</p>
<p>$$P(A B)=P(A) P(B)$$</p>
<p>则称事件 A, B 相互独立. 再结合乘法定理, 则有:</p>
<p>$$P(B \mid A) = P(B)$$</p>
<p><strong>全概率公式:</strong></p>
<p>设随机试验 E 的样本空间为 S, 若事件 $B_{1}$，$B_{2}$，…, $B_{n}$ 构成一个完备事件组(即它们两两相互独立，事件并集为 S), 且都有正概率，则对任意一个 E 的事件 A，有如下公式成立：</p>
<p>$$P(A)=P\left(A \mid B_{1}\right) P\left(B_{1}\right)+P\left(A \mid B_{2}\right) P\left(B_{2}\right)+\ldots \ldots+P\left(A \mid B_{n}\right) P\left(B_{n}\right)$$</p>
<p>此公式即为全概率公式. 特别地，对于任意两随机事件 A 和 B，有如下成立：</p>
<p>$$P(B)=P(B \mid A) P(A)+P(B \mid \bar{A}) P(\bar{A})$$</p>
<p><strong>贝叶斯公式:</strong></p>
<p>设随机试验 E 的样本空间为 S, 若事件 $B_{1}$，$B_{2}$，…, $B_{n}$ 构成一个完备事件组(即它们两两相互独立，事件并集为 S), 且都有正概率，则对任意一个 E 的正概率事件 A，有如下公式成立( i 为 1~n 的正整数)：</p>
<p>$$P\left(B_{i} \mid A\right)=\frac{P\left(A B_{i}\right)}{P(A)}=\frac{P\left(A \mid B_{i}\right) P\left(B_{i}\right)}{P(A)} \<br>=\frac{P\left(A \mid B_{i}\right) P\left(B_{i}\right)}{\sum_{j=1}^{n} P\left(A \mid B_{j}\right) P\left(B_{j}\right)}$$</p>
<p>贝叶斯公式将求解 P(B | A) 的概率转换成求 P(A | B) 的概率, 在求解某个事件概率非常困难时, 转换一下更方便求解</p>
<p>例: 从以往数据得出, 机器调整良好时生产的产品合格的概率是 98%, 机器故障时合格的概率是 55%, 每天开机时机器调整良好的概率为 95%. 求某日开机生产的第一件产品是合格品时, 机器调整良好的概率?</p>
<p>解: 设事件 A 为产品合格, B 为机器调整良好, 则 $\bar{B}$ 为机器故障</p>
<p>$$P(B \mid A)=\frac{P(A \mid B) P(B)}{P(A \mid B) P(B)+P(A \mid \bar{B}) P(\bar{B})} \<br>=\frac{0.98 \times 0.95}{0.98 \times 0.95+0.55 \times 0.05} \<br>=0.97$$</p>
<p><strong>先验概率和后验概率:</strong></p>
<p>由以往的数据得出的概率称为<strong>先验概率</strong>, 如上例中的已知概率</p>
<p>得到某些信息后, 在先验概率的基础上进行修正而得到的概率, 称为<strong>后验概率</strong>, 如上例中求解的概率</p>
<h3 id="2-朴素贝叶斯算法原理"><a href="#2-朴素贝叶斯算法原理" class="headerlink" title="2, 朴素贝叶斯算法原理"></a>2, 朴素贝叶斯算法原理</h3><p>朴素贝叶斯是基于概率的分类算法, 前提假设各个特征(自变量)之间是相互独立的, 设类别(因变量)为 Y, Y 包含 m 个类别($y_{1}, \ldots, y_{m}$), 特征为 X, X 包含含有 n 个特征 ($x_{1}, \ldots, x_{n}$), 然后通过计算比较, 在特征 X 确定的前提下, 类别 Y 中每个类别的概率大小, 概率最大者即为预测结果</p>
<p>设 Y 中任意一个类别为 y, 则:</p>
<p>$$P(y \mid X) = P\left(y \mid x_{1}, \ldots, x_{n}\right) \<br>=\frac{P(y) P\left(x_{1}, \ldots, x_{n} \mid y\right)}{P\left(x_{1}, \ldots, x_{n}\right)} \<br>=\frac{P(y) P\left(x_{1} \mid y\right) P\left(x_{2} \mid y\right) \ldots P\left(x_{n} \mid y\right)}{P\left(x_{1}, \ldots, x_{n}\right)} \<br>=\frac{P(y) \prod_{i=1}^{n} P\left(x_{i} \mid y\right)}{P\left(x_{1}, \ldots, x_{n}\right)}$$</p>
<p>上式分母为定值, 则:</p>
<p>$$P\left(y \mid X \right) \propto P(y) \prod_{i=1}^{n} P\left(x_{i} \mid y\right)$$</p>
<p>所以最终预测类别 $\hat{y}$ 为分子部分值最大对应的类别:</p>
<p>$$\hat{y}=\arg \max_{y} P(y) \prod_{i=1}^{n} P\left(x_{i} \mid y\right)$$</p>
<p>不同的朴素贝叶斯算法, 主要是对 $P\left(x_{i} \mid y\right)$ 的分布假设不同, 进而采取不同的参数估计方式. 最终主要就是通过计算  $P\left(x_{i} \mid y\right)$ 的概率来计算结果</p>
<p>例: 预测第 11 条记录, 学生是否上课</p>
<table>
   <tr>
      <td>序号</td>
      <td>天气</td>
      <td>上课距离</td>
      <td>成绩</td>
      <td>课程</td>
      <td>上课情况</td>
   </tr>
   <tr>
      <td>1</td>
      <td>晴</td>
      <td>远</td>
      <td>差</td>
      <td>选修</td>
      <td>逃课</td>
   </tr>
   <tr>
      <td>2</td>
      <td>晴</td>
      <td>近</td>
      <td>差</td>
      <td>必修</td>
      <td>上课</td>
   </tr>
   <tr>
      <td>3</td>
      <td>晴</td>
      <td>近</td>
      <td>好</td>
      <td>必修</td>
      <td>上课</td>
   </tr>
   <tr>
      <td>4</td>
      <td>阴</td>
      <td>远</td>
      <td>差</td>
      <td>选修</td>
      <td>逃课</td>
   </tr>
   <tr>
      <td>5</td>
      <td>阴</td>
      <td>近</td>
      <td>好</td>
      <td>选修</td>
      <td>上课</td>
   </tr>
   <tr>
      <td>6</td>
      <td>阴</td>
      <td>近</td>
      <td>好</td>
      <td>必修</td>
      <td>上课</td>
   </tr>
   <tr>
      <td>7</td>
      <td>雨</td>
      <td>远</td>
      <td>差</td>
      <td>选修</td>
      <td>逃课</td>
   </tr>
   <tr>
      <td>8</td>
      <td>雨</td>
      <td>近</td>
      <td>好</td>
      <td>必修</td>
      <td>上课</td>
   </tr>
   <tr>
      <td>9</td>
      <td>雨</td>
      <td>近</td>
      <td>差</td>
      <td>必修</td>
      <td>逃课</td>
   </tr>
   <tr>
      <td>10</td>
      <td>雨</td>
      <td>远</td>
      <td>好</td>
      <td>选修</td>
      <td>逃课</td>
   </tr>
   <tr>
      <td>11</td>
      <td>阴</td>
      <td>近</td>
      <td>差</td>
      <td>选修</td>
      <td>?</td>
   </tr>
   <tr>
      <td>12</td>
      <td>晴</td>
      <td>远</td>
      <td>好</td>
      <td>选修</td>
      <td>?</td>
   </tr>
</table>

<p>分别计算上课和逃课情况下, 各自的概率:</p>
<p>$$P(y=\text { 上课 }) \prod_{i=1}^{n} P\left(x_{i} \mid y=\text { 上课 }\right) \<br>=P(y=\text { 上课 }) P\left(x_{1}=\text { 阴 } \mid y=\text { 上课 }\right) P\left(x_{2}=\text { 近 } \mid y=\text { 上课 }\right) \<br>P\left(x_{3}=\text {差 } \mid y=\text { 上课 }\right) P\left(x_{4}=\text { 选修 } \mid y=\text { 上课 }\right) \<br>=0.5 \times 0.4 \times 1 \times 0.2 \times 0.2 \<br>=0.008$$</p>
<p>$$P(y=\text { 逃课 }) \prod_{i=1}^{n} P\left(x_{i} \mid y=\text { 逃课 }\right) \<br>=P(y=\text { 逃课 }) P\left(x_{1}=\text { 阴 } \mid y=\text { 逃课 }\right) P\left(x_{2}=\text { 近 } \mid y=\text { 逃课 }\right) \<br>P\left(x_{3}=\text { 差 } \mid y=\text { 逃课 }\right) P\left(x_{4}=\text { 选修 } \mid y=\text { 逃课 }\right) \<br>=0.5 \times 0.2 \times 0.2 \times 0.8 \times 0.8 \<br>=0.0128$$</p>
<p>可得预测结果为: 逃课</p>
<h3 id="3-平滑改进"><a href="#3-平滑改进" class="headerlink" title="3, 平滑改进"></a>3, 平滑改进</h3><p>当我们预测上例中, 第 12 条记录所属的类别时, 因为样本不是总体, 会出现上课的前提下, 距离远的概率为 0, 造成计算结果也为 0, 影响了预测结果, 因此需要平滑改进:</p>
<p>$$ P\left(x_{i} \mid y\right)=\frac{\text { 类别 } y \text { 中 } x_{i} \text { 取某个值出现的次数 }+ \alpha}{\text { 类别别 }  y \text { 的总数 }+k * \alpha} $$</p>
<p>其中, k 为特征 $x_{i}$ 可能的取值数, α (α ≥ 0) 称为平滑系数, 当 α = 1 时, 称拉普拉斯平滑( Laplace smoothing)</p>
<h3 id="4-算法优点"><a href="#4-算法优点" class="headerlink" title="4, 算法优点"></a>4, 算法优点</h3><p>即使训练集数据较少, 也能实现不错的预测; 算法训练速度非常快</p>
<p>因此算法假设特征之间是独立的, 可以单独考虑. 如果训练集有 N 个特征, 每个特征需要 M 个样本来训练, 则只需要训练 N*M 的样本数量, 而不是笛卡儿积的形式指数级增加</p>
<p>常用的朴素贝叶斯有: 高斯朴素贝叶斯, 伯努利朴素贝叶斯, 多项式朴素贝叶斯</p>
<h3 id="5-高斯朴素贝叶斯"><a href="#5-高斯朴素贝叶斯" class="headerlink" title="5, 高斯朴素贝叶斯"></a>5, 高斯朴素贝叶斯</h3><p>适用于连续变量, 其假定各个特征 x 在各个类别 y 下服从正态分布:</p>
<p>$$x_{i} \sim N\left(\mu_{y}, \sigma_{y}^{2}\right)$$</p>
<p>算法使用概率密度函数来计算 $P\left(x_{i} \mid y\right)$ 的概率:</p>
<p>$$P\left(x_{i} \mid y\right)=\frac{1}{\sqrt{2 \pi \sigma_{y}^{2}}} \exp \left(-\frac{\left(x_{i}-\mu_{y}\right)^{2}}{2 \sigma_{y}^{2}}\right) $$</p>
<p>$\mu_{y}$:  在类别为  y  的样本中, 特征  $x_{i}$  的均值<br>$\sigma_{y}$:  在类别为  y  的样本中, 特征 $x_{i}$  的标件差</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">from</span> sklearn.naive_bayes <span class="keyword">import</span> GaussianNB</span><br><span class="line"></span><br><span class="line">np.random.seed(<span class="number">0</span>)</span><br><span class="line">x = np.random.randint(<span class="number">0</span>, <span class="number">10</span>, size=(<span class="number">8</span>, <span class="number">3</span>))</span><br><span class="line">y = np.array([<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>])</span><br><span class="line">data = pd.DataFrame(np.concatenate([x, y.reshape(<span class="number">-1</span>, <span class="number">1</span>)], axis=<span class="number">1</span>),</span><br><span class="line">                   columns=[<span class="string">&#x27;x1&#x27;</span>, <span class="string">&#x27;x2&#x27;</span>, <span class="string">&#x27;x3&#x27;</span>, <span class="string">&#x27;y&#x27;</span>])</span><br><span class="line">display(data[:<span class="number">3</span>])</span><br><span class="line"></span><br><span class="line">gnb = GaussianNB()</span><br><span class="line">gnb.fit(x, y)</span><br><span class="line"></span><br><span class="line">print(<span class="string">&#x27;类别标签:&#x27;</span>, gnb.classes_)</span><br><span class="line">print(<span class="string">&#x27;每个类别的先验概率:&#x27;</span>, gnb.class_prior_)</span><br><span class="line">print(<span class="string">&#x27;样本数量:&#x27;</span>, gnb.class_count_)</span><br><span class="line">print(<span class="string">&#x27;每个类别下特征的均值:&#x27;</span>, gnb.theta_)</span><br><span class="line">print(<span class="string">&#x27;每个类别下特征的方差:&#x27;</span>, gnb.sigma_)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 测试集</span></span><br><span class="line">x_test = np.array([[<span class="number">5</span>, <span class="number">7</span>, <span class="number">2</span>]])</span><br><span class="line">print(<span class="string">&#x27;预测结果:&#x27;</span>, gnb.predict(x_test))</span><br><span class="line">print(<span class="string">&#x27;预测结果概率:&#x27;</span>, gnb.predict_proba(x_test))</span><br></pre></td></tr></table></figure>


<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

<pre><code>.dataframe tbody tr th &#123;
    vertical-align: top;
&#125;

.dataframe thead th &#123;
    text-align: right;
&#125;</code></pre>
<p></style></p>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>x1</th>
      <th>x2</th>
      <th>x3</th>
      <th>y</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>5</td>
      <td>0</td>
      <td>3</td>
      <td>0</td>
    </tr>
    <tr>
      <th>1</th>
      <td>3</td>
      <td>7</td>
      <td>9</td>
      <td>1</td>
    </tr>
    <tr>
      <th>2</th>
      <td>3</td>
      <td>5</td>
      <td>2</td>
      <td>0</td>
    </tr>
  </tbody>
</table>
</div>


<pre><code>类别标签: [0 1]
每个类别的先验概率: [0.5 0.5]
样本数量: [4. 4.]
每个类别下特征的均值: [[5.   5.   3.  ]
 [6.5  5.75 7.5 ]]
每个类别下特征的方差: [[3.50000001 9.50000001 3.50000001]
 [5.25000001 7.68750001 2.75000001]]
预测结果: [0]
预测结果概率: [[0.99567424 0.00432576]]</code></pre>
<h3 id="6-伯努利朴素贝叶斯"><a href="#6-伯努利朴素贝叶斯" class="headerlink" title="6, 伯努利朴素贝叶斯"></a>6, 伯努利朴素贝叶斯</h3><p>设实验 E 只有两个可能的结果, A 与 $\bar{A}$, 则称 E 为伯努利试验</p>
<p>伯努利朴素贝叶斯, 适用于离散变量, 其假设各个特征 x 在各个类别 y 下服从 n 重伯努利分布(二项分布), 因伯努利试验仅有两个结果, 算法会首先对特征值进行二值化处理(假设二值化结果为 1 和 0 )</p>
<p>$P\left(x_{i} \mid y\right)$ 的概率为:</p>
<p>$$P\left(x_{i} \mid y\right)=P\left(x_{i}=1 \mid y\right) x_{i}+\left(1-P\left(x_{i}=1 \mid y\right)\right)\left(1-x_{i}\right)$$</p>
<p>在训练集中, 会进行如下评估:</p>
<p>$$ P\left(x_{i}=1 \mid y\right)=\frac{N_{y i}+\alpha}{N_{y}+2 * \alpha} \<br> P\left(x_{i}=0 \mid y\right)=1-P\left(x_{i}=1 \mid y\right) $$</p>
<p>$N_{y i}$:  第  i  特征中, 属于类别  y,  数值为 1 的样本个数<br>$N_{y}$:  属于类別 y 的所有样本个数<br>$\alpha$:  平滑系数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.naive_bayes <span class="keyword">import</span> BernoulliNB</span><br><span class="line"></span><br><span class="line">np.random.seed(<span class="number">0</span>)</span><br><span class="line">x = np.random.randint(<span class="number">-5</span>, <span class="number">5</span>, size=(<span class="number">8</span>, <span class="number">3</span>))</span><br><span class="line">y = np.array([<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>])</span><br><span class="line">data = pd.DataFrame(np.concatenate([x, y.reshape(<span class="number">-1</span>, <span class="number">1</span>)], axis=<span class="number">1</span>),</span><br><span class="line">                   columns=[<span class="string">&#x27;x1&#x27;</span>, <span class="string">&#x27;x2&#x27;</span>, <span class="string">&#x27;x3&#x27;</span>, <span class="string">&#x27;y&#x27;</span>])</span><br><span class="line">display(data[:<span class="number">3</span>])</span><br><span class="line"></span><br><span class="line">bnb = BernoulliNB()</span><br><span class="line">bnb.fit(x, y)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 统计每个类别下, 特征中二值化后, 每个特征下值 1 出现的次数</span></span><br><span class="line">print(<span class="string">&#x27;值 1 出现的次数:&#x27;</span>, bnb.feature_count_)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 每个类别的先验概率, 算法得到的该概率值是取对数后的结果,</span></span><br><span class="line"><span class="comment"># 需要取指数还原</span></span><br><span class="line">print(<span class="string">&#x27;每个类别的先验概率:&#x27;</span>, np.exp(bnb.class_log_prior_))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 每个类别下, 每个特征的概率(也需要取指数还原)</span></span><br><span class="line">print(<span class="string">&#x27;每个特征的概率:&#x27;</span>, np.exp(bnb.feature_log_prob_))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 测试集</span></span><br><span class="line">x_test = np.array([[<span class="number">-5</span>, <span class="number">0</span>, <span class="number">2</span>]])</span><br><span class="line">print(<span class="string">&#x27;预测结果:&#x27;</span>, bnb.predict(x_test))</span><br><span class="line">print(<span class="string">&#x27;预测结果概率:&#x27;</span>, bnb.predict_proba(x_test))</span><br></pre></td></tr></table></figure>


<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

<pre><code>.dataframe tbody tr th &#123;
    vertical-align: top;
&#125;

.dataframe thead th &#123;
    text-align: right;
&#125;</code></pre>
<p></style></p>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>x1</th>
      <th>x2</th>
      <th>x3</th>
      <th>y</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>0</td>
      <td>-5</td>
      <td>-2</td>
      <td>0</td>
    </tr>
    <tr>
      <th>1</th>
      <td>-2</td>
      <td>2</td>
      <td>4</td>
      <td>1</td>
    </tr>
    <tr>
      <th>2</th>
      <td>-2</td>
      <td>0</td>
      <td>-3</td>
      <td>0</td>
    </tr>
  </tbody>
</table>
</div>


<pre><code>值 1 出现的次数: [[1. 2. 1.]
 [3. 3. 3.]]
每个类别的先验概率: [0.5 0.5]
每个特征的概率: [[0.33333333 0.5        0.33333333]
 [0.66666667 0.66666667 0.66666667]]
预测结果: [0]
预测结果概率: [[0.6 0.4]]</code></pre>
<h3 id="7-多项式朴素贝叶斯"><a href="#7-多项式朴素贝叶斯" class="headerlink" title="7, 多项式朴素贝叶斯"></a>7, 多项式朴素贝叶斯</h3><p>多项式朴素贝叶斯, 适用于离散变量, 其假设各个特征 x 在各个类别 y 下服从多项式分布(每个特征下的值之和, 就是该特征发生(出现)的次数), 因此每个特征值不能是负数</p>
<p>$P\left(x_{i} \mid y\right)$ 的概率为:</p>
<p>$$P\left(x_{i} \mid y\right)=\frac{N_{y i}+\alpha}{N_{y}+\alpha n} $$</p>
<p>$N_{y i}$:  特征 i 在类别 y 的样本中发生(出现)的次数<br>$N_{y}$:  类别  y  的样本中, 所有特征发生(出现)的次数<br>$n$:  特征数量<br>$\alpha$:  平滑系数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.naive_bayes <span class="keyword">import</span> MultinomialNB</span><br><span class="line"></span><br><span class="line">np.random.seed(<span class="number">0</span>)</span><br><span class="line">x = np.random.randint(<span class="number">1</span>, <span class="number">5</span>, size=(<span class="number">8</span>, <span class="number">3</span>))</span><br><span class="line">y = np.array([<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>])</span><br><span class="line">data = pd.DataFrame(np.concatenate([x, y.reshape(<span class="number">-1</span>, <span class="number">1</span>)], axis=<span class="number">1</span>),</span><br><span class="line">                   columns=[<span class="string">&#x27;x1&#x27;</span>, <span class="string">&#x27;x2&#x27;</span>, <span class="string">&#x27;x3&#x27;</span>, <span class="string">&#x27;y&#x27;</span>])</span><br><span class="line">display(data[:<span class="number">3</span>])</span><br><span class="line"></span><br><span class="line">mnb = MultinomialNB()</span><br><span class="line">mnb.fit(x, y)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 每个类别的样本数量</span></span><br><span class="line">print(<span class="string">&#x27;每个类别的样本数:&#x27;</span>, mnb.class_count_)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 每个特征在每个类别下发生(出现)的次数</span></span><br><span class="line">print(<span class="string">&#x27;每个特征发生(出现)次数:&#x27;</span>, mnb.feature_count_)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 每个类别下, 每个特征的概率(需要取指数还原)</span></span><br><span class="line">print(<span class="string">&#x27;每个类别下特征的概率:&#x27;</span>, np.exp(mnb.feature_log_prob_))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 测试集</span></span><br><span class="line">x_test = np.array([[<span class="number">1</span>, <span class="number">1</span>, <span class="number">4</span>]])</span><br><span class="line">print(<span class="string">&#x27;预测结果:&#x27;</span>, mnb.predict(x_test))</span><br><span class="line">print(<span class="string">&#x27;预测结果概率:&#x27;</span>, mnb.predict_proba(x_test))</span><br></pre></td></tr></table></figure>


<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

<pre><code>.dataframe tbody tr th &#123;
    vertical-align: top;
&#125;

.dataframe thead th &#123;
    text-align: right;
&#125;</code></pre>
<p></style></p>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>x1</th>
      <th>x2</th>
      <th>x3</th>
      <th>y</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>1</td>
      <td>4</td>
      <td>2</td>
      <td>0</td>
    </tr>
    <tr>
      <th>1</th>
      <td>1</td>
      <td>4</td>
      <td>4</td>
      <td>1</td>
    </tr>
    <tr>
      <th>2</th>
      <td>4</td>
      <td>4</td>
      <td>2</td>
      <td>0</td>
    </tr>
  </tbody>
</table>
</div>


<pre><code>每个类别的样本数: [4. 4.]
每个特征发生(出现)次数: [[10. 14. 10.]
 [ 9. 11. 11.]]
每个类别下特征的概率: [[0.2972973  0.40540541 0.2972973 ]
 [0.29411765 0.35294118 0.35294118]]
预测结果: [1]
预测结果概率: [[0.36890061 0.63109939]]</code></pre>
<p><strong>利用鸢尾花数据集比较上述 3 个贝叶斯算法:</strong></p>
<p>对不同的数据集, 根据其分布情况选择适合的算法, 能得到更好的结果</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.datasets <span class="keyword">import</span> load_iris</span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line"></span><br><span class="line">x, y = load_iris(return_X_y=<span class="literal">True</span>)</span><br><span class="line">x_train, x_test, y_train, y_test = train_test_split(x, y,</span><br><span class="line">                        test_size=<span class="number">0.25</span>, random_state=<span class="number">0</span>)</span><br><span class="line">models = [(<span class="string">&#x27;高斯朴素贝叶斯分值:&#x27;</span>, GaussianNB()),</span><br><span class="line">          (<span class="string">&#x27;伯努利朴素贝叶斯分值:&#x27;</span>, BernoulliNB()),</span><br><span class="line">          (<span class="string">&#x27;多项式朴素贝叶斯分值:&#x27;</span>, MultinomialNB())]</span><br><span class="line"><span class="keyword">for</span> name, m <span class="keyword">in</span> models:</span><br><span class="line">    m.fit(x_train, y_train)</span><br><span class="line">    print(name, m.score(x_test, y_test))</span><br></pre></td></tr></table></figure>

<pre><code>高斯朴素贝叶斯分值: 1.0
伯努利朴素贝叶斯分值: 0.23684210526315788
多项式朴素贝叶斯分值: 0.5789473684210527</code></pre>
<br>

]]></content>
      <categories>
        <category>数据分析</category>
      </categories>
      <tags>
        <tag>数理统计</tag>
      </tags>
  </entry>
  <entry>
    <title>Hive 介绍和 HiveQL 库和表初探</title>
    <url>/data/hadoop1-ce4bb28dd03c/</url>
    <content><![CDATA[<blockquote>
<p>文章主要内容和思路来源: <strong>开课吧</strong>学习笔记</p>
</blockquote>
<p><font color=#00A600 >2020年8月9日更新</font></p>
<h2 id="一-Hive-介绍"><a href="#一-Hive-介绍" class="headerlink" title="一, Hive 介绍"></a>一, Hive 介绍</h2><h3 id="1-关于大数据"><a href="#1-关于大数据" class="headerlink" title="1, 关于大数据"></a>1, 关于大数据</h3><p>大数据指无法在一定时间范围内用传统数据处理应用程序进行捕捉,管理和处理的极其庞大, 复杂的数据集合. 大数据通常还指用更高级的处理模式和分析方法, 优化和提取海量, 高增长率和多样化数据的价值. </p>
<p>大数据的 4V+1O 特征:</p>
<ul>
<li><p>数据量大(volume): 采集, 储存, 计算量都非常大.</p>
</li>
<li><p>类型繁多(variety): 种类和来源多样化. 结构和非结构, 文本, 音频, 图片, 视频等等.</p>
</li>
<li><p>价值密度低(value): 沙里淘金又弥足珍贵.</p>
</li>
<li><p>速度快时效高(velocity): 增长速度快, 处理速度快, 时效性要求高. 搜索引擎要求几分钟之前的新闻就能被用户查到, 推荐算法要求尽可能实时推荐.</p>
</li>
<li><p>数据在线(online): 数据永远在线, 随时调用计算(OLTP). </p>
</li>
</ul>
<h3 id="2-关于-hadoop"><a href="#2-关于-hadoop" class="headerlink" title="2, 关于 hadoop"></a>2, 关于 hadoop</h3><p>云计算是分布式计算, 并行计算, 网格计算, 多核计算, 网络存储, 虚拟化, 负载均衡等传统计算机技术和互联网技术融合发展的产物. 借助 IaaS(基础设施服务), PaaS(平台服务), SaaS(软件服务)等业务模式, 把强大的计算能力提供给终端用户(自主权 IaaS &gt; PaaS &gt; SaaS).</p>
<p>云计算的两大底层支撑技术: 虚拟化, 大数据.</p>
<p>Hadoop 是 Apache 旗下的一套开源软件平台, 是云计算 PaaS 层的解决方案之一. 其提供了利用服务器集群, 根据用户自定义业务逻辑, 对海量数据进行分布式处理的能力, 有高可靠性、高可拓展性、高容错性和高效性. </p>
<p>Hadoop 生态圈:</p>
<p><img src="/images/hadoop.jpg"></p>
<p>Hadoop 的主要组成: 分布式存储 HDFS, 分布式计算 MapReduce, 资源调度引擎 Yarn.</p>
<h3 id="3-关于-Hive"><a href="#3-关于-Hive" class="headerlink" title="3, 关于 Hive"></a>3, 关于 Hive</h3><p>Hive 是基于 Hadoop 构建的一套数据仓库分析系统，它提供了丰富的 SQL 查询方式来分析存储在 Hadoop 的分布式文件系统中的数据：</p>
<ul>
<li><p>可以将结构化的数据文件映射为一张数据库表，并提供完整的 SQL 查询功能.</p>
</li>
<li><p>可以将 SQL 语句转换为 MapReduce 任务运行，通过自己的 SQL 查询分析需要的内容，这套 SQL 简称 HiveQL，使不熟悉 mapreduce 的用户可以很方便地利用 SQL 语言查询, 汇总和分析数据.</p>
</li>
</ul>
<p>Hive 不适合用于联机事务处理(OLTP), 不提供实时的查询和基于行级的数据更新操作; 它是专为联机分析处理(OLAP)设计, 最适合应用在基于大量不可变数据的批处理作业.</p>
<p>Hive 在加载数据过程中不会对数据进行任何的修改，只是将数据移动到 HDFS 中 hive 设定的目录下，因此 hive 不支持对数据的改写和添加，所有的数据都在加载的时候确定. </p>
<h3 id="4-Hive-的数据类型"><a href="#4-Hive-的数据类型" class="headerlink" title="4, Hive 的数据类型"></a>4, Hive 的数据类型</h3><p>基本数据类型:</p>
<p>TINYINT, SALLINT, INT, BIGINT, BOLLEAN, FLOAT, DOUBLE, STRING, BINARY, TIMESTAMP, DECIMAL, CHAR, VARCHAR, DATE.</p>
<p>复杂数据类型:</p>
<p>STRUCT 类型, 可以通过 <code>.</code> 符号访问元素内容. 例如某列数据类型是 STRUCT(first str1, last str2), 那么第一个元素可以通过 <code>.first</code> 来引用.</p>
<p>MAP 类型, 一组 键-值 对元组集合, 使用数组表示法, 可以访问数据. 例如某列数据类型是 MAP, ‘first’-‘str1’, ‘last’-‘str2’, 可以通过 <code>[&#39;last&#39;]</code> 获取后一个元素.</p>
<p>ARRAY 类型, 就是数组, 可以通过下标进行元素引用.</p>
<h2 id="二-HiveQL-库和表初探"><a href="#二-HiveQL-库和表初探" class="headerlink" title="二, HiveQL 库和表初探"></a>二, HiveQL 库和表初探</h2><p>(HiveQL 语句, 很多和 SQL 语句一样, 不同之处还需要统计加以区分)</p>
<p><a href="https://cwiki.apache.org/confluence/display/Hive/Home">Hive 官方文档</a></p>
<h3 id="1-数据库"><a href="#1-数据库" class="headerlink" title="1, 数据库"></a>1, 数据库</h3><p>a, 创建数据库:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create (database&#x2F;schema) [if not exists] 库名</span><br><span class="line">[comment 数据库描述]</span><br><span class="line">[location hdfs路径]</span><br><span class="line">[with dbproperties (属性名&#x3D;属性值, ...)];</span><br></pre></td></tr></table></figure>

<p>b, 查看数据库信息:</p>
<p><code>desc database extended 数据库名;</code></p>
<p>c, 删除数据库:</p>
<p><code>drop database if exists 数据库名 cascade;</code>, 加上 cascade 表示强制删除.</p>
<p>d, 修改数据库:</p>
<p><code>alter (database/schema) 数据库名 set 属性名 新属性值;</code></p>
<h3 id="2-数据表"><a href="#2-数据表" class="headerlink" title="2, 数据表"></a>2, 数据表</h3><p>a, 创建数据表:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create [externa] table if not exists 表名  # external 表示创建外部表</span><br><span class="line">    (列名 数据类型 [comment 列描述],</span><br><span class="line">     ...</span><br><span class="line">    )</span><br><span class="line">[comment 表描述]</span><br><span class="line">[partitioned by (列名 数据类型 [comment 列描述], ...)]  # 分区表</span><br><span class="line">[clustered by (列名, 列名, ...)]                       # 分桶表</span><br><span class="line">[sorted by (列名 [asc|desc], ...)]                     # 排序</span><br><span class="line">[row format 行格式]</span><br><span class="line">[stored as 文件存储类型]</span><br><span class="line">[location hdfs路径]</span><br><span class="line">[tblproperties (属性名&#x3D;属性值, ...)]</span><br><span class="line">[as 查询语句]</span><br></pre></td></tr></table></figure>

<p>Hive 中分区表, 将数据按一定逻辑进行组织, 查询分区表时, 除非 where 语句包含分区字段过滤条件控制数据查询范围, 否则不允许执行, 防止扫描所有分区消耗巨大资源.</p>
<p>b, 查看数据表结构:</p>
<p><code>desc formatted 表名;</code></p>
<p>c, 修改表:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 修改表名</span><br><span class="line">alter table 表名 rename to 新表名;  </span><br><span class="line"># 表中添加列</span><br><span class="line">alter table 表名 add columns (列名 类型 描述, ...);</span><br><span class="line"># 修改列名</span><br><span class="line">alter table 表名 change 列名 新列名 类型;</span><br></pre></td></tr></table></figure>

<p>d, 删除表:</p>
<p><code>drop table if exists 表名;</code></p>
<p>e, 清空表:</p>
<p><code>truncate table 表名;</code></p>
<p>f, 数据导入导出:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 本地导入表中</span><br><span class="line">load data local inpath &#39;本地路径&#39; overwrite into table 表名 [partition (属性&#x3D;属性值, ...)];</span><br><span class="line"></span><br><span class="line"># 从 hdfs 导入表中</span><br><span class="line">load data inpath &#39;hdfs路径&#39; into table 表名 [partition (属性&#x3D;属性名, ...)];</span><br><span class="line"></span><br><span class="line"># 将 Hive 表中数据导出到本地</span><br><span class="line">insert overwrite local directory &#39;本地路径&#39; 查询语句;</span><br><span class="line"></span><br><span class="line"># 将 Hive 表中数据导出到 hdfs</span><br><span class="line">insert overwrite directory &#39;hdfs路径&#39; 查询语句;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>数据分析</category>
      </categories>
      <tags>
        <tag>HiveQL</tag>
      </tags>
  </entry>
  <entry>
    <title>HiveQL 表查询</title>
    <url>/data/hadoop2-8198ce8f5fce/</url>
    <content><![CDATA[<blockquote>
<p>文章主要内容和思路来源: <strong>开课吧</strong>学习笔记</p>
</blockquote>
<h2 id="三-HiveQL-单表查询"><a href="#三-HiveQL-单表查询" class="headerlink" title="三, HiveQL 单表查询"></a>三, HiveQL 单表查询</h2><h3 id="1-函数"><a href="#1-函数" class="headerlink" title="1, 函数"></a>1, 函数</h3><p>查询需要用到查询语法, 语句和函数. 查看 Hive 中的全部函数可用 <code>show functions;</code>语句</p>
<p>查看具体函数的用法可用 <code>desc function 函数名;</code>, 也可用更详细的 <code>desc function extended 函数名;</code>.</p>
<h3 id="2-语法和语句"><a href="#2-语法和语句" class="headerlink" title="2, 语法和语句"></a>2, 语法和语句</h3><p>查询语法和语句: </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT [DISTINCT] </span><br><span class="line">  FROM </span><br><span class="line">  [JOIN]</span><br><span class="line">    [ON]</span><br><span class="line">  [WHERE]</span><br><span class="line">  [GROUP BY]</span><br><span class="line">  [WITH]  </span><br><span class="line">  [HAVING]</span><br><span class="line">  [ORDER BY]</span><br><span class="line">  [LIMIT]</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>语句的执行顺序: </p>
<p>FROM → ON → JOIN → WHERE → GROUP BY → WITH → HAVING → SELECT → DISTINCT → ORDER BY → LIMIT  </p>
<h3 id="3-语句和常用函数用法"><a href="#3-语句和常用函数用法" class="headerlink" title="3, 语句和常用函数用法"></a>3, 语句和常用函数用法</h3><p>通过实例熟悉语句和常用函数用法:</p>
<p>有用户信息表 <code>user_info</code>, 通过语句<code>desc 表名</code>查看表结构信息如下:</p>
<table>
   <tr>
      <td>col_name</td>
      <td>data_type</td>
   </tr>
   <tr>
      <td>user_id             </td>
      <td>string              </td>
   </tr>
   <tr>
      <td>user_name           </td>
      <td>string              </td>
   </tr>
   <tr>
      <td>sex                 </td>
      <td>string              </td>
   </tr>
   <tr>
      <td>age                 </td>
      <td>int                 </td>
   </tr>
   <tr>
      <td>city                </td>
      <td>string              </td>
   </tr>
   <tr>
      <td>firstactivetime     </td>
      <td>string              </td>
   </tr>
   <tr>
      <td>level               </td>
      <td>int                 </td>
   </tr>
   <tr>
      <td>extra1              </td>
      <td>string              </td>
   </tr>
   <tr>
      <td>extra2              </td>
      <td>map<string,string> </td>
   </tr>
</table>

<p>其中扩展列 extra1 是 json 字符串型, extra2 是 map 类型, 格式如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;&quot;systemtype&quot;:&quot;ios&quot;,&quot;education&quot;:&quot;master&quot;,&quot;marriage_status&quot;:&quot;1&quot;,&quot;phonebrand&quot;:&quot;iphone X&quot;&#125;</span><br></pre></td></tr></table></figure>

<p>需要查看某个字段的值及格式, 直接筛选出来查看. </p>
<p><strong>3.01, 查询北京的 10 个女性用户:</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> user_name</span><br><span class="line"><span class="keyword">from</span> user_info</span><br><span class="line"><span class="keyword">where</span> city=<span class="string">&#x27;beijing&#x27;</span> <span class="keyword">and</span> <span class="string">&#x27;sex&#x27;</span>=<span class="string">&#x27;female&#x27;</span></span><br><span class="line"><span class="keyword">limit</span> <span class="number">10</span>;</span><br></pre></td></tr></table></figure>

<br>

<p>有用户交易表 <code>user_trade</code>:</p>
<table>
   <tr>
      <td>col_name</td>
      <td>data_type</td>
   </tr>
   <tr>
      <td>user_name           </td>
      <td>string              </td>
   </tr>
   <tr>
      <td>piece               </td>
      <td>int                 </td>
   </tr>
   <tr>
      <td>price               </td>
      <td>double              </td>
   </tr>
   <tr>
      <td>pay_amount          </td>
      <td>double              </td>
   </tr>
   <tr>
      <td>goods_category      </td>
      <td>string              </td>
   </tr>
   <tr>
      <td>pay_time            </td>
      <td>bigint              </td>
   </tr>
   <tr>
      <td>dt                  </td>
      <td>string              </td>
   </tr>
   <tr>
      <td># Partition Information</td>
      <td> </td>
   </tr>
   <tr>
      <td># col_name            </td>
      <td>data_type           </td>
   </tr>
   <tr>
      <td>dt                  </td>
      <td>string </td>
   </tr>
</table>

<p>此表是一个分区表, 有分区字段<code>dt</code>, 在查询的时候, where 条件中<strong>必须对分区字段进行限制</strong>.</p>
<p><strong>3.02, 查询某天(2018-12-31), 购买食物的用户, 及其购买量与金额:</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> user_name,</span><br><span class="line">    piece,</span><br><span class="line">    pay_amount</span><br><span class="line"><span class="keyword">from</span> user_trade</span><br><span class="line"><span class="keyword">where</span> dt=<span class="string">&#x27;2018-12-31&#x27;</span> <span class="keyword">and</span> goods_category=<span class="string">&#x27;food&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p><strong>3.03, 查询 2019 年第一季度, 商品的热度(购买人数)与价值度(购买金额):</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> goods_category,</span><br><span class="line">    <span class="keyword">count</span>(<span class="keyword">distinct</span> user_name) user_num,</span><br><span class="line">    <span class="keyword">sum</span>(pay_amount) tatal_amount</span><br><span class="line"><span class="keyword">from</span> user_trade</span><br><span class="line"><span class="keyword">where</span> dt <span class="keyword">between</span> <span class="string">&#x27;2019-01-01&#x27;</span> <span class="keyword">and</span> <span class="string">&#x27;2019-03-31&#x27;</span></span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> goods_category;</span><br></pre></td></tr></table></figure>

<p><code>count(distinct 字段)</code> 去重计数.</p>
<p><strong>3.04, 查询 2019 年 4 月, 支付超过 5w 的用户:</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> user_name,</span><br><span class="line">    <span class="keyword">sum</span>(pay_amount) total_amount</span><br><span class="line"><span class="keyword">from</span> user_trade</span><br><span class="line"><span class="keyword">where</span> dt <span class="keyword">between</span> <span class="string">&#x27;2019-04-01&#x27;</span> <span class="keyword">and</span> <span class="string">&#x27;2019-04-30&#x27;</span></span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> user_name</span><br><span class="line"><span class="keyword">having</span> <span class="keyword">sum</span>(pay_amount)&gt;<span class="number">50000</span>;</span><br></pre></td></tr></table></figure>
<p>语句<code>having sum(pay_amount)</code>虽然用上面的别名<code>total_amount</code>也可以查询, 但是执行顺序 having 在 select 之前, 最好不用别名.</p>
<p><strong>3.05, 查询 2019 年 4 月, 支付金额前五的用户:</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> user_name,</span><br><span class="line">    <span class="keyword">sum</span>(pay_amount) total_amount</span><br><span class="line"><span class="keyword">from</span> user_trade</span><br><span class="line"><span class="keyword">where</span> dt <span class="keyword">between</span> <span class="string">&#x27;2019-04-01&#x27;</span> <span class="keyword">and</span> <span class="string">&#x27;2019-04-30&#x27;</span></span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> user_name</span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> total_amount <span class="keyword">desc</span></span><br><span class="line"><span class="keyword">limit</span> <span class="number">5</span>;</span><br></pre></td></tr></table></figure>
<p><code>asc</code>是升序(默认), 可以不写, <code>desc</code>是降序, 对多个字段进行排序, 每个字段都要指定.</p>
<p><code>order by total_amount</code> 用 <code>sum(pay_amount)</code> 也可以查询, 但是最好用别名 <code>total_amount</code> , 执行顺序 order by 在 select 之后. </p>
<br>

<p><strong>日期时间处理函数</strong>:</p>
<p>时间戳转换为日期: </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from_unixtime(时间戳, &#39;yyyy-MM-dd hh:mm:ss&#39;)</span><br></pre></td></tr></table></figure>
<p>其中的日期格式<code>yyyy-MM-dd HH:mm:ss</code>(全省略时默认格式), <code>HH</code> 是 24 小时制, <code>hh</code> 是 12 小时制, 可以省略任意字符, 例如<code>y</code>就是转换为年, <code>h:m</code>就是几点几分, <code>yMd</code>就是年月日连写.</p>
<p>日期转换为时间戳:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">unix_timestamp(&#39;日期&#39;, &#39;yyyy-MM-dd hh:mm:ss&#39;)</span><br></pre></td></tr></table></figure>
<p>按照日期对应的格式转换为时间戳, 括号里无参数时, 获取当前时间的时间戳.</p>
<p>将日期时间转换为日期: <code>to_date()</code></p>
<p>计算两个日期之间的天数: <code>datediff(&#39;日期1&#39;, &#39;日期2&#39;)</code>, 得到<code>日期1 - 日期2</code>的天数.<br>日期增加: <code>date_add(&#39;日期&#39;, 天数)</code>, 日期减少: <code>date_sub(&#39;日期&#39;, 天数)</code>.<br>上述的日期都需要是<code>&#39;yyyy-MM-dd&#39;</code>格式, 天数是 int 类型.</p>
<p>获取当前日期: <code>current_date()</code>, 括号可以省略.</p>
<p><strong>3.06, 查询用户首次激活日期距今的日期间隔:</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> user_name,</span><br><span class="line">    <span class="keyword">datediff</span>(<span class="keyword">current_date</span>, <span class="keyword">to_date</span>(firstactivetime))</span><br><span class="line"><span class="keyword">from</span> user_info</span><br><span class="line"><span class="keyword">limit</span> <span class="number">10</span>;</span><br></pre></td></tr></table></figure>

<p><strong>3.07, 查询四个年龄段 20 以下, 20-30, 30-40, 40 以上 的用户数:</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">case</span> <span class="keyword">when</span> age&lt;<span class="number">20</span> <span class="keyword">then</span> <span class="string">&#x27;20以下&#x27;</span></span><br><span class="line">    <span class="keyword">when</span> age&gt;=<span class="number">20</span> <span class="keyword">and</span> age&lt;<span class="number">30</span> <span class="keyword">then</span> <span class="string">&#x27;20-30&#x27;</span></span><br><span class="line">    <span class="keyword">when</span> age&gt;=<span class="number">30</span> <span class="keyword">and</span> age&lt;<span class="number">40</span> <span class="keyword">then</span> <span class="string">&#x27;30-40&#x27;</span></span><br><span class="line">    <span class="keyword">else</span> <span class="string">&#x27;40以上&#x27;</span> <span class="keyword">end</span> <span class="keyword">as</span> age_type,</span><br><span class="line">    <span class="keyword">count</span>(<span class="keyword">distinct</span> user_id) user_num</span><br><span class="line"><span class="keyword">from</span> user_info</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> <span class="keyword">case</span> <span class="keyword">when</span> age&lt;<span class="number">20</span> <span class="keyword">then</span> <span class="string">&#x27;20以下&#x27;</span></span><br><span class="line">    <span class="keyword">when</span> age&gt;=<span class="number">20</span> <span class="keyword">and</span> age&lt;<span class="number">30</span> <span class="keyword">then</span> <span class="string">&#x27;20-30&#x27;</span></span><br><span class="line">    <span class="keyword">when</span> age&gt;=<span class="number">30</span> <span class="keyword">and</span> age&lt;<span class="number">40</span> <span class="keyword">then</span> <span class="string">&#x27;30-40&#x27;</span></span><br><span class="line">    <span class="keyword">else</span> <span class="string">&#x27;40以上&#x27;</span> <span class="keyword">end</span>;</span><br></pre></td></tr></table></figure>
<p>注意<code>case when ... then ... else ... end</code>的用法, 字段<code>user_id</code> 每个值是唯一值, 可以省略<code>distinct</code>.</p>
<p><strong>3.08, 查询用户等级高低(level&gt;5 为高)随性别分布情况:</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> sex, </span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">level</span>&gt;<span class="number">5</span>, <span class="string">&#x27;高&#x27;</span>, <span class="string">&#x27;低&#x27;</span>) level_type,</span><br><span class="line">    <span class="keyword">count</span>(user_id) user_num</span><br><span class="line"><span class="keyword">from</span> user_info</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> sex,</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">level</span>&gt;<span class="number">5</span>, <span class="string">&#x27;高&#x27;</span>, <span class="string">&#x27;低&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p><strong>字符串处理函数</strong>:</p>
<p><code>substr(字符串, 起始, 长度)</code>, 从<code>起始</code>(字符串的第一个字符是 1)截取<code>长度</code>个字符, <code>长度</code>省略则从<code>起始</code>截取到最后.</p>
<p><code>get_json_object(json字符串, &#39;$.key&#39;)</code>, 从 <code>json字符串</code>中取出 <code>key</code> 字符串对应的 <code>value</code> 字符串.</p>
<p><code>字段[&#39;key&#39;]</code>, 从 map 类型字段中, 取出 <code>key</code> 字符串对应的 <code>value</code> 字符串.</p>
<p><strong>3.09, 查询每个月拉新情况(就是每个月新的 用户id 的增加数):</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">substr</span>(firstactivetime, <span class="number">1</span>, <span class="number">7</span>) <span class="keyword">as</span> <span class="keyword">month</span>,</span><br><span class="line">    <span class="keyword">count</span>(<span class="keyword">distinct</span> user_id) user_num</span><br><span class="line"><span class="keyword">from</span> user_info</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> <span class="keyword">substr</span>(firstactivetime, <span class="number">1</span>, <span class="number">7</span>);</span><br></pre></td></tr></table></figure>

<p><strong>3.10, 查询不同手机品牌的用户数:</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 方法一</span></span><br><span class="line"><span class="keyword">select</span> get_json_object(extra1, <span class="string">&#x27;$.phonebrand&#x27;</span>) <span class="keyword">as</span> phone_brand,</span><br><span class="line">    <span class="keyword">count</span>(user_id) user_num</span><br><span class="line"><span class="keyword">from</span> user_info</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> get_json_object(extra1, <span class="string">&#x27;$.phonebrand&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 方法二</span></span><br><span class="line"><span class="keyword">select</span> extra2[<span class="string">&#x27;phonebrand&#x27;</span>] <span class="keyword">as</span> phone_brand,</span><br><span class="line">    <span class="keyword">count</span>(user_id) user_num</span><br><span class="line"><span class="keyword">from</span> user_info</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> extra2[<span class="string">&#x27;phonebrand&#x27;</span>];</span><br></pre></td></tr></table></figure>

<p><strong>3.11, 查询 ELLA 用户 2018 年平均每次支付金额和平均支付时间间隔:</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">avg</span>(pay_amount) <span class="keyword">as</span> avg_amount,</span><br><span class="line">    <span class="keyword">datediff</span>(<span class="keyword">max</span>(from_unixtime(pay_time, <span class="string">&#x27;yyyy-MM-dd&#x27;</span>)),</span><br><span class="line">        <span class="keyword">min</span>(from_unixtime(pay_time, <span class="string">&#x27;yyyy-MM-dd&#x27;</span>)))/<span class="keyword">count</span>(pay_time) <span class="keyword">as</span> avg_date</span><br><span class="line"><span class="keyword">from</span> user_trade</span><br><span class="line"><span class="keyword">where</span> <span class="keyword">year</span>(dt)=<span class="string">&#x27;2018&#x27;</span> <span class="keyword">and</span> user_name=<span class="string">&#x27;ELLA&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p>可以先取出最大最小, 在转换为时间格式. <code>year()</code>取出日期中的年, 对数字不敏感, <code>&#39;2018&#39;</code> 写成 <code>2018</code> 也可以. 月, 日, 小时, 分, 秒类似, 周是<code>weekofyear()</code>.</p>
<p><strong>3.12, 查询 2018 年购买商品品类在两个以上的用户数:</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">count</span>(a.user_name)</span><br><span class="line"><span class="keyword">from</span></span><br><span class="line">    (<span class="keyword">select</span> user_name,</span><br><span class="line">        <span class="keyword">count</span>(<span class="keyword">distinct</span> goods_category) <span class="keyword">as</span> category_num</span><br><span class="line">    <span class="keyword">from</span> user_trade</span><br><span class="line">    <span class="keyword">where</span> <span class="keyword">year</span>(dt)=<span class="string">&#x27;2018&#x27;</span></span><br><span class="line">    <span class="keyword">group</span> <span class="keyword">by</span> user_name</span><br><span class="line">    <span class="keyword">having</span> <span class="keyword">count</span>(<span class="keyword">distinct</span> goods_category)&gt;<span class="number">2</span>) a;</span><br></pre></td></tr></table></figure>

<p><strong>3.13, 查询在 2018 年激活, 年龄段在 20-30 和 30-40 的用户的婚姻状况分布:</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> a.age_type,</span><br><span class="line">    <span class="keyword">if</span>(a.marriage_status=<span class="number">1</span>, <span class="string">&#x27;已婚&#x27;</span>, <span class="string">&#x27;未婚&#x27;</span>),</span><br><span class="line">    <span class="keyword">count</span>(<span class="keyword">distinct</span> a.user_id)</span><br><span class="line"><span class="keyword">from</span></span><br><span class="line">    (<span class="keyword">select</span> <span class="keyword">case</span> <span class="keyword">when</span> age&lt;<span class="number">20</span> <span class="keyword">then</span> <span class="string">&#x27;&lt;20&#x27;</span></span><br><span class="line">        <span class="keyword">when</span> age&gt;=<span class="number">20</span> <span class="keyword">and</span> age&lt;<span class="number">30</span> <span class="keyword">then</span> <span class="string">&#x27;20-30&#x27;</span></span><br><span class="line">        <span class="keyword">when</span> age&gt;=<span class="number">30</span> <span class="keyword">and</span> age&lt;<span class="number">40</span> <span class="keyword">then</span> <span class="string">&#x27;30-40&#x27;</span></span><br><span class="line">        <span class="keyword">else</span> <span class="string">&#x27;&gt;40&#x27;</span> <span class="keyword">end</span> <span class="keyword">as</span> age_type,</span><br><span class="line">        get_json_object(extra1, <span class="string">&#x27;$.marriage_status&#x27;</span>) <span class="keyword">as</span> marriage_status,</span><br><span class="line">        user_id</span><br><span class="line">    <span class="keyword">from</span> user_info</span><br><span class="line">    <span class="keyword">where</span> <span class="keyword">to_date</span>(firstactivetime) <span class="keyword">between</span> <span class="string">&#x27;2018-01-01&#x27;</span> <span class="keyword">and</span> <span class="string">&#x27;2018-12-31&#x27;</span>) a</span><br><span class="line"><span class="keyword">where</span> a.age_type <span class="keyword">in</span> (<span class="string">&#x27;20-30&#x27;</span>, <span class="string">&#x27;30-40&#x27;</span>)</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> a.age_type,</span><br><span class="line">    <span class="keyword">if</span>(a.marriage_status=<span class="number">1</span>, <span class="string">&#x27;已婚&#x27;</span>, <span class="string">&#x27;未婚&#x27;</span>);</span><br></pre></td></tr></table></figure>
<p>婚姻状况在字段中是字符型的<code>&#39;0&#39;</code>和<code>&#39;1&#39;</code>, 可以直接写成<code>0</code>和<code>1</code>, 但是需前后要统一.</p>
<p><strong>3.14, 查询 2019-01-01 到 2019-04-30, 全天全时段不同商品的购买金额分布:</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">substr</span>(from_unixtime(pay_time), <span class="number">12</span>, <span class="number">2</span>) time_type,</span><br><span class="line">    goods_category,</span><br><span class="line">    <span class="keyword">sum</span>(pay_amount) pay_amount</span><br><span class="line"><span class="keyword">from</span> user_trade</span><br><span class="line"><span class="keyword">where</span> dt <span class="keyword">between</span> <span class="string">&#x27;2019-01-01&#x27;</span> <span class="keyword">and</span> <span class="string">&#x27;2019-04-30&#x27;</span></span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> <span class="keyword">substr</span>(from_unixtime(pay_time), <span class="number">12</span>, <span class="number">2</span>),</span><br><span class="line">    goods_category;</span><br></pre></td></tr></table></figure>
<p>可以用 <code>from_unixtime(pay_time, &#39;HH&#39;)</code>直接取时间, 更方便.</p>
<br>

<h2 id="四-HiveQL-多表连接查询"><a href="#四-HiveQL-多表连接查询" class="headerlink" title="四, HiveQL 多表连接查询"></a>四, HiveQL 多表连接查询</h2><h3 id="1-内连接"><a href="#1-内连接" class="headerlink" title="1, 内连接"></a>1, 内连接</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">表1 别名1 inner join 表2 别名2 on 连接条件</span><br></pre></td></tr></table></figure>

<p>表连接时起别名, 尤其必须对子查询的结果起别名.<br>on 后面的连接条件必须起到唯一键值的作用(去重或 group by等).<br>返回<code>表1</code>和<code>表2</code>同时满足连接条件的结果.<br>inner 可以省略.</p>
<p>有用户退款表 <code>user_refund</code> 如下:</p>
<table>
   <tr>
      <td>col_name</td>
      <td>data_type</td>
   </tr>
   <tr>
      <td>user_name           </td>
      <td>string              </td>
   </tr>
   <tr>
      <td>refund_piece        </td>
      <td>int                 </td>
   </tr>
   <tr>
      <td>refund_amount       </td>
      <td>double              </td>
   </tr>
   <tr>
      <td>refund_time         </td>
      <td>string              </td>
   </tr>
   <tr>
      <td>dt                  </td>
      <td>string              </td>
   </tr>
   <tr>
      <td># Partition Information</td>
      <td> </td>
   </tr>
   <tr>
      <td># col_name            </td>
      <td>data_type           </td>
   </tr>
   <tr>
      <td>dt                  </td>
      <td>string</td>
   </tr>
</table>


<p><strong>1.01, 查询 2019 年购买后又退款的用户:</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> a.user_name</span><br><span class="line"><span class="keyword">from</span></span><br><span class="line">    (<span class="keyword">select</span> <span class="keyword">distinct</span> user_name</span><br><span class="line">    <span class="keyword">from</span> user_trade</span><br><span class="line">    <span class="keyword">where</span> <span class="keyword">year</span>(dt)=<span class="number">2019</span>) a</span><br><span class="line"><span class="keyword">join</span></span><br><span class="line">    (<span class="keyword">select</span> <span class="keyword">distinct</span> user_name</span><br><span class="line">    <span class="keyword">from</span> user_refund</span><br><span class="line">    <span class="keyword">where</span> <span class="keyword">year</span>(dt)<span class="number">2019</span>) b</span><br><span class="line"><span class="keyword">on</span> a.user_name=b.user_name;</span><br></pre></td></tr></table></figure>

<p>注意点:<br>user_name 字段非唯一, 连接前需要去重(连接后去重效率低).<br>因为是内连接, a.user_name 与 b.user_name 相等.<br><code>select a.user_name</code> 必须指明来自 a 还是 b, 此处内连接 a 和 b 均可.</p>
<p><strong>1.02, 查询 2017 和 2018 都购买的用户:</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> a.user_name</span><br><span class="line"><span class="keyword">from</span></span><br><span class="line">    (<span class="keyword">select</span> <span class="keyword">distinct</span> user_name</span><br><span class="line">    <span class="keyword">from</span> user_trade</span><br><span class="line">    <span class="keyword">where</span> <span class="keyword">year</span>(dt)=<span class="number">2017</span>) a</span><br><span class="line"><span class="keyword">join</span> </span><br><span class="line">    (<span class="keyword">select</span> <span class="keyword">distinct</span> user_name</span><br><span class="line">    <span class="keyword">from</span> user_trade</span><br><span class="line">    <span class="keyword">where</span> <span class="keyword">year</span>(dt)<span class="number">2018</span>) b</span><br><span class="line"><span class="keyword">on</span> a.user_name=b.user_name;</span><br></pre></td></tr></table></figure>

<p>有 2017, 2018 和 2019 三年的交易表, <code>trade_2017</code>, <code>trade_2018</code> 和 <code>trade_2019</code>:</p>
<table>
   <tr>
      <td>col_name</td>
      <td>data_type</td>
   </tr>
   <tr>
      <td>user_name           </td>
      <td>string              </td>
   </tr>
   <tr>
      <td>amount              </td>
      <td>double              </td>
   </tr>
   <tr>
      <td>trade_time          </td>
      <td>string</td>
   </tr>
</table>

<p><strong>1.03, 查询三年都有交易的用户</strong>:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 方法一</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">distinct</span> a.user_name</span><br><span class="line"><span class="keyword">from</span> trade_2017 a</span><br><span class="line"><span class="keyword">join</span> trade_2018 b <span class="keyword">on</span> a.user_name=b.user_name</span><br><span class="line"><span class="keyword">join</span> trade_2019 c <span class="keyword">on</span> b.user_name=c.user_name;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 方法二</span></span><br><span class="line"><span class="keyword">select</span> a.user_name</span><br><span class="line"><span class="keyword">from</span></span><br><span class="line">    (<span class="keyword">select</span> <span class="keyword">distinct</span> user_name</span><br><span class="line">    <span class="keyword">from</span> trade_2017) a</span><br><span class="line">    <span class="keyword">join</span></span><br><span class="line">    (<span class="keyword">select</span> <span class="keyword">distinct</span> user_name</span><br><span class="line">    <span class="keyword">from</span> trade_2018) b <span class="keyword">on</span> a.user_name=b.user_name</span><br><span class="line">    <span class="keyword">join</span></span><br><span class="line">    (<span class="keyword">select</span> <span class="keyword">distinct</span> user_name</span><br><span class="line">    <span class="keyword">from</span> trade_2019) c <span class="keyword">on</span> b.user_name=c.user_name;</span><br></pre></td></tr></table></figure>

<p>注意点:<br>方法二更优, 数据量很大时用方法二.<br>执行时是按顺序一个 <code>join</code> 一个 <code>join</code> 的执行完, 因此每个都要连接条件.</p>
<h3 id="2-左连接"><a href="#2-左连接" class="headerlink" title="2, 左连接"></a>2, 左连接</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">表1 别名1 left join 表2 别名2 on 链接条件</span><br></pre></td></tr></table></figure>
<p>以左边的<code>表1</code>为全集, 返回连接条件能够匹配上的<code>表2</code>的匹配结果, 没匹配上的则返回 null.</p>
<p>右连接 <code>right join</code> 相反, 可以通过左连接改写出一样的结果.</p>
<p><strong>2.01, 查询在 2019 年购买且无退款的用户:</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> a.user_name</span><br><span class="line"><span class="keyword">from</span></span><br><span class="line">    (<span class="keyword">select</span> <span class="keyword">distinct</span> user_name</span><br><span class="line">    <span class="keyword">from</span> user_trade</span><br><span class="line">    <span class="keyword">where</span> <span class="keyword">year</span>(dt)=<span class="number">2019</span>) a</span><br><span class="line">    <span class="keyword">left</span> <span class="keyword">join</span></span><br><span class="line">    (<span class="keyword">select</span> <span class="keyword">distinct</span> user_name</span><br><span class="line">    <span class="keyword">from</span> user_refund</span><br><span class="line">    <span class="keyword">where</span> <span class="keyword">year</span>(dt)=<span class="number">2019</span>) b</span><br><span class="line">    <span class="keyword">on</span> a.user_name=b.user_name</span><br><span class="line"><span class="keyword">where</span> b.user_name <span class="keyword">is</span> <span class="literal">null</span>;</span><br></pre></td></tr></table></figure>

<p>因为是左连接, b.user_name 是 null 的用户, 就是购买无退款的用户, 而不是 null 的, 就是有购买也有退款的用户.</p>
<p><strong>2.02, 查询 2019 年购买用户的学历分布:</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> b.education,</span><br><span class="line">    <span class="keyword">count</span>(a.user_name)</span><br><span class="line"><span class="keyword">from</span></span><br><span class="line">    (<span class="keyword">select</span> <span class="keyword">distinct</span> user_name</span><br><span class="line">    <span class="keyword">from</span> user_trade</span><br><span class="line">    <span class="keyword">where</span> <span class="keyword">year</span>(dt)=<span class="number">2019</span>) a</span><br><span class="line">    <span class="keyword">left</span> <span class="keyword">join</span></span><br><span class="line">    (<span class="keyword">select</span> user_name,</span><br><span class="line">        get_json_object(extra1, <span class="string">&#x27;$.education&#x27;</span>) education</span><br><span class="line">    <span class="keyword">from</span> user_info) b</span><br><span class="line">    <span class="keyword">on</span> a.user_name=b.user_name</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> b.education;</span><br></pre></td></tr></table></figure>

<p><strong>2.03, 查询 2017 和 2018 购买, 2019 没有购买的用户:</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> a.user_name</span><br><span class="line"><span class="keyword">from</span></span><br><span class="line">    (<span class="keyword">select</span> <span class="keyword">distinct</span> user_name</span><br><span class="line">    <span class="keyword">from</span> trade_2017) a</span><br><span class="line">    <span class="keyword">join</span></span><br><span class="line">    (<span class="keyword">select</span> <span class="keyword">distinct</span> user_name</span><br><span class="line">    <span class="keyword">from</span> trade_2018) b </span><br><span class="line">    <span class="keyword">on</span> a.user_name=b.user_name</span><br><span class="line">    <span class="keyword">left</span> <span class="keyword">join</span></span><br><span class="line">    (<span class="keyword">select</span> <span class="keyword">distinct</span> user_name</span><br><span class="line">    <span class="keyword">from</span> trade_2019) c</span><br><span class="line">    <span class="keyword">on</span> b.user_name=c.user_name</span><br><span class="line"><span class="keyword">where</span> c.user_name <span class="keyword">is</span> <span class="literal">null</span>;</span><br></pre></td></tr></table></figure>

<p>方法不是唯一的, 有多种实现方法, 但是注意先后顺序和去重优化等.</p>
<h3 id="3-全连接"><a href="#3-全连接" class="headerlink" title="3, 全连接"></a>3, 全连接</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">表1 别名1 full join 表2 别名2 on 连接条件</span><br></pre></td></tr></table></figure>
<p><code>表1</code>和<code>表2</code>都为全集进行连接, 匹配上的返回匹配结果, 没匹配上的都为 null.</p>
<p>可用 <code>coalesce(字段1, 字段2, ...)</code> 函数, 将连接后每条记录的非 null 的值取出来, <code>表1</code>和<code>表2</code>相同字段都有值时, 只取其一.</p>
<h3 id="4-联合查询-并集"><a href="#4-联合查询-并集" class="headerlink" title="4, 联合查询(并集)"></a>4, 联合查询(并集)</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">查询1 union all(或union) 查询2</span><br></pre></td></tr></table></figure>
<p><code>查询1</code>和<code>查询2</code>的查询字段<strong>个数必须相同</strong>.<br>查询顺序需要一致(不一致也可, 但是失去了意义).<br>查询后的结果以<code>查询1</code>的字段名为字段名.<br>联合不需要条件.</p>
<p><code>union all</code> 和 <code>union</code> 的区别:</p>
<p><code>union</code><strong>对结果</strong>去重且排序, 效率低.<br><code>union all</code>不去重不排序, 简单地进行并集, 效率高.</p>
<p><strong>4.01, 查询 2017-2019 有交易的所有用户数:</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 方法一(最快)</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">count</span>(<span class="keyword">distinct</span> a.user_name),</span><br><span class="line">    <span class="keyword">count</span>(a.user_name)</span><br><span class="line"><span class="keyword">from</span></span><br><span class="line">    (<span class="keyword">select</span> user_name</span><br><span class="line">    <span class="keyword">from</span> trade_2017</span><br><span class="line">    <span class="keyword">union</span> <span class="keyword">all</span></span><br><span class="line">    <span class="keyword">select</span> user_name</span><br><span class="line">    <span class="keyword">from</span> trade_2018</span><br><span class="line">    <span class="keyword">union</span> <span class="keyword">all</span></span><br><span class="line">    <span class="keyword">select</span> user_name</span><br><span class="line">    <span class="keyword">from</span> trade_2019) a;</span><br><span class="line">结果:</span><br><span class="line">_c0	_c1</span><br><span class="line">199	796</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 方法二(其次)</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">count</span>(<span class="keyword">distinct</span> a.user_name),</span><br><span class="line">    <span class="keyword">count</span>(a.user_name)</span><br><span class="line"><span class="keyword">from</span></span><br><span class="line">    (<span class="keyword">select</span> user_name</span><br><span class="line">    <span class="keyword">from</span> trade_2017</span><br><span class="line">    <span class="keyword">union</span> </span><br><span class="line">    <span class="keyword">select</span> user_name</span><br><span class="line">    <span class="keyword">from</span> trade_2018</span><br><span class="line">    <span class="keyword">union</span> </span><br><span class="line">    <span class="keyword">select</span> user_name</span><br><span class="line">    <span class="keyword">from</span> trade_2019) a;</span><br><span class="line">结果:</span><br><span class="line">_c0	_c1</span><br><span class="line">199	199</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 方法三(最慢)</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">count</span>(<span class="keyword">distinct</span> a.user_name),</span><br><span class="line">    <span class="keyword">count</span>(a.user_name)</span><br><span class="line"><span class="keyword">from</span></span><br><span class="line">    (<span class="keyword">select</span> <span class="keyword">distinct</span> user_name</span><br><span class="line">    <span class="keyword">from</span> trade_2017</span><br><span class="line">    <span class="keyword">union</span> <span class="keyword">all</span></span><br><span class="line">    <span class="keyword">select</span> <span class="keyword">distinct</span> user_name</span><br><span class="line">    <span class="keyword">from</span> trade_2018</span><br><span class="line">    <span class="keyword">union</span> <span class="keyword">all</span></span><br><span class="line">    <span class="keyword">select</span> <span class="keyword">distinct</span> user_name</span><br><span class="line">    <span class="keyword">from</span> trade_2019) a;</span><br><span class="line">结果:</span><br><span class="line">_c0	_c1</span><br><span class="line">199	396</span><br></pre></td></tr></table></figure>

<p><strong>4.02, 查询2019 年用户支付和退款金额汇总:</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 方法一</span></span><br><span class="line"><span class="keyword">select</span> a.user_name,</span><br><span class="line">    <span class="keyword">sum</span>(a.pay_amount),</span><br><span class="line">    <span class="keyword">sum</span>(a.refund_amount)</span><br><span class="line"><span class="keyword">from</span></span><br><span class="line">    (<span class="keyword">select</span> user_name,</span><br><span class="line">        <span class="keyword">sum</span>(pay_amount) pay_amount,</span><br><span class="line">        <span class="number">0</span> refund_amount</span><br><span class="line">    <span class="keyword">from</span> user_trade</span><br><span class="line">    <span class="keyword">where</span> <span class="keyword">year</span>(dt)=<span class="number">2019</span></span><br><span class="line">    <span class="keyword">group</span> <span class="keyword">by</span> user_name</span><br><span class="line">    <span class="keyword">union</span> <span class="keyword">all</span></span><br><span class="line">    <span class="keyword">select</span> user_name,</span><br><span class="line">        <span class="number">0</span>,</span><br><span class="line">        <span class="keyword">sum</span>(refund_amount)</span><br><span class="line">    <span class="keyword">from</span> user_refund</span><br><span class="line">    <span class="keyword">where</span> <span class="keyword">year</span>(dt)=<span class="number">2019</span></span><br><span class="line">    <span class="keyword">group</span> <span class="keyword">by</span> user_name</span><br><span class="line">    ) a</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> a.user_name;</span><br><span class="line"><span class="comment">-- 方法二(full join)</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">coalesce</span>(a.user_name, b.user_name),</span><br><span class="line">    <span class="keyword">if</span>(a.pay_amount <span class="keyword">is</span> <span class="literal">null</span>, <span class="number">0</span>, a.pay_amount),</span><br><span class="line">    <span class="keyword">if</span>(b.refund_amount <span class="keyword">is</span> <span class="literal">null</span>, <span class="number">0</span>, b.refund_amount)</span><br><span class="line"><span class="keyword">from</span></span><br><span class="line">    (<span class="keyword">select</span> user_name,</span><br><span class="line">        <span class="keyword">sum</span>(pay_amount) pay_amount</span><br><span class="line">    <span class="keyword">from</span> user_trade</span><br><span class="line">    <span class="keyword">where</span> <span class="keyword">year</span>(dt)=<span class="number">2019</span></span><br><span class="line">    <span class="keyword">group</span> <span class="keyword">by</span> user_name) a</span><br><span class="line">    <span class="keyword">full</span> <span class="keyword">join</span></span><br><span class="line">    (<span class="keyword">select</span> user_name,</span><br><span class="line">        <span class="keyword">sum</span>(refund_amount) refund_amount</span><br><span class="line">    <span class="keyword">from</span> user_refund</span><br><span class="line">    <span class="keyword">where</span> <span class="keyword">year</span>(dt)=<span class="number">2019</span></span><br><span class="line">    <span class="keyword">group</span> <span class="keyword">by</span> user_name) b</span><br><span class="line">    <span class="keyword">on</span> a.user_name=b.user_name;</span><br></pre></td></tr></table></figure>

<p>注意点:<br>方法一中, union all 的前后两个查询, 为了保证字段个数相同和顺序一致用 0 占位, 并且前一个查询需要给 0 起别名作为字段名, 后一个查询可以省略. 交易表和退款表并集的结果任然有重复的 user_name, 还需要再进行聚合运算.<br>方法二中, 全连接后的结果不再需要聚合运算, 如果 a 和 b 都有 user_name 值, 只取其一与付款和退款对应, 只有 a 有 user_name 值, 则只有付款, 退款用 0 填充, 只有 b 有 user_name 值, 则只有退款, 付款用 0 填充.</p>
<p><strong>4.03, 查询 2019 年支付用户的支付金额和退款金额:</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> a.user_name,</span><br><span class="line">    a.pay_amount,</span><br><span class="line">    b.refund_amount</span><br><span class="line"><span class="keyword">from</span></span><br><span class="line">    (<span class="keyword">select</span> user_name,</span><br><span class="line">        <span class="keyword">sum</span>(pay_amount) pay_amount</span><br><span class="line">    <span class="keyword">from</span> user_trade</span><br><span class="line">    <span class="keyword">where</span> <span class="keyword">year</span>(dt)=<span class="number">2019</span></span><br><span class="line">    <span class="keyword">group</span> <span class="keyword">by</span> user_name) a</span><br><span class="line">    <span class="keyword">left</span> <span class="keyword">join</span></span><br><span class="line">    (<span class="keyword">select</span> user_name,</span><br><span class="line">        <span class="keyword">sum</span>(refund_amount) refund_amount</span><br><span class="line">    <span class="keyword">from</span> user_refund</span><br><span class="line">    <span class="keyword">where</span> <span class="keyword">year</span>(dt)=<span class="number">2019</span></span><br><span class="line">    <span class="keyword">group</span> <span class="keyword">by</span> user_name) b</span><br><span class="line">    <span class="keyword">on</span> a.user_name=b.user_name;</span><br></pre></td></tr></table></figure>

<p><strong>4.04, 查询首次激活在 2017 年, 但一直没有支付的用户的年龄段分布(&lt;20, 20-30, 30-40, &gt;40):</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> a.age_level,</span><br><span class="line">    <span class="keyword">count</span>(a.user_name)</span><br><span class="line"><span class="keyword">from</span></span><br><span class="line">    (<span class="keyword">select</span> user_name,</span><br><span class="line">        <span class="keyword">case</span> <span class="keyword">when</span> age&lt;<span class="number">20</span> <span class="keyword">then</span> <span class="string">&#x27;&lt;20&#x27;</span></span><br><span class="line">        <span class="keyword">when</span> age&gt;=<span class="number">20</span> <span class="keyword">and</span> age&lt;<span class="number">30</span> <span class="keyword">then</span> <span class="string">&#x27;20-30&#x27;</span></span><br><span class="line">        <span class="keyword">when</span> age&gt;=<span class="number">30</span> <span class="keyword">and</span> age&lt;<span class="number">40</span> <span class="keyword">then</span> <span class="string">&#x27;30-40&#x27;</span></span><br><span class="line">        <span class="keyword">else</span> <span class="string">&#x27;&gt;40&#x27;</span> <span class="keyword">end</span> age_level</span><br><span class="line">    <span class="keyword">from</span> user_info</span><br><span class="line">    <span class="keyword">where</span> <span class="keyword">year</span>(firstactivetime)=<span class="number">2017</span>) a</span><br><span class="line">    <span class="keyword">left</span> <span class="keyword">join</span></span><br><span class="line">    (<span class="keyword">select</span> <span class="keyword">distinct</span> user_name</span><br><span class="line">    <span class="keyword">from</span> user_trade</span><br><span class="line">    <span class="keyword">where</span> dt&gt;<span class="string">&#x27;0&#x27;</span>) b</span><br><span class="line">    <span class="keyword">on</span> a.user_name=b.user_name</span><br><span class="line"><span class="keyword">where</span> b.user_name <span class="keyword">is</span> <span class="literal">null</span></span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> a.age_level;</span><br></pre></td></tr></table></figure>

<p>注意点:<br>交易表 <code>user_trade</code> 是分区表, 必须对分区字段 dt 进行限制 <code>where dt&gt;&#39;0&#39;</code>, 也可以写成 <code>where dt is not null</code>, 只有限制, 无筛选作用.</p>
<p><strong>4.05, 查询 2018, 2019 年交易用户在全天中的激活时间段分布:</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">hour</span>(firstactivetime),</span><br><span class="line">    <span class="keyword">count</span>(a.user_name)</span><br><span class="line"><span class="keyword">from</span></span><br><span class="line">    (<span class="keyword">select</span> user_name</span><br><span class="line">    <span class="keyword">from</span> trade_2018</span><br><span class="line">    <span class="keyword">union</span></span><br><span class="line">    <span class="keyword">select</span> user_name</span><br><span class="line">    <span class="keyword">from</span> trade_2019) a</span><br><span class="line">    <span class="keyword">left</span> <span class="keyword">join</span> user_info b</span><br><span class="line">    <span class="keyword">on</span> a.user_name=b.user_name</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> <span class="keyword">hour</span>(firstactivetime);</span><br></pre></td></tr></table></figure>

<p><strong>4.06, 查询 2017-2019 年有交易没退款的用户的手机品牌分布:</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 方法一</span></span><br><span class="line"><span class="keyword">select</span> d.phonebrand,</span><br><span class="line">    <span class="keyword">count</span>(c.user_name)</span><br><span class="line"><span class="keyword">from</span></span><br><span class="line">    (<span class="keyword">select</span> a.user_name</span><br><span class="line">    <span class="keyword">from</span></span><br><span class="line">        (<span class="keyword">select</span> <span class="keyword">distinct</span> user_name</span><br><span class="line">        <span class="keyword">from</span> user_trade</span><br><span class="line">        <span class="keyword">where</span> <span class="keyword">year</span>(dt) <span class="keyword">between</span> <span class="string">&#x27;2017&#x27;</span> <span class="keyword">and</span> <span class="string">&#x27;2019&#x27;</span>) a</span><br><span class="line">    <span class="keyword">left</span> <span class="keyword">join</span></span><br><span class="line">        (<span class="keyword">select</span> <span class="keyword">distinct</span> user_name</span><br><span class="line">        <span class="keyword">from</span> user_refund</span><br><span class="line">        <span class="keyword">where</span> <span class="keyword">year</span>(dt) <span class="keyword">between</span> <span class="string">&#x27;2017&#x27;</span> <span class="keyword">and</span> <span class="string">&#x27;2019&#x27;</span>) b</span><br><span class="line">    <span class="keyword">on</span> a.user_name=b.user_name</span><br><span class="line">    <span class="keyword">where</span> b.user_name <span class="keyword">is</span> <span class="literal">null</span></span><br><span class="line">    ) c</span><br><span class="line"><span class="keyword">left</span> <span class="keyword">join</span></span><br><span class="line">    (<span class="keyword">select</span> user_name,</span><br><span class="line">        extra2[<span class="string">&#x27;phonebrand&#x27;</span>] phonebrand</span><br><span class="line">    <span class="keyword">from</span> user_info) d</span><br><span class="line">    <span class="keyword">on</span> c.user_name=d.user_name</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> d.phonebrand;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 方法二</span></span><br><span class="line"><span class="keyword">SELECT</span> d.extra2[<span class="string">&#x27;phonebrand&#x27;</span>],</span><br><span class="line">    <span class="keyword">count</span>(c.user_name)</span><br><span class="line"><span class="keyword">FROM</span> </span><br><span class="line">    (<span class="keyword">SELECT</span> a.user_name</span><br><span class="line">    <span class="keyword">FROM</span> </span><br><span class="line">        (<span class="keyword">SELECT</span> user_name</span><br><span class="line">        <span class="keyword">FROM</span> trade_2017</span><br><span class="line">        <span class="keyword">UNION</span></span><br><span class="line">        <span class="keyword">SELECT</span> user_name</span><br><span class="line">        <span class="keyword">FROM</span> trade_2018</span><br><span class="line">        <span class="keyword">UNION</span></span><br><span class="line">        <span class="keyword">SELECT</span> user_name</span><br><span class="line">        <span class="keyword">FROM</span> trade_2019</span><br><span class="line">        ) a</span><br><span class="line">    <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> </span><br><span class="line">        (<span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> user_name</span><br><span class="line">        <span class="keyword">FROM</span> user_refund</span><br><span class="line">        <span class="keyword">WHERE</span> dt&gt;<span class="string">&#x27;0&#x27;</span></span><br><span class="line">        ) b</span><br><span class="line">    <span class="keyword">ON</span> a.user_name=b.user_name</span><br><span class="line">    <span class="keyword">WHERE</span> b.user_name <span class="keyword">is</span> <span class="literal">null</span></span><br><span class="line">    ) c</span><br><span class="line">    <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> user_info d</span><br><span class="line">    <span class="keyword">ON</span> c.user_name=d.user_name</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span>  d.extra2[<span class="string">&#x27;phonebrand&#x27;</span>];</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>数据分析</category>
      </categories>
      <tags>
        <tag>HiveQL</tag>
      </tags>
  </entry>
  <entry>
    <title>HiveQL 窗口函数和常用优化技巧</title>
    <url>/data/hadoop3-743e8abb1c1c/</url>
    <content><![CDATA[<blockquote>
<p>文章主要内容和思路来源: <strong>开课吧</strong>学习笔记</p>
</blockquote>
<h2 id="五-HiveQL-窗口函数"><a href="#五-HiveQL-窗口函数" class="headerlink" title="五, HiveQL 窗口函数"></a>五, HiveQL 窗口函数</h2><p>窗口函数与聚合函数类似, 但是它每一行都生成一个结果, 窗口函数相当于从原数据中提取条件筛选出来的数据进行聚合运算, 有一行就提取计算一次.</p>
<p><strong>窗口函数的格式:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">函数() over (partition by 分组字段 order by 排序字段 rows between 起始行 and 结束行)</span><br></pre></td></tr></table></figure>
<p><code>order by</code>可以指定升序(asc 默认)或降序(desc). <code>起始行</code> 和 <code>结束行</code> 决定窗口函数计算范围.</p>
<h3 id="1-累计计算窗口函数"><a href="#1-累计计算窗口函数" class="headerlink" title="1, 累计计算窗口函数"></a>1, 累计计算窗口函数</h3><p>累计计算窗口函数中的<code>函数()</code>有: sum(), avg(), max() 和 min() 等. 函数中要指明计算的字段.</p>
<p><code>起始行</code> 或 <code>结束行</code> 的写法:<br><code>unbounded preceding</code>前面所有行;<br><code>unbounded following</code>后面所有行;<br><code>n preceding</code>前面 n 行;<br><code>n following</code>后面 n 行;<br><code>current row</code>当前行.</p>
<p><strong>1.01, 对 2018 年支付总额按月度累计分析:</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> a.month,</span><br><span class="line">    a.pay_amount,</span><br><span class="line">    <span class="keyword">sum</span>(a.pay_amount) <span class="keyword">over</span>(<span class="keyword">order</span> <span class="keyword">by</span> a.month)</span><br><span class="line"><span class="keyword">from</span></span><br><span class="line">    (<span class="keyword">select</span> <span class="keyword">month</span>(dt) <span class="keyword">month</span>,</span><br><span class="line">        <span class="keyword">sum</span>(pay_amount) pay_amount</span><br><span class="line">    <span class="keyword">from</span> user_trade</span><br><span class="line">    <span class="keyword">where</span> <span class="keyword">year</span>(dt)=<span class="number">2018</span></span><br><span class="line">    <span class="keyword">group</span> <span class="keyword">by</span> <span class="keyword">month</span>(dt)) a;</span><br></pre></td></tr></table></figure>
<table>
   <tr>
      <td>a.month</td>
      <td>a.pay_amount</td>
      <td>sum_window_0</td>
   </tr>
   <tr>
      <td>1</td>
      <td>317697.20 </td>
      <td>317697.20 </td>
   </tr>
   <tr>
      <td>2</td>
      <td>2214537.10 </td>
      <td>2532234.30 </td>
   </tr>
   <tr>
      <td>3</td>
      <td>3108435.90 </td>
      <td>5640670.20 </td>
   </tr>
   <tr>
      <td>4</td>
      <td>2717482.60 </td>
      <td>8358152.80 </td>
   </tr>
</table>

<p>可见默认是按<code>前面所有行</code>到<code>当前行</code>进行累计计算的, 窗口函数的每一行, 提取一次<code>前面所有行</code>到<code>当前行</code>进行一次计算.</p>
<p><strong>1.02, 对 2017 和 2018 年支付总额按月度累计分析, 按年汇总:</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> a.year,</span><br><span class="line">    a.month,</span><br><span class="line">    a.pay_amount,</span><br><span class="line">    <span class="keyword">sum</span>(a.pay_amount) <span class="keyword">over</span>(<span class="keyword">partition</span> <span class="keyword">by</span> a.year </span><br><span class="line">        <span class="keyword">order</span> <span class="keyword">by</span> a.month)</span><br><span class="line"><span class="keyword">from</span></span><br><span class="line">    (<span class="keyword">select</span> <span class="keyword">year</span>(dt) <span class="keyword">year</span>,</span><br><span class="line">        <span class="keyword">month</span>(dt) <span class="keyword">month</span>,</span><br><span class="line">        <span class="keyword">sum</span>(pay_amount) pay_amount</span><br><span class="line">    <span class="keyword">from</span> user_trade</span><br><span class="line">    <span class="keyword">where</span> <span class="keyword">year</span>(dt) <span class="keyword">in</span> (<span class="number">2017</span>, <span class="number">2018</span>)</span><br><span class="line">    <span class="keyword">group</span> <span class="keyword">by</span> <span class="keyword">year</span>(dt),</span><br><span class="line">        <span class="keyword">month</span>(dt)) a;</span><br></pre></td></tr></table></figure>

<table>
   <tr>
      <td>a.year</td>
      <td>a.month</td>
      <td>a.pay_amount</td>
      <td>sum_window_0</td>
   </tr>
   <tr>
      <td>2017</td>
      <td>1</td>
      <td>241755.70 </td>
      <td>241755.70 </td>
   </tr>
   <tr>
      <td>2017</td>
      <td>2</td>
      <td>2582410.60 </td>
      <td>2824166.30 </td>
   </tr>
   <tr>
      <td>2017</td>
      <td>3</td>
      <td>1977644.70 </td>
      <td>4801811.00 </td>
   </tr>
   <tr>
      <td>2017</td>
      <td>4</td>
      <td>1162322.80 </td>
      <td>5964133.80 </td>
   </tr>
   <tr>
      <td>2017</td>
      <td>5</td>
      <td>3038255.20 </td>
      <td>9002389.00 </td>
   </tr>
   <tr>
      <td>2017</td>
      <td>6</td>
      <td>2773154.40 </td>
      <td>11775543.40 </td>
   </tr>
   <tr>
      <td>2017</td>
      <td>7</td>
      <td>1677527.30 </td>
      <td>13453070.70 </td>
   </tr>
   <tr>
      <td>2017</td>
      <td>8</td>
      <td>2135214.40 </td>
      <td>15588285.10 </td>
   </tr>
   <tr>
      <td>2017</td>
      <td>9</td>
      <td>1355307.30 </td>
      <td>16943592.40 </td>
   </tr>
   <tr>
      <td>2017</td>
      <td>10</td>
      <td>1380672.70 </td>
      <td>18324265.10 </td>
   </tr>
   <tr>
      <td>2017</td>
      <td>11</td>
      <td>2428753.90 </td>
      <td>20753019.00 </td>
   </tr>
   <tr>
      <td>2017</td>
      <td>12</td>
      <td>3580954.60 </td>
      <td>24333973.60 </td>
   </tr>
   <tr>
      <td>2018</td>
      <td>1</td>
      <td>317697.20 </td>
      <td>317697.20 </td>
   </tr>
   <tr>
      <td>2018</td>
      <td>2</td>
      <td>2214537.10 </td>
      <td>2532234.30 </td>
   </tr>
   <tr>
      <td>2018</td>
      <td>3</td>
      <td>3108435.90 </td>
      <td>5640670.20 </td>
   </tr>
   <tr>
      <td>2018</td>
      <td>4</td>
      <td>2717482.60 </td>
      <td>8358152.80 </td>
   </tr>
</table>

<p>可见窗口函数有了分组字段之后, 累计计算完一组, 又开始累计下一组, 需要注意不能分错组.</p>
<p><strong>1.03, 对 2018 年每个月的近三个月求平均支付金额:</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> a.month,</span><br><span class="line">    a.pay_amount,</span><br><span class="line">    <span class="keyword">avg</span>(a.pay_amount) <span class="keyword">over</span>(<span class="keyword">order</span> <span class="keyword">by</span> a.month </span><br><span class="line">        <span class="keyword">rows</span> <span class="keyword">between</span> <span class="number">2</span> <span class="keyword">preceding</span> <span class="keyword">and</span> <span class="keyword">current</span> <span class="keyword">row</span>)</span><br><span class="line"><span class="keyword">from</span></span><br><span class="line">    (<span class="keyword">select</span> <span class="keyword">month</span>(dt) <span class="keyword">month</span>,</span><br><span class="line">        <span class="keyword">sum</span>(pay_amount) pay_amount</span><br><span class="line">    <span class="keyword">from</span> user_trade</span><br><span class="line">    <span class="keyword">where</span> <span class="keyword">year</span>(dt)=<span class="number">2018</span></span><br><span class="line">    <span class="keyword">group</span> <span class="keyword">by</span> <span class="keyword">month</span>(dt)) a;</span><br></pre></td></tr></table></figure>

<table>
   <tr>
      <td>a.month</td>
      <td>a.pay_amount</td>
      <td>avg_window_0</td>
   </tr>
   <tr>
      <td>1</td>
      <td>317697.20 </td>
      <td>317697.20 </td>
   </tr>
   <tr>
      <td>2</td>
      <td>2214537.10 </td>
      <td>1266117.15 </td>
   </tr>
   <tr>
      <td>3</td>
      <td>3108435.90 </td>
      <td>1880223.40 </td>
   </tr>
   <tr>
      <td>4</td>
      <td>2717482.60 </td>
      <td>2680151.87 </td>
   </tr>
   <tr>
      <td>5</td>
      <td>2723670.10 </td>
      <td>2849862.87 </td>
   </tr>
   <tr>
      <td>6</td>
      <td>3808041.30 </td>
      <td>3083064.67 </td>
   </tr>
   <tr>
      <td>7</td>
      <td>5426222.30 </td>
      <td>3985977.90 </td>
   </tr>
   <tr>
      <td>8</td>
      <td>2749747.00 </td>
      <td>3994670.20 </td>
   </tr>
   <tr>
      <td>9</td>
      <td>891197.00 </td>
      <td>3022388.77 </td>
   </tr>
   <tr>
      <td>10</td>
      <td>1510374.30 </td>
      <td>1717106.10 </td>
   </tr>
   <tr>
      <td>11</td>
      <td>2307257.40 </td>
      <td>1569609.57 </td>
   </tr>
   <tr>
      <td>12</td>
      <td>1759487.20 </td>
      <td>1859039.63 </td>
   </tr>
</table>

<p>近三个月, 就是计算前两个月和当月, 前面没有三个月的, 有几个月就计算几个月的平均值, 逐行移动一直计算完毕.</p>
<h3 id="2-分区排序窗口函数"><a href="#2-分区排序窗口函数" class="headerlink" title="2, 分区排序窗口函数"></a>2, 分区排序窗口函数</h3><p>分区排序窗口函数中的<code>函数()</code>有: row_number(), rank() 和 dense_rank(). 函数括号内不加任何字段, 返回值是<strong>相应规则的排序序号</strong>.</p>
<p>row_number(): 分组内, 查询出来的每一行记录都生成一个序号, 依次排序且不重复.</p>
<p>rank(): 分组内, 跳跃排序, 例如有两个第一, 接下来就是第三.</p>
<p>dense_rank(): 分组内, 连续排序, 例如有两个第一, 接下来就是第二.</p>
<p><strong>2.01, 查询 2019 年 1 月, 用户购买商品品类数量排名:</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> user_name,</span><br><span class="line">    <span class="keyword">count</span>(<span class="keyword">distinct</span> goods_category) goods_num,</span><br><span class="line">    row_number() <span class="keyword">over</span>(<span class="keyword">order</span> <span class="keyword">by</span> </span><br><span class="line">    <span class="keyword">count</span>(<span class="keyword">distinct</span> goods_category) <span class="keyword">desc</span> ) row_number,</span><br><span class="line">    <span class="keyword">rank</span>() <span class="keyword">over</span>(<span class="keyword">order</span> <span class="keyword">by</span> </span><br><span class="line">    <span class="keyword">count</span>(<span class="keyword">distinct</span> goods_category) <span class="keyword">desc</span> ) <span class="keyword">rank</span>,</span><br><span class="line">    <span class="keyword">dense_rank</span>() <span class="keyword">over</span>(<span class="keyword">order</span> <span class="keyword">by</span> </span><br><span class="line">    <span class="keyword">count</span>(<span class="keyword">distinct</span> goods_category) <span class="keyword">desc</span> ) <span class="keyword">dense_rank</span></span><br><span class="line"><span class="keyword">from</span> user_trade</span><br><span class="line"><span class="keyword">where</span> <span class="keyword">substr</span>(dt, <span class="number">1</span>, <span class="number">7</span>)=<span class="string">&#x27;2019-01&#x27;</span></span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> user_name;</span><br></pre></td></tr></table></figure>

<table>
   <tr>
      <td>user_name</td>
      <td>goods_num</td>
      <td>row_number</td>
      <td>rank</td>
      <td>dense_rank</td>
   </tr>
   <tr>
      <td>Payne</td>
      <td>2</td>
      <td>1</td>
      <td>1</td>
      <td>1</td>
   </tr>
   <tr>
      <td>Catherine</td>
      <td>2</td>
      <td>2</td>
      <td>1</td>
      <td>1</td>
   </tr>
   <tr>
      <td>Christy</td>
      <td>2</td>
      <td>3</td>
      <td>1</td>
      <td>1</td>
   </tr>
   <tr>
      <td>Angelia</td>
      <td>2</td>
      <td>4</td>
      <td>1</td>
      <td>1</td>
   </tr>
   <tr>
      <td>Ingrid</td>
      <td>2</td>
      <td>5</td>
      <td>1</td>
      <td>1</td>
   </tr>
   <tr>
      <td>Wheeler</td>
      <td>1</td>
      <td>6</td>
      <td>6</td>
      <td>2</td>
   </tr>
   <tr>
      <td>Ward</td>
      <td>1</td>
      <td>7</td>
      <td>6</td>
      <td>2</td>
   </tr>
</table>

<p><strong>2.02, 查询 2019 年支付金额排名第 5, 10, 15 的用户:</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> a.user_name,</span><br><span class="line">    a.pay_amount,</span><br><span class="line">    a.dr</span><br><span class="line"><span class="keyword">from</span></span><br><span class="line">    (<span class="keyword">select</span> user_name,</span><br><span class="line">        <span class="keyword">sum</span>(pay_amount) pay_amount,</span><br><span class="line">        <span class="keyword">dense_rank</span>() <span class="keyword">over</span>(<span class="keyword">order</span> <span class="keyword">by</span> <span class="keyword">sum</span>(pay_amount) <span class="keyword">desc</span>) dr</span><br><span class="line">    <span class="keyword">from</span> user_trade</span><br><span class="line">    <span class="keyword">where</span> <span class="keyword">year</span>(dt)=<span class="number">2019</span></span><br><span class="line">    <span class="keyword">group</span> <span class="keyword">by</span> user_name) a</span><br><span class="line"><span class="keyword">where</span> a.dr <span class="keyword">in</span> (<span class="number">5</span>, <span class="number">10</span>, <span class="number">15</span>);</span><br></pre></td></tr></table></figure>

<table>
   <tr>
      <td>a.user_name</td>
      <td>a.pay_amount</td>
      <td>a.dr</td>
   </tr>
   <tr>
      <td>King</td>
      <td>553856.5</td>
      <td>5</td>
   </tr>
   <tr>
      <td>James</td>
      <td>286638.0</td>
      <td>10</td>
   </tr>
   <tr>
      <td>Frieda</td>
      <td>192670.0</td>
      <td>15</td>
   </tr>
</table>

<h3 id="3-切片排序窗口函数"><a href="#3-切片排序窗口函数" class="headerlink" title="3, 切片排序窗口函数"></a>3, 切片排序窗口函数</h3><p><code>函数()</code>是 <code>ntile()</code>, 括号内指明切分的片数, 返回值: 切到第几片就是几.<br>不支持 <code>rows between ... and ...</code>.<br>如果行数无法整除, 切片不均匀, 则前面的片(组)均分余数.</p>
<p><strong>3.01, 将 2019 年 1 月支付用户按支付金额分为 5 组:</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> user_name,</span><br><span class="line">    <span class="keyword">sum</span>(pay_amount) pay_amount,</span><br><span class="line">    ntile(<span class="number">5</span>) <span class="keyword">over</span>(<span class="keyword">order</span> <span class="keyword">by</span> <span class="keyword">sum</span>(pay_amount) <span class="keyword">desc</span>) <span class="keyword">level</span></span><br><span class="line"><span class="keyword">from</span> user_trade</span><br><span class="line"><span class="keyword">where</span> <span class="keyword">substr</span>(dt, <span class="number">1</span>, <span class="number">7</span>)=<span class="string">&#x27;2019-01&#x27;</span></span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> user_name;</span><br></pre></td></tr></table></figure>

<table>
   <tr>
      <td>user_name</td>
      <td>pay_amount</td>
      <td>level</td>
   </tr>
   <tr>
      <td>Angelia</td>
      <td>677710.0</td>
      <td>1</td>
   </tr>
   <tr>
      <td>Cherry</td>
      <td>359964.0</td>
      <td>1</td>
   </tr>
   <tr>
      <td>Christy</td>
      <td>217772.5</td>
      <td>1</td>
   </tr>
   <tr>
      <td>Rupert</td>
      <td>62680.8</td>
      <td>1</td>
   </tr>
   <tr>
      <td>Janet</td>
      <td>56481.6</td>
      <td>2</td>
   </tr>
   <tr>
      <td>Ward</td>
      <td>26174.4</td>
      <td>2</td>
   </tr>
   <tr>
      <td>Frank</td>
      <td>22041.6</td>
      <td>2</td>
   </tr>
   <tr>
      <td>Wheeler</td>
      <td>21600.0</td>
      <td>2</td>
   </tr>
   <tr>
      <td>Jill</td>
      <td>14800.0</td>
      <td>3</td>
   </tr>
   <tr>
      <td>Payne</td>
      <td>12247.3</td>
      <td>3</td>
   </tr>
   <tr>
      <td>Peterson</td>
      <td>2066.4</td>
      <td>3</td>
   </tr>
   <tr>
      <td>Catherine</td>
      <td>1320.9</td>
      <td>3</td>
   </tr>
   <tr>
      <td>Cameron</td>
      <td>1219.3</td>
      <td>4</td>
   </tr>
   <tr>
      <td>Cathy</td>
      <td>1000.0</td>
      <td>4</td>
   </tr>
   <tr>
      <td>Amanda</td>
      <td>827.7</td>
      <td>4</td>
   </tr>
   <tr>
      <td>Parker</td>
      <td>631.9</td>
      <td>4</td>
   </tr>
   <tr>
      <td>Mitchell</td>
      <td>471.7</td>
      <td>5</td>
   </tr>
   <tr>
      <td>Ingrid</td>
      <td>465.2</td>
      <td>5</td>
   </tr>
   <tr>
      <td>Cloris</td>
      <td>418.3</td>
      <td>5</td>
   </tr>
   <tr>
      <td>Fiona</td>
      <td>110.0</td>
      <td>5</td>
   </tr>
</table>

<p><strong>3.02, 选出 2019 年退款金额排名前 5% 的用户:</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> a.user_name,</span><br><span class="line">    a.refund_amount,</span><br><span class="line">    a.level</span><br><span class="line"><span class="keyword">from</span></span><br><span class="line">    (<span class="keyword">select</span> user_name,</span><br><span class="line">        <span class="keyword">sum</span>(refund_amount) refund_amount,</span><br><span class="line">        ntile(<span class="number">20</span>) <span class="keyword">over</span>(<span class="keyword">order</span> <span class="keyword">by</span> <span class="keyword">sum</span>(refund_amount) <span class="keyword">desc</span>) <span class="keyword">level</span></span><br><span class="line">    <span class="keyword">from</span> user_refund</span><br><span class="line">    <span class="keyword">where</span> <span class="keyword">year</span>(dt)=<span class="number">2019</span></span><br><span class="line">    <span class="keyword">group</span> <span class="keyword">by</span> user_name) a</span><br><span class="line"><span class="keyword">where</span> a.level=<span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<table>
   <tr>
      <td>a.user_name</td>
      <td>a.refund_amount</td>
      <td>a.level</td>
   </tr>
   <tr>
      <td>Phillips</td>
      <td>626604.0</td>
      <td>1</td>
   </tr>
   <tr>
      <td>Angelia</td>
      <td>586608.0</td>
      <td>1</td>
   </tr>
</table>

<h3 id="4-偏移分析窗口函数"><a href="#4-偏移分析窗口函数" class="headerlink" title="4, 偏移分析窗口函数"></a>4, 偏移分析窗口函数</h3><p><code>函数()</code>为 <code>lag(偏移字段, 偏移量, 填充值)</code> 和 <code>lead(偏移字段, 偏移量, 填充值)</code>, 可在同一次查询中取出同一个字段<strong>前 n 行的数据(lag)**和</strong>后 n 行的数据(lead)**参与计算.</p>
<p>lag: 滞后, 也就是取出原字段数据向下移, 前面空出来的用<code>填充值</code>(默认是 null)填充的数据.</p>
<p>lead: 领先, 也就是取出原字段数据向上移, 后面空出来的用<code>填充值</code>(默认是 null)填充的数据.</p>
<p><code>偏移量</code>默认是 <code>1</code>.</p>
<p><strong>4.01, 查询支付时间间隔有超过 100 天的用户:</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">count</span>(<span class="keyword">distinct</span> a.user_name)</span><br><span class="line"><span class="keyword">from</span></span><br><span class="line">    (<span class="keyword">select</span> user_name,</span><br><span class="line">        dt,</span><br><span class="line">        <span class="keyword">lead</span>(dt) <span class="keyword">over</span>(<span class="keyword">partition</span> <span class="keyword">by</span> user_name <span class="keyword">order</span> <span class="keyword">by</span> dt) lead_dt</span><br><span class="line">    <span class="keyword">from</span> user_trade</span><br><span class="line">    <span class="keyword">where</span> dt&gt;<span class="string">&#x27;0&#x27;</span>) a</span><br><span class="line"><span class="keyword">where</span> a.lead_dt <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">null</span></span><br><span class="line">    <span class="keyword">and</span> <span class="keyword">datediff</span>(a.lead_dt, a.dt)&gt;<span class="number">100</span>;</span><br></pre></td></tr></table></figure>

<p>注意点:<br>窗口函数对 user_name 分组排序后再移动, 分组并未去重, 而是分组并保留所有记录进行排序.<br>同一个用户可能有多个时间间隔超过 100 天, 因此要去重统计.</p>
<p><strong>4.02, 查询每个城市, 不同性别 2018 年支付金额最高的 TOP3 用户:</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> c.user_name,</span><br><span class="line">    c.city,</span><br><span class="line">    c.sex,</span><br><span class="line">    c.pay_amount,</span><br><span class="line">    c.rank</span><br><span class="line"><span class="keyword">from</span></span><br><span class="line">    (<span class="keyword">select</span> a.user_name,</span><br><span class="line">        b.city,</span><br><span class="line">        b.sex,</span><br><span class="line">        a.pay_amount,</span><br><span class="line">        <span class="keyword">dense_rank</span>() <span class="keyword">over</span>(<span class="keyword">partition</span> <span class="keyword">by</span> b.city, b.sex </span><br><span class="line">            <span class="keyword">order</span> <span class="keyword">by</span> a.pay_amount <span class="keyword">desc</span> ) <span class="keyword">rank</span></span><br><span class="line">    <span class="keyword">from</span></span><br><span class="line">        (<span class="keyword">select</span> user_name,</span><br><span class="line">            <span class="keyword">sum</span>(pay_amount) pay_amount</span><br><span class="line">        <span class="keyword">from</span> user_trade</span><br><span class="line">        <span class="keyword">where</span> <span class="keyword">year</span>(dt)=<span class="number">2018</span></span><br><span class="line">        <span class="keyword">group</span> <span class="keyword">by</span> user_name) a</span><br><span class="line">        <span class="keyword">left</span> <span class="keyword">join</span> user_info b</span><br><span class="line">        <span class="keyword">on</span> a.user_name=b.user_name</span><br><span class="line">    ) c</span><br><span class="line"><span class="keyword">where</span> c.rank&lt;=<span class="number">3</span>;</span><br></pre></td></tr></table></figure>

<table>
   <tr>
      <td>c.user_name</td>
      <td>c.city</td>
      <td>c.sex</td>
      <td>c.pay_amount</td>
      <td>c.rank</td>
   </tr>
   <tr>
      <td>Christine</td>
      <td>beijing</td>
      <td>female</td>
      <td>633270.0</td>
      <td>1</td>
   </tr>
   <tr>
      <td>DARCY</td>
      <td>beijing</td>
      <td>female</td>
      <td>486704.9</td>
      <td>2</td>
   </tr>
   <tr>
      <td>Becky</td>
      <td>beijing</td>
      <td>female</td>
      <td>268957.7</td>
      <td>3</td>
   </tr>
   <tr>
      <td>Campbell</td>
      <td>beijing</td>
      <td>male</td>
      <td>653347.2</td>
      <td>1</td>
   </tr>
   <tr>
      <td>Ross</td>
      <td>beijing</td>
      <td>male</td>
      <td>546811.2</td>
      <td>2</td>
   </tr>
   <tr>
      <td>Mitchell</td>
      <td>beijing</td>
      <td>male</td>
      <td>466620.0</td>
      <td>3</td>
   </tr>
   <tr>
      <td>Joanna</td>
      <td>changchun</td>
      <td>female</td>
      <td>1059184.0</td>
      <td>1</td>
   </tr>
   <tr>
      <td>Andrea</td>
      <td>changchun</td>
      <td>female</td>
      <td>1058965.3</td>
      <td>2</td>
   </tr>
   <tr>
      <td>Cherry</td>
      <td>changchun</td>
      <td>female</td>
      <td>524638.5</td>
      <td>3</td>
   </tr>
   <tr>
      <td>Noah</td>
      <td>changchun</td>
      <td>male</td>
      <td>1033230.0</td>
      <td>1</td>
   </tr>
</table>

<p><strong>4.03, 查询每个手机品牌退款金额前 20% 的用户:</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> *</span><br><span class="line"><span class="keyword">from</span></span><br><span class="line">    (<span class="keyword">select</span> a.user_name,</span><br><span class="line">        b.extra2[<span class="string">&#x27;phonebrand&#x27;</span>] phonebrand,</span><br><span class="line">        a.refund_amount,</span><br><span class="line">        ntile(<span class="number">5</span>) <span class="keyword">over</span>(<span class="keyword">partition</span> <span class="keyword">by</span> b.extra2[<span class="string">&#x27;phonebrand&#x27;</span>]</span><br><span class="line">            <span class="keyword">order</span> <span class="keyword">by</span> a.refund_amount <span class="keyword">desc</span>) <span class="keyword">level</span></span><br><span class="line">    <span class="keyword">from</span></span><br><span class="line">        (<span class="keyword">select</span> user_name,</span><br><span class="line">            <span class="keyword">sum</span>(refund_amount) refund_amount</span><br><span class="line">        <span class="keyword">from</span> user_refund</span><br><span class="line">        <span class="keyword">where</span> dt&gt;<span class="string">&#x27;0&#x27;</span></span><br><span class="line">        <span class="keyword">group</span> <span class="keyword">by</span> user_name</span><br><span class="line">        ) a</span><br><span class="line">        <span class="keyword">left</span> <span class="keyword">join</span> user_info b</span><br><span class="line">        <span class="keyword">on</span> a.user_name=b.user_name</span><br><span class="line">    ) c</span><br><span class="line"><span class="keyword">where</span> c.level=<span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<table>
   <tr>
      <td>c.user_name</td>
      <td>c.phonebrand</td>
      <td>c.refund_amount</td>
      <td>c.level</td>
   </tr>
   <tr>
      <td>Martin</td>
      <td>CHUIZI</td>
      <td>606953.1</td>
      <td>1</td>
   </tr>
   <tr>
      <td>David</td>
      <td>CHUIZI</td>
      <td>277750.0</td>
      <td>1</td>
   </tr>
   <tr>
      <td>DORIS</td>
      <td>CHUIZI</td>
      <td>231168.3</td>
      <td>1</td>
   </tr>
   <tr>
      <td>Jordan</td>
      <td>CHUIZI</td>
      <td>182266.7</td>
      <td>1</td>
   </tr>
   <tr>
      <td>Angelia</td>
      <td>HUAWEI</td>
      <td>586697.1</td>
      <td>1</td>
   </tr>
   <tr>
      <td>DIANA</td>
      <td>HUAWEI</td>
      <td>566610.0</td>
      <td>1</td>
   </tr>
   <tr>
      <td>Cassie</td>
      <td>HUAWEI</td>
      <td>234443.2</td>
      <td>1</td>
   </tr>
   <tr>
      <td>KATE</td>
      <td>MI</td>
      <td>826619.6</td>
      <td>1</td>
   </tr>
   <tr>
      <td>ELLIE</td>
      <td>MI</td>
      <td>664728.3</td>
      <td>1</td>
   </tr>
   <tr>
      <td>JUNE</td>
      <td>MI</td>
      <td>379962.0</td>
      <td>1</td>
   </tr>
</table>

<p><strong>4.04, 查询退款时间间隔最长的前 10 位用户:</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 方法一</span></span><br><span class="line"><span class="keyword">select</span> a.user_name,</span><br><span class="line">    <span class="keyword">max</span>(<span class="keyword">datediff</span>(a.lead_dt, a.dt)) dt_interval</span><br><span class="line"><span class="keyword">from</span>    </span><br><span class="line">    (<span class="keyword">select</span> user_name,</span><br><span class="line">            dt,</span><br><span class="line">            <span class="keyword">lead</span>(dt) <span class="keyword">over</span>(<span class="keyword">partition</span> <span class="keyword">by</span> user_name <span class="keyword">order</span> <span class="keyword">by</span> dt) lead_dt</span><br><span class="line">        <span class="keyword">from</span> user_refund</span><br><span class="line">        <span class="keyword">where</span> dt&gt;<span class="string">&#x27;0&#x27;</span>) a</span><br><span class="line"><span class="keyword">where</span> a.lead_dt <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">null</span></span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> user_name</span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> dt_interval <span class="keyword">desc</span></span><br><span class="line"><span class="keyword">limit</span> <span class="number">10</span>;</span><br></pre></td></tr></table></figure>

<table>
   <tr>
      <td>a.user_name</td>
      <td>dt_interval</td>
   </tr>
   <tr>
      <td>April</td>
      <td>725</td>
   </tr>
   <tr>
      <td>Aviva</td>
      <td>648</td>
   </tr>
   <tr>
      <td>Jamie</td>
      <td>513</td>
   </tr>
   <tr>
      <td>Angela</td>
      <td>507</td>
   </tr>
   <tr>
      <td>Harrison</td>
      <td>503</td>
   </tr>
   <tr>
      <td>Maynard</td>
      <td>496</td>
   </tr>
   <tr>
      <td>Noah</td>
      <td>476</td>
   </tr>
   <tr>
      <td>DEMI</td>
      <td>461</td>
   </tr>
   <tr>
      <td>DEBBIE</td>
      <td>448</td>
   </tr>
   <tr>
      <td>DORIS</td>
      <td>441</td>
   </tr>
</table>

<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 方法二</span></span><br><span class="line"><span class="keyword">select</span> b.user_name,</span><br><span class="line">    b.rank</span><br><span class="line"><span class="keyword">from</span></span><br><span class="line">    (<span class="keyword">select</span> a.user_name,</span><br><span class="line">        <span class="keyword">rank</span>() <span class="keyword">over</span>(<span class="keyword">order</span> <span class="keyword">by</span> <span class="keyword">max</span>(<span class="keyword">datediff</span>(a.lead_dt, a.dt)) <span class="keyword">desc</span>) <span class="keyword">rank</span></span><br><span class="line">    <span class="keyword">from</span></span><br><span class="line">        (<span class="keyword">select</span> user_name,</span><br><span class="line">            dt,</span><br><span class="line">            <span class="keyword">lead</span>(dt) <span class="keyword">over</span>(<span class="keyword">partition</span> <span class="keyword">by</span> user_name <span class="keyword">order</span> <span class="keyword">by</span> dt) lead_dt</span><br><span class="line">        <span class="keyword">from</span> user_refund</span><br><span class="line">        <span class="keyword">where</span> dt&gt;<span class="string">&#x27;0&#x27;</span>) a</span><br><span class="line">    <span class="keyword">where</span> a.lead_dt <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">null</span></span><br><span class="line">    <span class="keyword">group</span> <span class="keyword">by</span> a.user_name</span><br><span class="line">    ) b</span><br><span class="line"><span class="keyword">where</span> b.rank&lt;=<span class="number">10</span>;</span><br></pre></td></tr></table></figure>
<table>
   <tr>
      <td>b.user_name</td>
      <td>b.rank</td>
   </tr>
   <tr>
      <td>April</td>
      <td>1</td>
   </tr>
   <tr>
      <td>Aviva</td>
      <td>2</td>
   </tr>
   <tr>
      <td>Jamie</td>
      <td>3</td>
   </tr>
   <tr>
      <td>Angela</td>
      <td>4</td>
   </tr>
   <tr>
      <td>Harrison</td>
      <td>5</td>
   </tr>
   <tr>
      <td>Maynard</td>
      <td>6</td>
   </tr>
   <tr>
      <td>Noah</td>
      <td>7</td>
   </tr>
   <tr>
      <td>DEMI</td>
      <td>8</td>
   </tr>
   <tr>
      <td>DEBBIE</td>
      <td>9</td>
   </tr>
   <tr>
      <td>DORIS</td>
      <td>10</td>
   </tr>
</table>

<p>方法一如果出现并列排名, 就会有误差, 方法二则无此顾虑, 但是需要注意窗口函数分组是不去重的, 两个方法都需要对 <code>user_name</code> 去重, 不然可能出现同一个用户重复出现的情况.</p>
<br>

<h2 id="六-HiveQL-常用优化技巧"><a href="#六-HiveQL-常用优化技巧" class="headerlink" title="六, HiveQL 常用优化技巧"></a>六, HiveQL 常用优化技巧</h2><h3 id="1-用-group-by-代替-distinct-去重"><a href="#1-用-group-by-代替-distinct-去重" class="headerlink" title="1, 用 group by 代替 distinct 去重"></a>1, 用 group by 代替 distinct 去重</h3><p>在数据量大, 重复值多时, 能先使用 group by 去重的, 使用 group by 去重后再计算, 比之后再去重计算效率更高.</p>
<p>例如前面的例题中, <strong>查询 2019 年购买后又退款的用户</strong>, 可以这样优化:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> a.user_name</span><br><span class="line"><span class="keyword">from</span></span><br><span class="line">    (<span class="keyword">select</span> user_name</span><br><span class="line">    <span class="keyword">from</span> user_trade</span><br><span class="line">    <span class="keyword">where</span> <span class="keyword">year</span>(dt)=<span class="number">2019</span></span><br><span class="line">    <span class="keyword">group</span> <span class="keyword">by</span> user_name) a</span><br><span class="line"><span class="keyword">join</span></span><br><span class="line">    (<span class="keyword">select</span> user_name</span><br><span class="line">    <span class="keyword">from</span> user_refund</span><br><span class="line">    <span class="keyword">where</span> <span class="keyword">year</span>(dt)=<span class="number">2019</span></span><br><span class="line">    <span class="keyword">group</span> <span class="keyword">by</span> user_name) b</span><br><span class="line"><span class="keyword">on</span> a.user_name=b.user_name;</span><br></pre></td></tr></table></figure>

<h3 id="2-多维度聚合"><a href="#2-多维度聚合" class="headerlink" title="2, 多维度聚合"></a>2, 多维度聚合</h3><p>需要对多个字段进行聚合运算, 一个字段一个字段的写 SQL 计算, 不如使用多维度聚合计算语句: <code>grouping sets</code>, <code>cube</code> 和 <code>rollup</code>.</p>
<p><strong>2.01, 分别查询用性别, 城市, 等级分布:</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> sex, city, <span class="keyword">level</span>,</span><br><span class="line">    <span class="keyword">count</span>(user_id)</span><br><span class="line"><span class="keyword">from</span> user_info</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> sex, city, <span class="keyword">level</span>;</span><br></pre></td></tr></table></figure>
<p>上述 sql 查询出来的是同一性别, 不同城市, 不同等级的分布, 而我们需要的结果是三个字段的结果是分开的:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> sex, city, <span class="keyword">level</span>,</span><br><span class="line">    <span class="keyword">count</span>(user_id)</span><br><span class="line"><span class="keyword">from</span> user_info</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> sex, city, <span class="keyword">level</span></span><br><span class="line"><span class="keyword">grouping</span> <span class="keyword">sets</span> (sex, city, <span class="keyword">level</span>);</span><br></pre></td></tr></table></figure>
<table>
   <tr>
      <td>sex</td>
      <td>city</td>
      <td>level</td>
      <td>_c3</td>
   </tr>
   <tr>
      <td>NULL</td>
      <td>NULL</td>
      <td>1</td>
      <td>33</td>
   </tr>
   <tr>
      <td>NULL</td>
      <td>NULL</td>
      <td>2</td>
      <td>26</td>
   </tr>
   <tr>
      <td>NULL</td>
      <td>NULL</td>
      <td>3</td>
      <td>30</td>
   </tr>
   <tr>
      <td>NULL</td>
      <td>NULL</td>
      <td>4</td>
      <td>44</td>
   </tr>
   <tr>
      <td>NULL</td>
      <td>NULL</td>
      <td>5</td>
      <td>30</td>
   </tr>
   <tr>
      <td>NULL</td>
      <td>NULL</td>
      <td>6</td>
      <td>32</td>
   </tr>
   <tr>
      <td>NULL</td>
      <td>NULL</td>
      <td>7</td>
      <td>35</td>
   </tr>
   <tr>
      <td>NULL</td>
      <td>NULL</td>
      <td>8</td>
      <td>34</td>
   </tr>
   <tr>
      <td>NULL</td>
      <td>NULL</td>
      <td>9</td>
      <td>30</td>
   </tr>
   <tr>
      <td>NULL</td>
      <td>NULL</td>
      <td>10</td>
      <td>33</td>
   </tr>
   <tr>
      <td>NULL</td>
      <td>beijing</td>
      <td>NULL</td>
      <td>53</td>
   </tr>
   <tr>
      <td>NULL</td>
      <td>changchun</td>
      <td>NULL</td>
      <td>53</td>
   </tr>
   <tr>
      <td>NULL</td>
      <td>guangzhou</td>
      <td>NULL</td>
      <td>55</td>
   </tr>
   <tr>
      <td>NULL</td>
      <td>hangzhou</td>
      <td>NULL</td>
      <td>57</td>
   </tr>
   <tr>
      <td>NULL</td>
      <td>shanghai</td>
      <td>NULL</td>
      <td>61</td>
   </tr>
   <tr>
      <td>NULL</td>
      <td>shenzhen</td>
      <td>NULL</td>
      <td>48</td>
   </tr>
   <tr>
      <td>female</td>
      <td>NULL</td>
      <td>NULL</td>
      <td>177</td>
   </tr>
   <tr>
      <td>male</td>
      <td>NULL</td>
      <td>NULL</td>
      <td>150</td>
   </tr>
</table>

<p>a, <code>grouping sets()</code> 相当于将不同 group by 聚合的结果进行 union all, 可以在括号中指明聚合规则.</p>
<p><strong>2.02, 查询性别分布, 以及不同性别的城市分布:</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> sex, city,</span><br><span class="line">    <span class="keyword">count</span>(user_id)</span><br><span class="line"><span class="keyword">from</span> user_info</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> sex, city</span><br><span class="line"><span class="keyword">grouping</span> <span class="keyword">sets</span> (sex, (sex, city));</span><br></pre></td></tr></table></figure>
<table>
   <tr>
      <td>sex</td>
      <td>city</td>
      <td>_c2</td>
   </tr>
   <tr>
      <td>female</td>
      <td>NULL</td>
      <td>177</td>
   </tr>
   <tr>
      <td>female</td>
      <td>beijing</td>
      <td>26</td>
   </tr>
   <tr>
      <td>female</td>
      <td>changchun</td>
      <td>32</td>
   </tr>
   <tr>
      <td>female</td>
      <td>guangzhou</td>
      <td>30</td>
   </tr>
   <tr>
      <td>female</td>
      <td>hangzhou</td>
      <td>30</td>
   </tr>
   <tr>
      <td>female</td>
      <td>shanghai</td>
      <td>36</td>
   </tr>
   <tr>
      <td>female</td>
      <td>shenzhen</td>
      <td>23</td>
   </tr>
   <tr>
      <td>male</td>
      <td>NULL</td>
      <td>150</td>
   </tr>
   <tr>
      <td>male</td>
      <td>beijing</td>
      <td>27</td>
   </tr>
   <tr>
      <td>male</td>
      <td>changchun</td>
      <td>21</td>
   </tr>
   <tr>
      <td>male</td>
      <td>guangzhou</td>
      <td>25</td>
   </tr>
   <tr>
      <td>male</td>
      <td>hangzhou</td>
      <td>27</td>
   </tr>
   <tr>
      <td>male</td>
      <td>shanghai</td>
      <td>25</td>
   </tr>
   <tr>
      <td>male</td>
      <td>shenzhen</td>
      <td>25</td>
   </tr>
</table>

<p>城市一列为 null 的是性别分布, 其他的是每个性别的城市分布.</p>
<p>b, <code>with cube</code>将分组聚合的所有维度都进行计算:</p>
<p><strong>2.03, 查询性别, 城市, 等级各种组合的用户分布情况:</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 方法一</span></span><br><span class="line"><span class="keyword">select</span> sex, city, <span class="keyword">level</span>,</span><br><span class="line">    <span class="keyword">count</span>(user_id)</span><br><span class="line"><span class="keyword">from</span> user_info</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> sex, city, <span class="keyword">level</span></span><br><span class="line"><span class="keyword">grouping</span> <span class="keyword">sets</span> (sex, city, <span class="keyword">level</span>, </span><br><span class="line">    (sex, city), (sex, <span class="keyword">level</span>), (city, <span class="keyword">level</span>),</span><br><span class="line">    (sex, city, <span class="keyword">level</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 方法二</span></span><br><span class="line"><span class="keyword">select</span> sex, city, <span class="keyword">level</span>,</span><br><span class="line">    <span class="keyword">count</span>(user_id)</span><br><span class="line"><span class="keyword">from</span> user_info</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> sex, city, <span class="keyword">level</span></span><br><span class="line"><span class="keyword">with</span> <span class="keyword">cube</span>;</span><br></pre></td></tr></table></figure>
<p>方法二将所有用户数进行了统计, 方法一没有.</p>
<p>c, <code>with rollup</code>以最左侧的字段为主, 进行层级聚合, 结果是 <code>with cube</code> 的子集.</p>
<p><strong>2.04, 查询每个月的支付金额及每年的支付金额:</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 方法一</span></span><br><span class="line"><span class="keyword">select</span> a.dt,</span><br><span class="line">    <span class="keyword">sum</span>(a.year_amount),</span><br><span class="line">    <span class="keyword">sum</span>(a.month_amount)</span><br><span class="line"><span class="keyword">from</span></span><br><span class="line">    (<span class="keyword">select</span> <span class="keyword">substr</span>(dt, <span class="number">1</span>, <span class="number">4</span>) dt,</span><br><span class="line">        <span class="keyword">sum</span>(pay_amount) year_amount,</span><br><span class="line">        <span class="number">0</span> month_amount</span><br><span class="line">    <span class="keyword">from</span> user_trade</span><br><span class="line">    <span class="keyword">where</span> dt&gt;<span class="string">&#x27;0&#x27;</span></span><br><span class="line">    <span class="keyword">group</span> <span class="keyword">by</span> <span class="keyword">substr</span>(dt, <span class="number">1</span>, <span class="number">4</span>)</span><br><span class="line">    <span class="keyword">union</span> <span class="keyword">all</span></span><br><span class="line">    <span class="keyword">select</span> <span class="keyword">substr</span>(dt, <span class="number">1</span>, <span class="number">7</span>) dt,</span><br><span class="line">        <span class="number">0</span> year_mount,</span><br><span class="line">        <span class="keyword">sum</span>(pay_amount) month_amount</span><br><span class="line">    <span class="keyword">from</span> user_trade</span><br><span class="line">    <span class="keyword">where</span> dt&gt;<span class="string">&#x27;0&#x27;</span></span><br><span class="line">    <span class="keyword">group</span> <span class="keyword">by</span> <span class="keyword">substr</span>(dt, <span class="number">1</span>, <span class="number">7</span>)</span><br><span class="line">    ) a</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> a.dt;</span><br></pre></td></tr></table></figure>
<table>
   <tr>
      <td>a.dt</td>
      <td>_c1</td>
      <td>_c2</td>
   </tr>
   <tr>
      <td>2017</td>
      <td>24333973.60 </td>
      <td>0.00 </td>
   </tr>
   <tr>
      <td>2017-01</td>
      <td>0.00 </td>
      <td>241755.70 </td>
   </tr>
   <tr>
      <td>2017-02</td>
      <td>0.00 </td>
      <td>2582410.60 </td>
   </tr>
</table>

<p>第一列是年的总额.</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 方法二</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">year</span>(dt) <span class="keyword">year</span>,</span><br><span class="line">    <span class="keyword">month</span>(dt) <span class="keyword">month</span>,</span><br><span class="line">    <span class="keyword">sum</span>(pay_amount)</span><br><span class="line"><span class="keyword">from</span> user_trade</span><br><span class="line"><span class="keyword">where</span> dt&gt;<span class="string">&#x27;0&#x27;</span></span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> <span class="keyword">year</span>(dt), <span class="keyword">month</span>(dt)</span><br><span class="line"><span class="keyword">with</span> <span class="keyword">rollup</span>;</span><br></pre></td></tr></table></figure>
<table>
   <tr>
      <td>year</td>
      <td>month</td>
      <td>_c2</td>
   </tr>
   <tr>
      <td>NULL</td>
      <td>NULL</td>
      <td>62348041.30 </td>
   </tr>
   <tr>
      <td>2017</td>
      <td>NULL</td>
      <td>24333973.60 </td>
   </tr>
   <tr>
      <td>2017</td>
      <td>1</td>
      <td>241755.70 </td>
   </tr>
   <tr>
      <td>2017</td>
      <td>2</td>
      <td>2582410.60 </td>
   </tr>
</table>

<p>第一列是全部的总额, 第二列是年的总额. <code>with rollup</code>计算了全部的总额和以 year 字段为主的两个维度 <code>year</code>, <code>(year, month)</code>的总额.</p>
<h3 id="3-转换解题思路"><a href="#3-转换解题思路" class="headerlink" title="3, 转换解题思路"></a>3, 转换解题思路</h3><p>前面的例题, <strong>查询 2017 和 2018 都购买的用户</strong>, 可以如下优化:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> a.user_name</span><br><span class="line"><span class="keyword">from</span> (<span class="keyword">select</span> user_name,</span><br><span class="line">        <span class="keyword">count</span>(<span class="keyword">distinct</span> <span class="keyword">year</span>(dt)) year_num</span><br><span class="line">    <span class="keyword">from</span> user_trade</span><br><span class="line">    <span class="keyword">where</span> <span class="keyword">year</span>(dt) <span class="keyword">in</span> (<span class="number">2017</span>, <span class="number">2018</span>)</span><br><span class="line">    <span class="keyword">group</span> <span class="keyword">by</span> user_name) a</span><br><span class="line"><span class="keyword">where</span> a.year_num=<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 还可再优化</span></span><br><span class="line"><span class="keyword">select</span> user_name,</span><br><span class="line">    <span class="keyword">count</span>(<span class="keyword">distinct</span> <span class="keyword">year</span>(dt)) year_num</span><br><span class="line"><span class="keyword">from</span> user_trade</span><br><span class="line"><span class="keyword">where</span> <span class="keyword">year</span>(dt) <span class="keyword">in</span> (<span class="number">2017</span>, <span class="number">2018</span>)</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> user_name</span><br><span class="line"><span class="keyword">having</span> <span class="keyword">count</span>(<span class="keyword">distinct</span> <span class="keyword">year</span>(dt))=<span class="number">2</span>;</span><br></pre></td></tr></table></figure>

<h3 id="4-有-union-all-查询时-开启并发执行"><a href="#4-有-union-all-查询时-开启并发执行" class="headerlink" title="4, 有 union all 查询时, 开启并发执行"></a>4, 有 union all 查询时, 开启并发执行</h3><p>开启参数设置: <code>set hive.exec.parallel=true</code></p>
<p>查看是否设置成功: <code>set hive.exec.parallel;</code></p>
<p>多台服务器时开启才有效.</p>
<h3 id="5-同一字段的数据展开-或按分组归类"><a href="#5-同一字段的数据展开-或按分组归类" class="headerlink" title="5, 同一字段的数据展开, 或按分组归类"></a>5, 同一字段的数据展开, 或按分组归类</h3><p>有用户购买的商品表 <code>user_goods_category</code>:</p>
<table>
   <tr>
      <td>col_name</td>
      <td>data_type</td>
   </tr>
   <tr>
      <td>user_name           </td>
      <td>string              </td>
   </tr>
   <tr>
      <td>category_detail     </td>
      <td>string     </td>
   </tr>
</table>

<p>部分数据:</p>
<table>
   <tr>
      <td>Abby</td>
      <td>clothes,food,electronics</td>
   </tr>
   <tr>
      <td>Ailsa</td>
      <td>book,clothes,food</td>
   </tr>
   <tr>
      <td>Albert</td>
      <td>clothes,electronics,computer</td>
   </tr>
</table>

<p>a, 同一字段的数据展开:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">基表 lateral view explode(列表字段) 单列表 as 列名1</span><br></pre></td></tr></table></figure>
<p>得到的结果是一个<strong>将 <code>基表</code> 的 <code>列表字段</code> 展开得到列名为 <code>列名1</code> 的 <code>单列表</code> 与 <code>基表</code> 合并</strong>的特殊表.</p>
<p><strong>5.01, 查询每个商品品类的购买用户数:</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> b.category,</span><br><span class="line">    <span class="keyword">count</span>(<span class="keyword">distinct</span> a.user_name)</span><br><span class="line"><span class="keyword">from</span> user_goods_category a</span><br><span class="line"><span class="keyword">lateral</span> <span class="keyword">view</span> <span class="keyword">explode</span>(<span class="keyword">split</span>(category_detail, <span class="string">&#x27;,&#x27;</span>)) b <span class="keyword">as</span> <span class="keyword">category</span></span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> b.category;</span><br></pre></td></tr></table></figure>
<table>
   <tr>
      <td>b.category</td>
      <td>_c1</td>
   </tr>
   <tr>
      <td>book</td>
      <td>99</td>
   </tr>
   <tr>
      <td>clothes</td>
      <td>110</td>
   </tr>
   <tr>
      <td>computer</td>
      <td>99</td>
   </tr>
   <tr>
      <td>electronics</td>
      <td>99</td>
   </tr>
   <tr>
      <td>food</td>
      <td>105</td>
   </tr>
   <tr>
      <td>shoes</td>
      <td>91</td>
   </tr>
</table>

<p><code>split()</code>将字符串分割并以列表形式返回.</p>
<p><code>explode()</code>将值为列表形式的字段展开成多行.</p>
<p><code>from</code>语句后面得到的特殊表如下:</p>
<table>
   <tr>
      <td>a.user_name</td>
      <td>a.category_detail</td>
      <td>b.category</td>
   </tr>
   <tr>
      <td>Abby</td>
      <td>clothes,food,electronics</td>
      <td>clothes</td>
   </tr>
   <tr>
      <td>Abby</td>
      <td>clothes,food,electronics</td>
      <td>food</td>
   </tr>
   <tr>
      <td>Abby</td>
      <td>clothes,food,electronics</td>
      <td>electronics</td>
   </tr>
   <tr>
      <td>Ailsa</td>
      <td>book,clothes,food</td>
      <td>book</td>
   </tr>
   <tr>
      <td>Ailsa</td>
      <td>book,clothes,food</td>
      <td>clothes</td>
   </tr>
   <tr>
      <td>Ailsa</td>
      <td>book,clothes,food</td>
      <td>food</td>
   </tr>
</table>

<p>b, 同一字段按分组归类:</p>
<p><strong>5.02, 查看每个商品品类都有哪些用户购买:</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> b.category,</span><br><span class="line">    collect_set(<span class="keyword">distinct</span> a.user_name)</span><br><span class="line"><span class="keyword">from</span> user_goods_category a</span><br><span class="line"><span class="keyword">lateral</span> <span class="keyword">view</span> <span class="keyword">explode</span>(<span class="keyword">split</span>(category_detail, <span class="string">&#x27;,&#x27;</span>)) b <span class="keyword">as</span> <span class="keyword">category</span></span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> b.category;</span><br></pre></td></tr></table></figure>
<table>
   <tr>
      <td>b.category</td>
      <td>_c1</td>
   </tr>
   <tr>
      <td>book</td>
      <td>["Ailsa","Alexander",…(后面省略)]</td>
   </tr>
   <tr>
      <td>clothes</td>
      <td>["Abby","Ailsa",...(后面省略)]</td>
   </tr>
</table>

<p><code>collect_set()</code>将分组后分到同一组的值全部放到一个列表里显示出来, 还可以再用 <code>concat_ws(&#39;分隔符&#39;, ...)</code> 将列表中的值连接成字符串.</p>
<h3 id="6-表连接优化"><a href="#6-表连接优化" class="headerlink" title="6, 表连接优化"></a>6, 表连接优化</h3><ul>
<li><p>使用相同的连接键<br>对3个以上表进行 join 连接, on 条件使用相同的连接键, 只会产生一个 MapReduce job.</p>
</li>
<li><p>尽早进行数据过滤<br>例如数据只选择需要的区段和字段, 分组去重等.</p>
</li>
<li><p>逻辑过于复杂时引入中间表</p>
</li>
</ul>
<h3 id="7-防止数据倾斜"><a href="#7-防止数据倾斜" class="headerlink" title="7, 防止数据倾斜"></a>7, 防止数据倾斜</h3><p>数据倾斜: 任务执行过程中, 大部分任务执行完成, 少数任务一直在执行中的情况.</p>
<ul>
<li><p>空值产生的数据倾斜<br>表连接时, 连接字段有空值, 增加空值过滤条件, 例如:<br><code>on a.id=b.id and a.id is not null</code></p>
</li>
<li><p>表连接时, 连接字段数据类型不一致<br>将数据类型转换一致, 例如:<br><code>on a.id=cast(b.id as string)</code></p>
</li>
</ul>
<br>

<h1 id="Hive-扩展"><a href="#Hive-扩展" class="headerlink" title="Hive 扩展"></a>Hive 扩展</h1>]]></content>
      <categories>
        <category>数据分析</category>
      </categories>
      <tags>
        <tag>HiveQL</tag>
      </tags>
  </entry>
  <entry>
    <title>Mysql 常用函数</title>
    <url>/data/mysql3-8dca988d8207/</url>
    <content><![CDATA[<blockquote>
<p>文章主要内容和思路来源: <strong>开课吧</strong>学习笔记</p>
</blockquote>
<h2 id="四-mysql-常用函数"><a href="#四-mysql-常用函数" class="headerlink" title="四, mysql 常用函数"></a>四, mysql 常用函数</h2><h3 id="1-字符串函数"><a href="#1-字符串函数" class="headerlink" title="1, 字符串函数"></a>1, 字符串函数</h3><h4 id="字符串合并-concat-concat-ws"><a href="#字符串合并-concat-concat-ws" class="headerlink" title="字符串合并 concat, concat_ws:"></a>字符串合并 <code>concat</code>, <code>concat_ws</code>:</h4><ul>
<li><code>concat(s1, s2, ..., sn)</code>, 将多个对象合并, 某个对象为 <code>null</code>, 全体为空.</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">%%sql</span><br><span class="line">select concat(<span class="string">&#x27;bill&#x27;</span>, <span class="string">&#x27;is&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;student.&#x27;</span>) <span class="keyword">as</span> bill</span><br></pre></td></tr></table></figure>

<pre><code> * mysql+pymysql://root:***@localhost/test
1 rows affected.</code></pre>
<table>
    <tr>
        <th>bill</th>
    </tr>
    <tr>
        <td>billisastudent.</td>
    </tr>
</table>




<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">%%sql</span><br><span class="line">select concat(curdate(), <span class="string">&#x27;_&#x27;</span>, <span class="number">12.34</span>, <span class="string">&#x27;_&#x27;</span>)</span><br></pre></td></tr></table></figure>

<pre><code> * mysql+pymysql://root:***@localhost/test
1 rows affected.</code></pre>
<table>
    <tr>
        <th>concat(curdate(), &#x27;_&#x27;, 12.34, &#x27;_&#x27;)</th>
    </tr>
    <tr>
        <td>2020-05-17_12.34_</td>
    </tr>
</table>



<ul>
<li><code>concat_ws(sep, s1, s2, ..., sn)</code>, 用分隔符 <code>sep</code> 将对象连接, <code>sep</code> 为 null, 全体为空, 其他为 null 无影响.</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">%%sql</span><br><span class="line">select concat_ws(<span class="string">&#x27;_&#x27;</span>, <span class="string">&#x27;bill&#x27;</span>, <span class="string">&#x27;is&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;student&#x27;</span>) <span class="keyword">as</span> bill</span><br></pre></td></tr></table></figure>

<pre><code> * mysql+pymysql://root:***@localhost/test
1 rows affected.</code></pre>
<table>
    <tr>
        <th>bill</th>
    </tr>
    <tr>
        <td>bill_is_a_student</td>
    </tr>
</table>




<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">%%sql</span><br><span class="line">select concat_ws(curdate(), <span class="string">&#x27;_&#x27;</span>, <span class="number">12.34</span>, <span class="string">&#x27;什么情况&#x27;</span>, <span class="string">&#x27;_&#x27;</span>)</span><br></pre></td></tr></table></figure>

<pre><code> * mysql+pymysql://root:***@localhost/test
1 rows affected.</code></pre>
<table>
    <tr>
        <th>concat_ws(curdate(), &#x27;_&#x27;, 12.34, &#x27;什么情况&#x27;, &#x27;_&#x27;)</th>
    </tr>
    <tr>
        <td>_2020-05-1812.342020-05-18什么情况2020-05-18_</td>
    </tr>
</table>



<h4 id="字符串比较-strcmp"><a href="#字符串比较-strcmp" class="headerlink" title="字符串比较 strcmp:"></a>字符串比较 <code>strcmp</code>:</h4><p><code>strcmp(s1, s2)</code>, s1 &gt; s2 返回 1, s1 &lt; s2 返回 -1, 等于返回 0</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">%%sql</span><br><span class="line">select strcmp(<span class="number">1</span>, <span class="number">2</span>),</span><br><span class="line">    strcmp(<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;3&#x27;</span>),</span><br><span class="line">    strcmp(<span class="string">&#x27;2&#x27;</span>, <span class="number">1.6</span>)</span><br></pre></td></tr></table></figure>

<pre><code> * mysql+pymysql://root:***@localhost/test
1 rows affected.</code></pre>
<table>
    <tr>
        <th>strcmp(1, 2)</th>
        <th>strcmp(&#x27;a&#x27;, &#x27;3&#x27;)</th>
        <th>strcmp(&#x27;2&#x27;, 1.6)</th>
    </tr>
    <tr>
        <td>-1</td>
        <td>1</td>
        <td>1</td>
    </tr>
</table>



<h4 id="字符串长度-length-char-length"><a href="#字符串长度-length-char-length" class="headerlink" title="字符串长度 length, char_length:"></a>字符串长度 <code>length</code>, <code>char_length</code>:</h4><ul>
<li><code>length()</code> 返回字符串的长度，以字节为单位, utf8 编码下, 一个汉字三个字节，一个数字或字母一个字节, gbk 下, 一个汉字两个字节，一个数字或字母一个字节.</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">%%sql</span><br><span class="line">select <span class="string">&#x27;bill&#x27;</span>, length(<span class="string">&#x27;bill&#x27;</span>), <span class="string">&#x27;中文&#x27;</span>, length(<span class="string">&#x27;中文&#x27;</span>)</span><br></pre></td></tr></table></figure>

<pre><code> * mysql+pymysql://root:***@localhost/test
1 rows affected.</code></pre>
<table>
    <tr>
        <th>bill</th>
        <th>length(&#x27;bill&#x27;)</th>
        <th>中文</th>
        <th>length(&#x27;中文&#x27;)</th>
    </tr>
    <tr>
        <td>bill</td>
        <td>4</td>
        <td>中文</td>
        <td>6</td>
    </tr>
</table>



<ul>
<li><code>char_length()</code> 返回字符串的长度，以字符为单位.</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">%%sql</span><br><span class="line">select <span class="string">&#x27;bill&#x27;</span>, char_length(<span class="string">&#x27;bill&#x27;</span>), <span class="string">&#x27;中文&#x27;</span>, char_length(<span class="string">&#x27;中文&#x27;</span>)</span><br></pre></td></tr></table></figure>

<pre><code> * mysql+pymysql://root:***@localhost/test
1 rows affected.</code></pre>
<table>
    <tr>
        <th>bill</th>
        <th>char_length(&#x27;bill&#x27;)</th>
        <th>中文</th>
        <th>char_length(&#x27;中文&#x27;)</th>
    </tr>
    <tr>
        <td>bill</td>
        <td>4</td>
        <td>中文</td>
        <td>2</td>
    </tr>
</table>



<h4 id="大小写转换-lower-upper"><a href="#大小写转换-lower-upper" class="headerlink" title="大小写转换 lower, upper:"></a>大小写转换 <code>lower</code>, <code>upper</code>:</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">%%sql</span><br><span class="line">select <span class="string">&#x27;bill&#x27;</span>, upper(<span class="string">&#x27;bill&#x27;</span>), <span class="string">&#x27;BILL&#x27;</span>, lower(<span class="string">&#x27;BILL&#x27;</span>)</span><br></pre></td></tr></table></figure>

<pre><code> * mysql+pymysql://root:***@localhost/test
1 rows affected.</code></pre>
<table>
    <tr>
        <th>bill</th>
        <th>upper(&#x27;bill&#x27;)</th>
        <th>BILL</th>
        <th>lower(&#x27;BILL&#x27;)</th>
    </tr>
    <tr>
        <td>bill</td>
        <td>BILL</td>
        <td>BILL</td>
        <td>bill</td>
    </tr>
</table>



<h4 id="字符串查找"><a href="#字符串查找" class="headerlink" title="字符串查找"></a>字符串查找</h4><ul>
<li><code>find_in_set(s1,s2)</code> 返回 s1 在 s2 中的位置, 只能用逗号<code>,</code>隔开.</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">%%sql</span><br><span class="line">select find_in_set(<span class="string">&#x27;bill&#x27;</span>, <span class="string">&#x27;bob, bill, jack,bill&#x27;</span>) <span class="keyword">as</span> <span class="string">&#x27;bill 的位置&#x27;</span></span><br></pre></td></tr></table></figure>

<pre><code> * mysql+pymysql://root:***@localhost/test
1 rows affected.</code></pre>
<table>
    <tr>
        <th>bill 的位置</th>
    </tr>
    <tr>
        <td>4</td>
    </tr>
</table>



<ul>
<li><code>field(s, s1, s2, ..., sn)</code> 返回第一个字符串 s 匹配的字符串的位置.</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">%%sql</span><br><span class="line">select field(<span class="string">&#x27;bill&#x27;</span>, <span class="string">&#x27;bob&#x27;</span>, <span class="string">&#x27;jack&#x27;</span>, <span class="string">&#x27;bill&#x27;</span>) <span class="string">&#x27;bill 的位置&#x27;</span></span><br></pre></td></tr></table></figure>

<pre><code> * mysql+pymysql://root:***@localhost/test
1 rows affected.</code></pre>
<table>
    <tr>
        <th>bill 的位置</th>
    </tr>
    <tr>
        <td>3</td>
    </tr>
</table>



<ul>
<li><code>locate(s1, s)</code>, <code>position(s1 in s)</code> 返回 s1 在 s 中开始的位置.</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">%%sql</span><br><span class="line">select locate(<span class="string">&#x27;bill&#x27;</span>, <span class="string">&#x27;bob jack bill&#x27;</span>)</span><br></pre></td></tr></table></figure>

<pre><code> * mysql+pymysql://root:***@localhost/test
1 rows affected.</code></pre>
<table>
    <tr>
        <th>locate(&#x27;bill&#x27;, &#x27;bob jack bill&#x27;)</th>
    </tr>
    <tr>
        <td>10</td>
    </tr>
</table>




<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">%%sql</span><br><span class="line">select position(<span class="string">&#x27;bill&#x27;</span> <span class="keyword">in</span> <span class="string">&#x27;bob jack bill&#x27;</span>)</span><br></pre></td></tr></table></figure>

<pre><code> * mysql+pymysql://root:***@localhost/test
1 rows affected.</code></pre>
<table>
    <tr>
        <th>position(&#x27;bill&#x27; in &#x27;bob jack bill&#x27;)</th>
    </tr>
    <tr>
        <td>10</td>
    </tr>
</table>



<h4 id="字符串截取子串"><a href="#字符串截取子串" class="headerlink" title="字符串截取子串"></a>字符串截取子串</h4><ul>
<li><code>left(str, n)</code> 获取字符串的前 n 个字符.</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">%%sql</span><br><span class="line">select left(<span class="string">&#x27;中bill文&#x27;</span>, <span class="number">2</span>)</span><br></pre></td></tr></table></figure>

<pre><code> * mysql+pymysql://root:***@localhost/test
1 rows affected.</code></pre>
<table>
    <tr>
        <th>left(&#x27;中bill文&#x27;, 2)</th>
    </tr>
    <tr>
        <td>中b</td>
    </tr>
</table>



<ul>
<li><code>right(str, n)</code> 获取字符串后 n 个字符.</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">%%sql</span><br><span class="line">select right(<span class="string">&#x27;中bill文&#x27;</span>, <span class="number">2</span>)</span><br></pre></td></tr></table></figure>

<pre><code> * mysql+pymysql://root:***@localhost/test
1 rows affected.</code></pre>
<table>
    <tr>
        <th>right(&#x27;中bill文&#x27;, 2)</th>
    </tr>
    <tr>
        <td>l文</td>
    </tr>
</table>



<ul>
<li><code>substring(str, m, n)</code> 获取字符串从 m 开始的 n 个字符.</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">%%sql</span><br><span class="line">select substring(<span class="string">&#x27;中bill文&#x27;</span>, <span class="number">2</span>, <span class="number">4</span>)</span><br></pre></td></tr></table></figure>

<pre><code> * mysql+pymysql://root:***@localhost/test
1 rows affected.</code></pre>
<table>
    <tr>
        <th>substring(&#x27;中bill文&#x27;, 2, 4)</th>
    </tr>
    <tr>
        <td>bill</td>
    </tr>
</table>



<h4 id="去除字符串的首尾空格"><a href="#去除字符串的首尾空格" class="headerlink" title="去除字符串的首尾空格"></a>去除字符串的首尾空格</h4><ul>
<li><code>ltrim()</code> 去除首空格, <code>rtrim()</code> 去除尾空格, <code>trim()</code> 去除两边空格.</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">%%sql</span><br><span class="line">select concat(ltrim(<span class="string">&#x27; bill &#x27;</span>), rtrim(<span class="string">&#x27;is_ &#x27;</span>), <span class="string">&#x27;a&#x27;</span>, trim(<span class="string">&#x27; _student &#x27;</span>)) bill</span><br></pre></td></tr></table></figure>

<pre><code> * mysql+pymysql://root:***@localhost/test
1 rows affected.</code></pre>
<table>
    <tr>
        <th>bill</th>
    </tr>
    <tr>
        <td>bill is_a_student</td>
    </tr>
</table>



<h4 id="替换字符串"><a href="#替换字符串" class="headerlink" title="替换字符串"></a>替换字符串</h4><ul>
<li><code>insert(str, m, n, newstr)</code> 将字符串 str 中, 位置从 m 起长度为 n 的子串替换为 newstr. m 超过字符串长度, 返回 str, n 大于 str 剩余长度, 从 m 开始替换, 任何参数为 null, 返回 null.</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">%%sql</span><br><span class="line">select <span class="string">&#x27;这是mysql数据库&#x27;</span> MySQL, insert(<span class="string">&#x27;这是mysqlL数据库&#x27;</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="string">&#x27;Oracle&#x27;</span>) 转为</span><br></pre></td></tr></table></figure>

<pre><code> * mysql+pymysql://root:***@localhost/test
1 rows affected.</code></pre>
<table>
    <tr>
        <th>MySQL</th>
        <th>转为</th>
    </tr>
    <tr>
        <td>这是mysql数据库</td>
        <td>这是OracleL数据库</td>
    </tr>
</table>




<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">%%sql</span><br><span class="line">select <span class="string">&#x27;这是mysql数据库&#x27;</span> MySQL, insert(<span class="string">&#x27;这是mysql数据库&#x27;</span>, <span class="number">3</span>, <span class="number">10</span>, <span class="string">&#x27;Oracle&#x27;</span>) 转为</span><br></pre></td></tr></table></figure>

<pre><code> * mysql+pymysql://root:***@localhost/test
1 rows affected.</code></pre>
<table>
    <tr>
        <th>MySQL</th>
        <th>转为</th>
    </tr>
    <tr>
        <td>这是mysql数据库</td>
        <td>这是Oracle</td>
    </tr>
</table>



<ul>
<li><code>replace(str, substr, newstr)</code> 用 newstr 替换 str 中的 substr.</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">%%sql</span><br><span class="line">select <span class="string">&#x27;这是mysql数据库&#x27;</span> mysql, replace(<span class="string">&#x27;这是mysql数据库&#x27;</span>, <span class="string">&#x27;mysql&#x27;</span>, <span class="string">&#x27;Oracle&#x27;</span>) Oracle</span><br></pre></td></tr></table></figure>

<pre><code> * mysql+pymysql://root:***@localhost/test
1 rows affected.</code></pre>
<table>
    <tr>
        <th>mysql</th>
        <th>Oracle</th>
    </tr>
    <tr>
        <td>这是mysql数据库</td>
        <td>这是Oracle数据库</td>
    </tr>
</table>



<h3 id="2-数值函数"><a href="#2-数值函数" class="headerlink" title="2, 数值函数"></a>2, 数值函数</h3><p><code>rand()</code> 返回 0~1 之间的随机数, <code>ceil(x)</code> 返回大于等于 x 的最小整数, <code>floor(x)</code> 返回小于等于 x 的最大整数.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">%%sql</span><br><span class="line">select rand(), ceil(<span class="number">3.14</span>), floor(<span class="number">3.14</span>)</span><br></pre></td></tr></table></figure>

<pre><code> * mysql+pymysql://root:***@localhost/test
1 rows affected.</code></pre>
<table>
    <tr>
        <th>rand()</th>
        <th>ceil(3.14)</th>
        <th>floor(3.14)</th>
    </tr>
    <tr>
        <td>0.806298252014721</td>
        <td>4</td>
        <td>3</td>
    </tr>
</table>



<p><code>truncate(x, y)</code> 返回 x 保留小数点后 y 位的数, <code>round(x)</code> 返回 x 四舍五入的整数, <code>round(x, y)</code> x 四舍五入保留小数点后 y 位.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">%%sql</span><br><span class="line">select truncate(<span class="number">3.14159</span>, <span class="number">4</span>), <span class="built_in">round</span>(<span class="number">3.1415</span>), <span class="built_in">round</span>(<span class="number">3.14159</span>, <span class="number">4</span>)</span><br></pre></td></tr></table></figure>

<pre><code> * mysql+pymysql://root:***@localhost/test
1 rows affected.</code></pre>
<table>
    <tr>
        <th>truncate(3.14159, 4)</th>
        <th>round(3.1415)</th>
        <th>round(3.14159, 4)</th>
    </tr>
    <tr>
        <td>3.1415</td>
        <td>3</td>
        <td>3.1416</td>
    </tr>
</table>



<h3 id="3-日期时间函数"><a href="#3-日期时间函数" class="headerlink" title="3, 日期时间函数"></a>3, 日期时间函数</h3><p><code>curdate()</code> 返回当前日期, <code>curtime()</code> 返回当前时间, <code>now()</code> 返回当前日期时间, <code>week(date)</code> 返回日期在一年的第几周, <code>year(date)</code> 返回日期所在年份, <code>hour(time)</code> 返回时间的小时数, <code>minute(time)</code> 返回时间的分钟数, <code>monthname(date)</code> 返回日期的月份名称. </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">%%sql</span><br><span class="line">select curdate() 日期, curtime() 时间, now() 当前</span><br></pre></td></tr></table></figure>

<pre><code> * mysql+pymysql://root:***@localhost/test
1 rows affected.</code></pre>
<table>
    <tr>
        <th>日期</th>
        <th>时间</th>
        <th>当前</th>
    </tr>
    <tr>
        <td>2020-05-18</td>
        <td>11:12:06</td>
        <td>2020-05-18 11:12:06</td>
    </tr>
</table>




<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">%%sql</span><br><span class="line">select week(<span class="string">&#x27;2020-05-18&#x27;</span>) w, </span><br><span class="line">    year(<span class="string">&#x27;2020-05-18&#x27;</span>) y, </span><br><span class="line">    hour(<span class="string">&#x27;10:57:19&#x27;</span>) h, </span><br><span class="line">    minute(<span class="string">&#x27;98-02-03 10:05:03&#x27;</span>) <span class="built_in">min</span>,</span><br><span class="line">    monthname(<span class="string">&#x27;98-02-05&#x27;</span>) m</span><br></pre></td></tr></table></figure>

<pre><code> * mysql+pymysql://root:***@localhost/test
1 rows affected.</code></pre>
<table>
    <tr>
        <th>w</th>
        <th>y</th>
        <th>h</th>
        <th>min</th>
        <th>m</th>
    </tr>
    <tr>
        <td>20</td>
        <td>2020</td>
        <td>10</td>
        <td>5</td>
        <td>February</td>
    </tr>
</table>



<h3 id="4-系统信息函数"><a href="#4-系统信息函数" class="headerlink" title="4, 系统信息函数"></a>4, 系统信息函数</h3><p><code>version()</code> 返回数据库版本号, <code>database()</code> 返回当前数据库名, <code>user()</code>返回当前用户名.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">%%sql</span><br><span class="line">select version() 版本, database() 数据库, user() 用户</span><br></pre></td></tr></table></figure>

<pre><code> * mysql+pymysql://root:***@localhost/test
1 rows affected.</code></pre>
<table>
    <tr>
        <th>版本</th>
        <th>数据库</th>
        <th>用户</th>
    </tr>
    <tr>
        <td>5.7.27-log</td>
        <td>test</td>
        <td>root@localhost</td>
    </tr>
</table>
]]></content>
      <categories>
        <category>数据分析</category>
      </categories>
      <tags>
        <tag>Mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>Mysql 索引，视图和三范式</title>
    <url>/data/mysql4-95ef69379b8e/</url>
    <content><![CDATA[<blockquote>
<p>文章主要内容和思路来源: <strong>开课吧</strong>学习笔记</p>
</blockquote>
<h2 id="五-索引"><a href="#五-索引" class="headerlink" title="五, 索引"></a>五, 索引</h2><p>(此知识点需要重新深入理顺逻辑)</p>
<h3 id="1-索引介绍"><a href="#1-索引介绍" class="headerlink" title="1, 索引介绍"></a>1, 索引介绍</h3><p>索引是存储引擎用于快速查找数据记录的一种数据结构, 而不必扫描整个数据库, 索引优化是查询性能优化非常有效的手段, 根据存储类型可以分为 B(B+) 树索引(innodb 引擎), 哈希索引(memory 引擎).</p>
<p>索引确保查询速度, 同时还能保证数据完整性, 通常主键, 唯一键, 联合键等有约束功能的字段就是索引, 还可以设置无约束的普通索引.</p>
<h3 id="2-普通索引的创建"><a href="#2-普通索引的创建" class="headerlink" title="2, 普通索引的创建"></a>2, 普通索引的创建</h3><p>无约束条件, 可以创建在任何字段上, 有三种方法创建索引.</p>
<p>建表时指定索引:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">create table 表名(</span><br><span class="line">    字段 数据类型 属性 ...,</span><br><span class="line">    ...,</span><br><span class="line">    index|key [索引名](字段, [(长度)] [asc|desc]));</span><br></pre></td></tr></table></figure>

<p>在表中指定字段作为索引:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">create index 索引名 on 表名 (字段 [(长度)] [asc|sesc]);</span><br></pre></td></tr></table></figure>

<p>修改表结构指定索引:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">alter table 表名 add index|key 索引名 (字段 [(长度)] [asc|desc])</span><br></pre></td></tr></table></figure>

<p>创建多列索引时, 上述语句中指定多个字段即可</p>
<p>创建唯一索引, 上述语句 index 前加上 unique</p>
<p>全文索引, 主要设置在数据量较大的字符串类型字段, 创建全文索引, 在上述语句 index 前加上 fulltext</p>
<h3 id="3-删除索引"><a href="#3-删除索引" class="headerlink" title="3, 删除索引"></a>3, 删除索引</h3><p>创建主键, 外键等自动创建索引, 删除键, 并没有删除索引.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">drop index 索引名 on 表名;</span><br></pre></td></tr></table></figure>

<br>

<h2 id="六-视图"><a href="#六-视图" class="headerlink" title="六, 视图"></a>六, 视图</h2><h3 id="1-视图介绍"><a href="#1-视图介绍" class="headerlink" title="1, 视图介绍"></a>1, 视图介绍</h3><p>视图是从数据库的基本表(可以是多个不同的表)中, 将某些有特定联系和特定需要的数据筛选出来联系在一起动态生成的虚拟表, 相当于查询语句得到的中间结果. </p>
<p>视图的建立和删除不影响基本表, 视图内容的更新(增删改)直接影响基本表, 但视图来自多个表时, 不允许添加和删除数据.</p>
<p>视图的作用:</p>
<p>a, 对需要重复查询的数据, 直接建立视图便可重复使用, 减少重复的甚至复杂的 sql 语句查询.</p>
<p>b, 如果数据库重构, 例如表拆分, 之前的脚本程序可能会受影响, 利用视图可以恢复脚本使用.</p>
<p>c, 可以对不同的用户设定不同的视图, 隐藏需要保密的信息, 提高数据安全性.</p>
<p>d, 把需要的数据, 创建相应的视图, 使数据更加清晰.</p>
<h3 id="2-视图的基本操作"><a href="#2-视图的基本操作" class="headerlink" title="2, 视图的基本操作"></a>2, 视图的基本操作</h3><p>视图不能和表名和其他视图重名, 视图是封装了查询语句中间表, 查询视图数据和查询表一样.</p>
<p>创建视图:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">create view 视图名 <span class="keyword">as</span> 查询语句;</span><br></pre></td></tr></table></figure>

<p>查看视图:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">show table status;  <span class="comment">#显示所有的表与视图</span></span><br><span class="line">show create view 视图名; <span class="comment"># 显示创建视图的语句</span></span><br><span class="line">desc 视图名; <span class="comment"># 显示视图结构</span></span><br></pre></td></tr></table></figure>

<p>删除视图:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">drop view 视图名;</span><br></pre></td></tr></table></figure>

<p>修改视图:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">create <span class="keyword">or</span> replace view 视图名 <span class="keyword">as</span> 查询语句;  <span class="comment"># 有视图就修改, 没有就创建</span></span><br><span class="line">alter view 视图名 <span class="keyword">as</span> 查询语句;</span><br><span class="line"><span class="comment"># 视图是虚表, 还可以删除视图重新创建.</span></span><br></pre></td></tr></table></figure>

<br>

<h2 id="七-数据库设计三范式"><a href="#七-数据库设计三范式" class="headerlink" title="七, 数据库设计三范式"></a>七, 数据库设计三范式</h2><p>设计关系型数据库, 遵从一定的规范要求, 越高的范式, 数据冗余越小, 但是会降低数据读写效率, 效率低, 又需要反范式.</p>
<p>第一范式(1NF): 原子性, 字段不可再分, 某个属性有多个值时, 必须拆分为不同属性, 也就是一个字段只存储一项信息. 关系型数据库, 自动满足第一范式.</p>
<p>第二范式(2NF): 在第一范式基础上建立. 有主键, 确保数据库表中的每一列都和主键相关，而不能只与主键的某一部分相关（主要针对联合主键而言）. 也就是说在一个数据库表中，一个表只能保存一种数据，不可以把多种数据保存在同一张数据库表中. 例如一张订单编号和商品编号为联合主键, 存储订单信息和商品信息的表, 就不满足第二范式.</p>
<p>第三范式(3NF): 必须先满足第二范式. 非主键字段不能相互依赖, 每一列与主键直接依赖, 不存在传递依赖. 例如一个订单信息表, 订单编号为主键, 可将客户编号作为外键与订单信息表建立联系.</p>
]]></content>
      <categories>
        <category>数据分析</category>
      </categories>
      <tags>
        <tag>Mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>Mysql 多表基础操作</title>
    <url>/data/mysql2-8fd5fec702bb/</url>
    <content><![CDATA[<blockquote>
<p>文章主要内容和思路来源: <strong>开课吧</strong>学习笔记</p>
</blockquote>
<h2 id="三-多表基础操作"><a href="#三-多表基础操作" class="headerlink" title="三, 多表基础操作"></a>三, 多表基础操作</h2><h3 id="1-1-多表介绍"><a href="#1-1-多表介绍" class="headerlink" title="1.1, 多表介绍"></a>1.1, 多表介绍</h3><p>一个项目的数据库, 储存很多信息, 通过多表, 实现数据的总览, 细分, 结构化, 减少冗余. 但又要通过一定的关系将表联系起来, 便于查询分析.</p>
<h3 id="1-2-多表关联"><a href="#1-2-多表关联" class="headerlink" title="1.2, 多表关联"></a>1.2, 多表关联</h3><h4 id="通过-id-关联"><a href="#通过-id-关联" class="headerlink" title="通过 id 关联"></a>通过 id 关联</h4><p>灵活, 高并发. 但数据完整性很难保证, 需要代码确保数据完整性, 加大代码量.</p>
<h4 id="通过外键关联"><a href="#通过外键关联" class="headerlink" title="通过外键关联"></a>通过外键关联</h4><p>a, 准备数据:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">%%sql</span><br><span class="line">create table dept(</span><br><span class="line">    deptno <span class="built_in">int</span> primary key comment <span class="string">&quot;部门编号&quot;</span>,</span><br><span class="line">    name varchar(<span class="number">20</span>) comment <span class="string">&quot;部门名称&quot;</span>,</span><br><span class="line">    loc varchar(<span class="number">40</span>) comment <span class="string">&quot;所在城市&quot;</span></span><br><span class="line">) charset=utf8;</span><br><span class="line"></span><br><span class="line">insert into dept values</span><br><span class="line">    (<span class="number">10</span>, <span class="string">&quot;accounting&quot;</span>, <span class="string">&quot;new_york&quot;</span>),</span><br><span class="line">    (<span class="number">20</span>, <span class="string">&quot;research&quot;</span>, <span class="string">&quot;dalas&quot;</span>),</span><br><span class="line">    (<span class="number">30</span>, <span class="string">&quot;sales&quot;</span>, <span class="string">&quot;beijing&quot;</span>),</span><br><span class="line">    (<span class="number">40</span>, <span class="string">&quot;financial&quot;</span>, <span class="string">&quot;shanghai&quot;</span>);</span><br><span class="line"></span><br><span class="line">select * <span class="keyword">from</span> dept;</span><br></pre></td></tr></table></figure>

<pre><code> * mysql+pymysql://root:***@localhost/test
0 rows affected.
4 rows affected.
4 rows affected.</code></pre>
<table>
    <tr>
        <th>deptno</th>
        <th>name</th>
        <th>loc</th>
    </tr>
    <tr>
        <td>10</td>
        <td>accounting</td>
        <td>new_york</td>
    </tr>
    <tr>
        <td>20</td>
        <td>research</td>
        <td>dalas</td>
    </tr>
    <tr>
        <td>30</td>
        <td>sales</td>
        <td>beijing</td>
    </tr>
    <tr>
        <td>40</td>
        <td>financial</td>
        <td>shanghai</td>
    </tr>
</table>



<br>

<p>b, 设置外键(父表需要先有主键)</p>
<p>第一种方法, 建表时在字段后指定外键:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">constraint 外键名 foreign key(字段) references 父表名(字段) on delete <span class="built_in">set</span> null on update <span class="built_in">set</span> null</span><br></pre></td></tr></table></figure>

<p>第二种方法, 建表后再添加:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">alter table 子表名 add constraint 外键名 foreign key(字段) references 父表名(字段) on delete <span class="built_in">set</span> null on update <span class="built_in">set</span> null;</span><br></pre></td></tr></table></figure>


<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">%%sql</span><br><span class="line">alter table employee add constraint em_fk foreign key(deptno) references dept(deptno) on delete <span class="built_in">set</span> null on update <span class="built_in">set</span> null;</span><br></pre></td></tr></table></figure>

<pre><code> * mysql+pymysql://root:***@localhost/test
14 rows affected.

[]</code></pre>
<br>

<p>c, 外键的几种模式</p>
<p>如果子表试图创建一个在父表中不存在的外键值，InnoDB 会拒绝任何 INSERT 或 UPDATE 操作. 如果父表试图 UPDATE 或者 DELETE 任何子表中存在或匹配的外键值，最终动作取决于外键约束定义中的 ON UPDATE 和 ON DELETE 选项. 如果没有指定 ON DELETE 或者 ON UPDATE，默认的动作为 RESTRICT.</p>
<ul>
<li><p><code>set null</code> 从父表中删除或更新对应的行，同时将子表中的匹配外键列设为空. 注意，这些在外键列没有被设为 NOT NULL 时才有效.</p>
</li>
<li><p><code>cascade</code> 从父表中删除或更新对应的行，同时自动的删除或更新子表中匹配的行.</p>
</li>
<li><p><code>restrict</code> 和 <code>no action</code>, 如果子表中有匹配的记录, 拒绝删除或者更新父表.</p>
</li>
</ul>
<p>多表关联必须保证数据一致性, 并发要求不高, 优先选外键, 数据量过大(百万以上)用外键.</p>
<br>

<h3 id="1-3-并集-union"><a href="#1-3-并集-union" class="headerlink" title="1.3, 并集(union)"></a>1.3, 并集(union)</h3><p>用于把来自多个 select 语句的结果组合到一个结果中, 也叫联合查询.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">select ...</span><br><span class="line">union [<span class="built_in">all</span> | distinct]</span><br><span class="line">select ...</span><br><span class="line">[union [<span class="built_in">all</span> | distinct]</span><br><span class="line">select ...];</span><br></pre></td></tr></table></figure>

<p>在多个 select 语句中, 第一个 select 语句中被使用的字段名将被用做结果的字段名.</p>
<p>使用union 时, 会删除重复记录, 而 union all 会保留所有记录, 且效率高于 union.</p>
<p>只要求每个 select 查询的字段数量一样, 类型无关.</p>
<p>当使用 order by 时, 需要对 select 语句添加括号, 且与 limit 结合才生效.</p>
<p>准备数据:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">%%sql</span><br><span class="line">create table student (</span><br><span class="line">    <span class="built_in">id</span> <span class="built_in">int</span>(<span class="number">11</span>),</span><br><span class="line">    name varchar(<span class="number">10</span>),</span><br><span class="line">    age tinyint(<span class="number">4</span>),</span><br><span class="line">    classID <span class="built_in">int</span>(<span class="number">11</span>),</span><br><span class="line">    primary key(<span class="built_in">id</span>)</span><br><span class="line">) charset=utf8;</span><br><span class="line"></span><br><span class="line">insert into student values </span><br><span class="line">    (<span class="number">1</span>, <span class="string">&#x27;s1&#x27;</span>, <span class="number">20</span>, <span class="number">1</span>),</span><br><span class="line">    (<span class="number">2</span>, <span class="string">&#x27;s4&#x27;</span>, <span class="number">22</span>, <span class="number">1</span>),</span><br><span class="line">    (<span class="number">3</span>, <span class="string">&#x27;s5&#x27;</span>, <span class="number">22</span>, <span class="number">3</span>),</span><br><span class="line">    (<span class="number">4</span>, <span class="string">&#x27;s7&#x27;</span>, <span class="number">25</span>, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">select * <span class="keyword">from</span> student;</span><br></pre></td></tr></table></figure>

<pre><code> * mysql+pymysql://root:***@localhost/test
0 rows affected.
4 rows affected.
4 rows affected.</code></pre>
<table>
    <tr>
        <th>id</th>
        <th>name</th>
        <th>age</th>
        <th>classID</th>
    </tr>
    <tr>
        <td>1</td>
        <td>s1</td>
        <td>20</td>
        <td>1</td>
    </tr>
    <tr>
        <td>2</td>
        <td>s4</td>
        <td>22</td>
        <td>1</td>
    </tr>
    <tr>
        <td>3</td>
        <td>s5</td>
        <td>22</td>
        <td>3</td>
    </tr>
    <tr>
        <td>4</td>
        <td>s7</td>
        <td>25</td>
        <td>2</td>
    </tr>
</table>




<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">%%sql    </span><br><span class="line">create table teacher (</span><br><span class="line">    <span class="built_in">id</span> <span class="built_in">int</span>(<span class="number">11</span>),</span><br><span class="line">    name varchar(<span class="number">4</span>),</span><br><span class="line">    age tinyint(<span class="number">4</span>),</span><br><span class="line">    primary key(<span class="built_in">id</span>)</span><br><span class="line">) charset=utf8;</span><br><span class="line"></span><br><span class="line">insert into teacher values</span><br><span class="line">    (<span class="number">1</span>, <span class="string">&#x27;t1&#x27;</span>, <span class="number">36</span>),</span><br><span class="line">    (<span class="number">2</span>, <span class="string">&#x27;t2&#x27;</span>, <span class="number">33</span>),</span><br><span class="line">    (<span class="number">3</span>, <span class="string">&#x27;t3&#x27;</span>, <span class="number">30</span>);</span><br><span class="line">    </span><br><span class="line">select * <span class="keyword">from</span> teacher;</span><br></pre></td></tr></table></figure>

<pre><code> * mysql+pymysql://root:***@localhost/test
0 rows affected.
3 rows affected.
3 rows affected.</code></pre>
<table>
    <tr>
        <th>id</th>
        <th>name</th>
        <th>age</th>
    </tr>
    <tr>
        <td>1</td>
        <td>t1</td>
        <td>36</td>
    </tr>
    <tr>
        <td>2</td>
        <td>t2</td>
        <td>33</td>
    </tr>
    <tr>
        <td>3</td>
        <td>t3</td>
        <td>30</td>
    </tr>
</table>



<br>

<p>student 和 teacher 并集:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">%%sql</span><br><span class="line">select <span class="built_in">id</span>, name, age <span class="keyword">from</span> student</span><br><span class="line">union <span class="built_in">all</span></span><br><span class="line">select age, <span class="built_in">id</span>, name <span class="keyword">from</span> teacher;</span><br></pre></td></tr></table></figure>

<pre><code> * mysql+pymysql://root:***@localhost/test
7 rows affected.</code></pre>
<table>
    <tr>
        <th>id</th>
        <th>name</th>
        <th>age</th>
    </tr>
    <tr>
        <td>1</td>
        <td>s1</td>
        <td>20</td>
    </tr>
    <tr>
        <td>2</td>
        <td>s4</td>
        <td>22</td>
    </tr>
    <tr>
        <td>3</td>
        <td>s5</td>
        <td>22</td>
    </tr>
    <tr>
        <td>4</td>
        <td>s7</td>
        <td>25</td>
    </tr>
    <tr>
        <td>36</td>
        <td>1</td>
        <td>t1</td>
    </tr>
    <tr>
        <td>33</td>
        <td>2</td>
        <td>t2</td>
    </tr>
    <tr>
        <td>30</td>
        <td>3</td>
        <td>t3</td>
    </tr>
</table>



<br>

<h3 id="1-4-笛卡尔积"><a href="#1-4-笛卡尔积" class="headerlink" title="1.4, 笛卡尔积"></a>1.4, 笛卡尔积</h3><p>多表查询的笛卡尔积: 表一中的每一条记录, 与表二中的所有记录匹配完.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">%%sql</span><br><span class="line">select * <span class="keyword">from</span> student, teacher;</span><br></pre></td></tr></table></figure>

<pre><code> * mysql+pymysql://root:***@localhost/test
12 rows affected.</code></pre>
<table>
    <tr>
        <th>id</th>
        <th>name</th>
        <th>age</th>
        <th>classID</th>
        <th>id_1</th>
        <th>name_1</th>
        <th>age_1</th>
    </tr>
    <tr>
        <td>1</td>
        <td>s1</td>
        <td>20</td>
        <td>1</td>
        <td>1</td>
        <td>t1</td>
        <td>36</td>
    </tr>
    <tr>
        <td>1</td>
        <td>s1</td>
        <td>20</td>
        <td>1</td>
        <td>2</td>
        <td>t2</td>
        <td>33</td>
    </tr>
    <tr>
        <td>1</td>
        <td>s1</td>
        <td>20</td>
        <td>1</td>
        <td>3</td>
        <td>t3</td>
        <td>30</td>
    </tr>
    <tr>
        <td>2</td>
        <td>s4</td>
        <td>22</td>
        <td>1</td>
        <td>1</td>
        <td>t1</td>
        <td>36</td>
    </tr>
    <tr>
        <td>2</td>
        <td>s4</td>
        <td>22</td>
        <td>1</td>
        <td>2</td>
        <td>t2</td>
        <td>33</td>
    </tr>
    <tr>
        <td>2</td>
        <td>s4</td>
        <td>22</td>
        <td>1</td>
        <td>3</td>
        <td>t3</td>
        <td>30</td>
    </tr>
    <tr>
        <td>3</td>
        <td>s5</td>
        <td>22</td>
        <td>3</td>
        <td>1</td>
        <td>t1</td>
        <td>36</td>
    </tr>
    <tr>
        <td>3</td>
        <td>s5</td>
        <td>22</td>
        <td>3</td>
        <td>2</td>
        <td>t2</td>
        <td>33</td>
    </tr>
    <tr>
        <td>3</td>
        <td>s5</td>
        <td>22</td>
        <td>3</td>
        <td>3</td>
        <td>t3</td>
        <td>30</td>
    </tr>
    <tr>
        <td>4</td>
        <td>s7</td>
        <td>25</td>
        <td>2</td>
        <td>1</td>
        <td>t1</td>
        <td>36</td>
    </tr>
    <tr>
        <td>4</td>
        <td>s7</td>
        <td>25</td>
        <td>2</td>
        <td>2</td>
        <td>t2</td>
        <td>33</td>
    </tr>
    <tr>
        <td>4</td>
        <td>s7</td>
        <td>25</td>
        <td>2</td>
        <td>3</td>
        <td>t3</td>
        <td>30</td>
    </tr>
</table>



<p>一般先确定要用到哪些表, 再进行笛卡儿积, 然后去除不符合逻辑的数据, 最后加上条件查询.</p>
<br>

<h3 id="1-5-内连接"><a href="#1-5-内连接" class="headerlink" title="1.5, 内连接"></a>1.5, 内连接</h3><p>在表关系的笛卡尔积数据中, 保留匹配的数据记录, 舍弃不匹配的.</p>
<p>语句:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">select 字段<span class="number">1</span>, ... 字段n <span class="keyword">from</span> 表<span class="number">1</span> inner join 表<span class="number">2</span> on 条件 ... inner join 表n on 条件;</span><br><span class="line"><span class="comment"># inner 可以省略</span></span><br></pre></td></tr></table></figure>

<p>查询两个表部门相同的人:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">%%sql</span><br><span class="line">select dept.deptno, employee.name, dept.name </span><br><span class="line"><span class="keyword">from</span> employee join dept </span><br><span class="line">    on employee.deptno = dept.deptno;</span><br></pre></td></tr></table></figure>

<pre><code> * mysql+pymysql://root:***@localhost/test
14 rows affected.</code></pre>
<table>
    <tr>
        <th>deptno</th>
        <th>name</th>
        <th>name_1</th>
    </tr>
    <tr>
        <td>10</td>
        <td>clark</td>
        <td>accounting</td>
    </tr>
    <tr>
        <td>10</td>
        <td>king</td>
        <td>accounting</td>
    </tr>
    <tr>
        <td>10</td>
        <td>miller</td>
        <td>accounting</td>
    </tr>
    <tr>
        <td>20</td>
        <td>smith</td>
        <td>research</td>
    </tr>
    <tr>
        <td>20</td>
        <td>jones</td>
        <td>research</td>
    </tr>
    <tr>
        <td>20</td>
        <td>scott</td>
        <td>research</td>
    </tr>
    <tr>
        <td>20</td>
        <td>adams</td>
        <td>research</td>
    </tr>
    <tr>
        <td>20</td>
        <td>ford</td>
        <td>research</td>
    </tr>
    <tr>
        <td>30</td>
        <td>allen</td>
        <td>sales</td>
    </tr>
    <tr>
        <td>30</td>
        <td>ward</td>
        <td>sales</td>
    </tr>
    <tr>
        <td>30</td>
        <td>martin</td>
        <td>sales</td>
    </tr>
    <tr>
        <td>30</td>
        <td>blake</td>
        <td>sales</td>
    </tr>
    <tr>
        <td>30</td>
        <td>turner</td>
        <td>sales</td>
    </tr>
    <tr>
        <td>30</td>
        <td>james</td>
        <td>sales</td>
    </tr>
</table>



<p>字段名相同, 可以将 on 语句换成 using(depton).</p>
<br>

<p>查询同一张表的员工上下级关系(后者是前者的上级):</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">%%sql</span><br><span class="line">select f.no, f.mgr, j.mgr </span><br><span class="line"><span class="keyword">from</span> employee f, employee j </span><br><span class="line">    where f.mgr=j.no;</span><br></pre></td></tr></table></figure>

<pre><code> * mysql+pymysql://root:***@localhost/test
13 rows affected.</code></pre>
<table>
    <tr>
        <th>no</th>
        <th>mgr</th>
        <th>mgr_1</th>
    </tr>
    <tr>
        <td>7788</td>
        <td>7566</td>
        <td>7839</td>
    </tr>
    <tr>
        <td>7902</td>
        <td>7566</td>
        <td>7839</td>
    </tr>
    <tr>
        <td>7499</td>
        <td>7698</td>
        <td>7839</td>
    </tr>
    <tr>
        <td>7521</td>
        <td>7698</td>
        <td>7839</td>
    </tr>
    <tr>
        <td>7654</td>
        <td>7698</td>
        <td>7839</td>
    </tr>
    <tr>
        <td>7844</td>
        <td>7698</td>
        <td>7839</td>
    </tr>
    <tr>
        <td>7900</td>
        <td>7698</td>
        <td>7839</td>
    </tr>
    <tr>
        <td>7934</td>
        <td>7782</td>
        <td>7839</td>
    </tr>
    <tr>
        <td>7876</td>
        <td>7788</td>
        <td>7566</td>
    </tr>
    <tr>
        <td>7566</td>
        <td>7839</td>
        <td>None</td>
    </tr>
    <tr>
        <td>7698</td>
        <td>7839</td>
        <td>None</td>
    </tr>
    <tr>
        <td>7782</td>
        <td>7839</td>
        <td>None</td>
    </tr>
    <tr>
        <td>7369</td>
        <td>7902</td>
        <td>7566</td>
    </tr>
</table>




<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">%%sql</span><br><span class="line">select f.no, f.mgr, j.mgr </span><br><span class="line"><span class="keyword">from</span> employee f join employee j </span><br><span class="line">    on f.mgr=j.no;</span><br></pre></td></tr></table></figure>

<pre><code> * mysql+pymysql://root:***@localhost/test
13 rows affected.</code></pre>
<table>
    <tr>
        <th>no</th>
        <th>mgr</th>
        <th>mgr_1</th>
    </tr>
    <tr>
        <td>7788</td>
        <td>7566</td>
        <td>7839</td>
    </tr>
    <tr>
        <td>7902</td>
        <td>7566</td>
        <td>7839</td>
    </tr>
    <tr>
        <td>7499</td>
        <td>7698</td>
        <td>7839</td>
    </tr>
    <tr>
        <td>7521</td>
        <td>7698</td>
        <td>7839</td>
    </tr>
    <tr>
        <td>7654</td>
        <td>7698</td>
        <td>7839</td>
    </tr>
    <tr>
        <td>7844</td>
        <td>7698</td>
        <td>7839</td>
    </tr>
    <tr>
        <td>7900</td>
        <td>7698</td>
        <td>7839</td>
    </tr>
    <tr>
        <td>7934</td>
        <td>7782</td>
        <td>7839</td>
    </tr>
    <tr>
        <td>7876</td>
        <td>7788</td>
        <td>7566</td>
    </tr>
    <tr>
        <td>7566</td>
        <td>7839</td>
        <td>None</td>
    </tr>
    <tr>
        <td>7698</td>
        <td>7839</td>
        <td>None</td>
    </tr>
    <tr>
        <td>7782</td>
        <td>7839</td>
        <td>None</td>
    </tr>
    <tr>
        <td>7369</td>
        <td>7902</td>
        <td>7566</td>
    </tr>
</table>




<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">%%sql</span><br><span class="line">select f.no, f.mgr, j.mgr, k.mgr </span><br><span class="line"><span class="keyword">from</span> employee f join employee j on f.mgr = j.no</span><br><span class="line">    join employee k on j.mgr = k.no;</span><br></pre></td></tr></table></figure>

<pre><code> * mysql+pymysql://root:***@localhost/test
10 rows affected.</code></pre>
<table>
    <tr>
        <th>no</th>
        <th>mgr</th>
        <th>mgr_1</th>
        <th>mgr_2</th>
    </tr>
    <tr>
        <td>7876</td>
        <td>7788</td>
        <td>7566</td>
        <td>7839</td>
    </tr>
    <tr>
        <td>7369</td>
        <td>7902</td>
        <td>7566</td>
        <td>7839</td>
    </tr>
    <tr>
        <td>7788</td>
        <td>7566</td>
        <td>7839</td>
        <td>None</td>
    </tr>
    <tr>
        <td>7902</td>
        <td>7566</td>
        <td>7839</td>
        <td>None</td>
    </tr>
    <tr>
        <td>7499</td>
        <td>7698</td>
        <td>7839</td>
        <td>None</td>
    </tr>
    <tr>
        <td>7521</td>
        <td>7698</td>
        <td>7839</td>
        <td>None</td>
    </tr>
    <tr>
        <td>7654</td>
        <td>7698</td>
        <td>7839</td>
        <td>None</td>
    </tr>
    <tr>
        <td>7844</td>
        <td>7698</td>
        <td>7839</td>
        <td>None</td>
    </tr>
    <tr>
        <td>7900</td>
        <td>7698</td>
        <td>7839</td>
        <td>None</td>
    </tr>
    <tr>
        <td>7934</td>
        <td>7782</td>
        <td>7839</td>
        <td>None</td>
    </tr>
</table>



<br>

<h3 id="1-6-外连接"><a href="#1-6-外连接" class="headerlink" title="1.6, 外连接"></a>1.6, 外连接</h3><p>外连接分 左连接 和 右连接:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">select 字段<span class="number">1</span>, ... 字段n <span class="keyword">from</span> 表<span class="number">1</span> [left|right] [outer] join 表<span class="number">2</span> on 条件;</span><br><span class="line"><span class="comment"># outer 可以省略</span></span><br></pre></td></tr></table></figure>

<p>左连接查看员工所在的部门和城市:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">%%sql</span><br><span class="line">select e.name, d.name <span class="string">&#x27;部门&#x27;</span>, d.loc </span><br><span class="line"><span class="keyword">from</span> employee e left join dept d </span><br><span class="line">    using(deptno);</span><br></pre></td></tr></table></figure>

<pre><code> * mysql+pymysql://root:***@localhost/test
14 rows affected.</code></pre>
<table>
    <tr>
        <th>name</th>
        <th>部门</th>
        <th>loc</th>
    </tr>
    <tr>
        <td>clark</td>
        <td>accounting</td>
        <td>new_york</td>
    </tr>
    <tr>
        <td>king</td>
        <td>accounting</td>
        <td>new_york</td>
    </tr>
    <tr>
        <td>miller</td>
        <td>accounting</td>
        <td>new_york</td>
    </tr>
    <tr>
        <td>smith</td>
        <td>research</td>
        <td>dalas</td>
    </tr>
    <tr>
        <td>jones</td>
        <td>research</td>
        <td>dalas</td>
    </tr>
    <tr>
        <td>scott</td>
        <td>research</td>
        <td>dalas</td>
    </tr>
    <tr>
        <td>adams</td>
        <td>research</td>
        <td>dalas</td>
    </tr>
    <tr>
        <td>ford</td>
        <td>research</td>
        <td>dalas</td>
    </tr>
    <tr>
        <td>allen</td>
        <td>sales</td>
        <td>beijing</td>
    </tr>
    <tr>
        <td>ward</td>
        <td>sales</td>
        <td>beijing</td>
    </tr>
    <tr>
        <td>martin</td>
        <td>sales</td>
        <td>beijing</td>
    </tr>
    <tr>
        <td>blake</td>
        <td>sales</td>
        <td>beijing</td>
    </tr>
    <tr>
        <td>turner</td>
        <td>sales</td>
        <td>beijing</td>
    </tr>
    <tr>
        <td>james</td>
        <td>sales</td>
        <td>beijing</td>
    </tr>
</table>



<br>

<p>右连接以右边的表来匹配下属:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">%%sql</span><br><span class="line">select f.no, f.mgr, j.mgr </span><br><span class="line"><span class="keyword">from</span> employee f right join employee j </span><br><span class="line">    on f.mgr = j.no;</span><br></pre></td></tr></table></figure>

<pre><code> * mysql+pymysql://root:***@localhost/test
21 rows affected.</code></pre>
<table>
    <tr>
        <th>no</th>
        <th>mgr</th>
        <th>mgr_1</th>
    </tr>
    <tr>
        <td>7369</td>
        <td>7902</td>
        <td>7566</td>
    </tr>
    <tr>
        <td>7499</td>
        <td>7698</td>
        <td>7839</td>
    </tr>
    <tr>
        <td>7521</td>
        <td>7698</td>
        <td>7839</td>
    </tr>
    <tr>
        <td>7566</td>
        <td>7839</td>
        <td>None</td>
    </tr>
    <tr>
        <td>7654</td>
        <td>7698</td>
        <td>7839</td>
    </tr>
    <tr>
        <td>7698</td>
        <td>7839</td>
        <td>None</td>
    </tr>
    <tr>
        <td>7782</td>
        <td>7839</td>
        <td>None</td>
    </tr>
    <tr>
        <td>7788</td>
        <td>7566</td>
        <td>7839</td>
    </tr>
    <tr>
        <td>7844</td>
        <td>7698</td>
        <td>7839</td>
    </tr>
    <tr>
        <td>7876</td>
        <td>7788</td>
        <td>7566</td>
    </tr>
    <tr>
        <td>7900</td>
        <td>7698</td>
        <td>7839</td>
    </tr>
    <tr>
        <td>7902</td>
        <td>7566</td>
        <td>7839</td>
    </tr>
    <tr>
        <td>7934</td>
        <td>7782</td>
        <td>7839</td>
    </tr>
    <tr>
        <td>None</td>
        <td>None</td>
        <td>7902</td>
    </tr>
    <tr>
        <td>None</td>
        <td>None</td>
        <td>7698</td>
    </tr>
    <tr>
        <td>None</td>
        <td>None</td>
        <td>7698</td>
    </tr>
    <tr>
        <td>None</td>
        <td>None</td>
        <td>7698</td>
    </tr>
    <tr>
        <td>None</td>
        <td>None</td>
        <td>7698</td>
    </tr>
    <tr>
        <td>None</td>
        <td>None</td>
        <td>7788</td>
    </tr>
    <tr>
        <td>None</td>
        <td>None</td>
        <td>7698</td>
    </tr>
    <tr>
        <td>None</td>
        <td>None</td>
        <td>7782</td>
    </tr>
</table>



<br>

<h3 id="1-7-join连接图解"><a href="#1-7-join连接图解" class="headerlink" title="1.7, join连接图解"></a>1.7, join连接图解</h3><p><img src="/images/join.jpg"></p>
<p>对于所有连接类型而言, 就是将符合 on 后条件匹配的对应组合都放到结果中, 可能存在 一对多 或 多对一 的情况, 则在结果中形成多条记录.</p>
<p>内连接查询到的是 on 条件匹配的两个表中都存在的记录.</p>
<br>

<h3 id="1-8-子查询"><a href="#1-8-子查询" class="headerlink" title="1.8, 子查询"></a>1.8, 子查询</h3><p>select 语句嵌套在另一个 SQL 语句中, 那么该 select 语句称为子查询, 用 () 包围.</p>
<h4 id="单行单列和单行多列子查询"><a href="#单行单列和单行多列子查询" class="headerlink" title="单行单列和单行多列子查询"></a>单行单列和单行多列子查询</h4><p>当子查询返回的结果为单行单列时, 通常包含运算符.</p>
<p>单行单列子查询, 查询工资比 Smith 高的雇员:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">%%sql</span><br><span class="line">select name <span class="keyword">from</span> employee where sal &gt; (</span><br><span class="line">    select sal <span class="keyword">from</span> employee where name = <span class="string">&#x27;smith&#x27;</span>);</span><br></pre></td></tr></table></figure>

<pre><code> * mysql+pymysql://root:***@localhost/test
13 rows affected.</code></pre>
<table>
    <tr>
        <th>name</th>
    </tr>
    <tr>
        <td>allen</td>
    </tr>
    <tr>
        <td>ward</td>
    </tr>
    <tr>
        <td>jones</td>
    </tr>
    <tr>
        <td>martin</td>
    </tr>
    <tr>
        <td>blake</td>
    </tr>
    <tr>
        <td>clark</td>
    </tr>
    <tr>
        <td>scott</td>
    </tr>
    <tr>
        <td>king</td>
    </tr>
    <tr>
        <td>turner</td>
    </tr>
    <tr>
        <td>adams</td>
    </tr>
    <tr>
        <td>james</td>
    </tr>
    <tr>
        <td>ford</td>
    </tr>
    <tr>
        <td>miller</td>
    </tr>
</table>




<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">单行多列子查询, 查询工资和职位与 ward 一样的雇员:</span><br></pre></td></tr></table></figure>


<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">%%sql</span><br><span class="line">select name, sal, job <span class="keyword">from</span> employee where (sal, job) = (</span><br><span class="line">    select sal, job <span class="keyword">from</span> employee where name = <span class="string">&#x27;ward&#x27;</span>);</span><br></pre></td></tr></table></figure>

<pre><code> * mysql+pymysql://root:***@localhost/test
2 rows affected.</code></pre>
<table>
    <tr>
        <th>name</th>
        <th>sal</th>
        <th>job</th>
    </tr>
    <tr>
        <td>ward</td>
        <td>1250.0</td>
        <td>salesman</td>
    </tr>
    <tr>
        <td>martin</td>
        <td>1250.0</td>
        <td>salesman</td>
    </tr>
</table>



<br>

<h4 id="多行单列子查询"><a href="#多行单列子查询" class="headerlink" title="多行单列子查询"></a>多行单列子查询</h4><p>当查询结果为多行单列, 通常包含 in, any, all, exists 等关键字.</p>
<p><code>in</code> 关键字, 主查询的条件为: 判断是否在子查询的结果中, 子查询只能有一个字段, <code>in</code> 把内外表作了hash 连接. </p>
<p>查询部门编号是 30 的雇员:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">%%sql</span><br><span class="line">select name, deptno <span class="keyword">from</span> employee where deptno <span class="keyword">not</span> <span class="keyword">in</span> (</span><br><span class="line">    select deptno <span class="keyword">from</span> dept where deptno != <span class="number">30</span>);</span><br></pre></td></tr></table></figure>

<pre><code> * mysql+pymysql://root:***@localhost/test
6 rows affected.</code></pre>
<table>
    <tr>
        <th>name</th>
        <th>deptno</th>
    </tr>
    <tr>
        <td>allen</td>
        <td>30</td>
    </tr>
    <tr>
        <td>ward</td>
        <td>30</td>
    </tr>
    <tr>
        <td>martin</td>
        <td>30</td>
    </tr>
    <tr>
        <td>blake</td>
        <td>30</td>
    </tr>
    <tr>
        <td>turner</td>
        <td>30</td>
    </tr>
    <tr>
        <td>james</td>
        <td>30</td>
    </tr>
</table>



<p><code>any</code> 关键字, 主查询的条件为: 和任意子查询结果比较. <code>= any</code>, 和 <code>in</code> 一样, <code>&gt; any</code>, 比子查询结果中最小的大, <code>&lt; any</code>, 比子查询结果中最大的小.</p>
<p>查询工资比职位 manager 最低工资高的所有雇员及其工资:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">%%sql</span><br><span class="line">select name, sal <span class="keyword">from</span> employee where sal &gt; <span class="built_in">any</span> (</span><br><span class="line">    select sal <span class="keyword">from</span> employee where job = <span class="string">&#x27;manager&#x27;</span>);</span><br></pre></td></tr></table></figure>

<pre><code> * mysql+pymysql://root:***@localhost/test
5 rows affected.</code></pre>
<table>
    <tr>
        <th>name</th>
        <th>sal</th>
    </tr>
    <tr>
        <td>jones</td>
        <td>2975.0</td>
    </tr>
    <tr>
        <td>blake</td>
        <td>2850.0</td>
    </tr>
    <tr>
        <td>scott</td>
        <td>3000.0</td>
    </tr>
    <tr>
        <td>king</td>
        <td>5000.0</td>
    </tr>
    <tr>
        <td>ford</td>
        <td>3000.0</td>
    </tr>
</table>



<p><code>all</code> 关键字, 主查询的条件为: 和所有子查询结果比较.</p>
<p>查询工资高于职位 manager 工资的雇员及工资.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">%%sql</span><br><span class="line">select name, sal <span class="keyword">from</span> employee where sal &gt; <span class="built_in">all</span> (</span><br><span class="line">    select sal <span class="keyword">from</span> employee where job = <span class="string">&#x27;manager&#x27;</span>);</span><br></pre></td></tr></table></figure>

<pre><code> * mysql+pymysql://root:***@localhost/test
3 rows affected.</code></pre>
<table>
    <tr>
        <th>name</th>
        <th>sal</th>
    </tr>
    <tr>
        <td>scott</td>
        <td>3000.0</td>
    </tr>
    <tr>
        <td>king</td>
        <td>5000.0</td>
    </tr>
    <tr>
        <td>ford</td>
        <td>3000.0</td>
    </tr>
</table>



<br>

<h4 id="exists-子查询"><a href="#exists-子查询" class="headerlink" title="exists 子查询"></a>exists 子查询</h4><p><code>exists</code> 关键字, 主查询条件为: 循环外表, 判断是否满足子查询关联结果, <code>exists</code> 前面不能有字段, 而是对外表作 loop 循环, 需要在子查询中 ‘连接’ 外表.</p>
<p>查询所有有员工的部门.<br>需要内表的 deptno 与外表的 deptno ‘连接’, 子查询的字段对最终结果无影响:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">%%sql</span><br><span class="line">select name <span class="string">&#x27;部门&#x27;</span> <span class="keyword">from</span> dept where exists (</span><br><span class="line">    select * <span class="keyword">from</span> employee where deptno = dept.deptno);</span><br></pre></td></tr></table></figure>

<pre><code> * mysql+pymysql://root:***@localhost/test
3 rows affected.</code></pre>
<table>
    <tr>
        <th>部门</th>
    </tr>
    <tr>
        <td>accounting</td>
    </tr>
    <tr>
        <td>research</td>
    </tr>
    <tr>
        <td>sales</td>
    </tr>
</table>




<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">%%sql</span><br><span class="line">select name <span class="string">&#x27;部门&#x27;</span> <span class="keyword">from</span> dept where exists (</span><br><span class="line">    select deptno <span class="keyword">from</span> employee where deptno = dept.deptno);</span><br></pre></td></tr></table></figure>

<pre><code> * mysql+pymysql://root:***@localhost/test
3 rows affected.</code></pre>
<table>
    <tr>
        <th>部门</th>
    </tr>
    <tr>
        <td>accounting</td>
    </tr>
    <tr>
        <td>research</td>
    </tr>
    <tr>
        <td>sales</td>
    </tr>
</table>




<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">%%sql</span><br><span class="line">select name <span class="string">&#x27;部门&#x27;</span> <span class="keyword">from</span> dept where exists (</span><br><span class="line">    select loc <span class="keyword">from</span> employee where deptno = dept.deptno);</span><br></pre></td></tr></table></figure>

<pre><code> * mysql+pymysql://root:***@localhost/test
3 rows affected.</code></pre>
<table>
    <tr>
        <th>部门</th>
    </tr>
    <tr>
        <td>accounting</td>
    </tr>
    <tr>
        <td>research</td>
    </tr>
    <tr>
        <td>sales</td>
    </tr>
</table>



<p>内表的 deptno 与外表的 deptno 不’连接’, 则子查询无关联结果, 主查询始终满足条件, 相当于无条件:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">%%sql</span><br><span class="line">select name <span class="string">&#x27;部门&#x27;</span> <span class="keyword">from</span> dept where exists (</span><br><span class="line">    select * <span class="keyword">from</span> employee where deptno != <span class="number">30</span>);</span><br></pre></td></tr></table></figure>

<pre><code> * mysql+pymysql://root:***@localhost/test
4 rows affected.</code></pre>
<table>
    <tr>
        <th>部门</th>
    </tr>
    <tr>
        <td>accounting</td>
    </tr>
    <tr>
        <td>research</td>
    </tr>
    <tr>
        <td>sales</td>
    </tr>
    <tr>
        <td>financial</td>
    </tr>
</table>



<h4 id="多行多列子查询"><a href="#多行多列子查询" class="headerlink" title="多行多列子查询"></a>多行多列子查询</h4><p>子查询一般在主查询的 from 子句中.</p>
<p>查询雇员表中的部门, 部门号, 地址, 人数, 平均工资.<br>子查询方法:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">%%sql</span><br><span class="line">select d.name <span class="string">&#x27;部门&#x27;</span>, </span><br><span class="line">    d.deptno <span class="string">&#x27;部门号&#x27;</span>, </span><br><span class="line">    d.loc <span class="string">&#x27;地址&#x27;</span>, </span><br><span class="line">    num <span class="string">&#x27;人数&#x27;</span>,</span><br><span class="line">    ag <span class="string">&#x27;平均工资&#x27;</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">from</span> dept d inner join (</span><br><span class="line">        select deptno, </span><br><span class="line">            count(no) num, </span><br><span class="line">            avg(sal) ag</span><br><span class="line">        <span class="keyword">from</span> employee</span><br><span class="line">        group by deptno</span><br><span class="line">    ) em_1 on d.deptno = em_1.deptno; </span><br></pre></td></tr></table></figure>

<pre><code> * mysql+pymysql://root:***@localhost/test
3 rows affected.</code></pre>
<table>
    <tr>
        <th>部门</th>
        <th>部门号</th>
        <th>地址</th>
        <th>人数</th>
        <th>平均工资</th>
    </tr>
    <tr>
        <td>accounting</td>
        <td>10</td>
        <td>new_york</td>
        <td>3</td>
        <td>2916.666667</td>
    </tr>
    <tr>
        <td>research</td>
        <td>20</td>
        <td>dalas</td>
        <td>5</td>
        <td>2175.0</td>
    </tr>
    <tr>
        <td>sales</td>
        <td>30</td>
        <td>beijing</td>
        <td>6</td>
        <td>1566.666667</td>
    </tr>
</table>



<p>连接方法:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">%%sql</span><br><span class="line">select d.deptno <span class="string">&#x27;部门号&#x27;</span>,</span><br><span class="line">    d.name <span class="string">&#x27;部门&#x27;</span>,</span><br><span class="line">    d.loc <span class="string">&#x27;地址&#x27;</span>,</span><br><span class="line">    count(e.no) <span class="string">&#x27;人数&#x27;</span>,</span><br><span class="line">    avg(e.sal) <span class="string">&#x27;平均工资&#x27;</span></span><br><span class="line"><span class="keyword">from</span> employee e inner join dept d </span><br><span class="line">    on e.deptno = d.deptno </span><br><span class="line">    group by d.deptno, d.name, d.loc;</span><br></pre></td></tr></table></figure>

<pre><code> * mysql+pymysql://root:***@localhost/test
3 rows affected.</code></pre>
<table>
    <tr>
        <th>部门号</th>
        <th>部门</th>
        <th>地址</th>
        <th>人数</th>
        <th>平均工资</th>
    </tr>
    <tr>
        <td>10</td>
        <td>accounting</td>
        <td>new_york</td>
        <td>3</td>
        <td>2916.666667</td>
    </tr>
    <tr>
        <td>20</td>
        <td>research</td>
        <td>dalas</td>
        <td>5</td>
        <td>2175.0</td>
    </tr>
    <tr>
        <td>30</td>
        <td>sales</td>
        <td>beijing</td>
        <td>6</td>
        <td>1566.666667</td>
    </tr>
</table>
]]></content>
      <categories>
        <category>数据分析</category>
      </categories>
      <tags>
        <tag>Mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>Mysql 基本介绍和单表操作</title>
    <url>/data/mysql1-a1e1ed8d89a7/</url>
    <content><![CDATA[<blockquote>
<p>文章主要内容和思路来源: <strong>开课吧</strong>学习笔记</p>
</blockquote>
<p><font color=#00A600 >2020年5月18日更新</font></p>
<h2 id="一-基本介绍"><a href="#一-基本介绍" class="headerlink" title="一, 基本介绍"></a>一, 基本介绍</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>1, 数据库(database):  </p>
<p>保存有组织的数据的容器（通常是一个文件或一组文件）. 其实我们一直在使用数据库。每当你从电子邮件地址簿里查找名字时，就是在使用数据库。你在网站上进行搜索，也是在使用数据库。你在工作中登录网络，也需要依靠数据库验证用户名和密码。即使是在自动取款机上使用 ATM卡，也要利用数据库进行密码验证和查询余额。</p>
<p>2, MySQL:  </p>
<p>数据库管理系统（DBMS）的一种, 数据库通过 DBMS 创建和操纵容器.</p>
<p>3, SQL:  </p>
<p>结构化查询语言(structured query language), 用来和数据库通信.</p>
<p>4, 表:  </p>
<p>数据库中一种结构化的文件, 相当于 excel 中的一个 sheet.</p>
<p>5, 列:  </p>
<p>表中的一列, 一个字段, 存储某一特定信息, 例如姓名. 每一列有固定的数据类型.</p>
<p>6, 行:  </p>
<p>表中的数据是按行储存的, 一行就是一条完整的数据(记录).</p>
<p>7, 主键:  </p>
<p>为方便数据管理而定义的, 能够唯一标识表中每一行的一列(或几列, 几列时单列可不唯一, 组合必须唯一). 表中任何列都可作为主键, 只要满足:</p>
<p>a, 任意两行都无相同主键;<br>b, 每一行必须有一个非 NULL 值的主键;<br>c, 主键中的值不允许修改或更新;<br>d, 主键值不能重用(某行删除, 它的主键不能赋给新行)</p>
<p>8, MySQL 常用数据类型:  </p>
<p>整数类型: TINYINT, SMALLINT, MEDIUMINT, INT和INTEGER, BIGINT.</p>
<p>浮点类型: FLOAT, DOUBLE, DECIMAL, 位类型: BIT(m), m 范围 1~64.</p>
<p>时间日期型: DATE, DATETIME, TIMESTAMP, TIME, YEAR.</p>
<p>字符串类型: CHAR(m), VARCHAR(m), TINYTEXT, TEXT, MEDIUMTEXT, LONGTEXT.</p>
<h3 id="数据库和表初探"><a href="#数据库和表初探" class="headerlink" title="数据库和表初探"></a>数据库和表初探</h3><p>1, 建库:</p>
<p><code>create database 库名 charset utf8mb4 collate utf8mb4_genneral_ci;</code>,<br><code>charset utf8mb4</code>, 指定编码(可选); <code>collate utf8mb4_genneral_ci</code>, 指定排序规则(可选).</p>
<p>数据库命名规则: 字母, 数字, 下划线, <code>@</code>, <code>#</code>, <code>$</code>组成, 首字母不能是数字和 <code>$</code>, 且不能与 MySQL 保留字相同.</p>
<p>排序规则设置优先级顺序: SQL语句 &gt; 列 &gt; 表 &gt; 库 &gt; 实例.</p>
<p><code>show create database 库名;</code>, 查看建库时使用的语句.</p>
<p>2, 查看, 进入, 删除库: </p>
<p>查看所有数据库: <code>show databases;</code>.</p>
<p>进入数据库: <code>use 库名;</code>.</p>
<p>删除数据库: <code>drop database 库名;</code>.</p>
<p>3, 建表:</p>
<ul>
<li><p>先进入数据库, 再建表:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create table 表名(</span><br><span class="line">    列名1 数据类型, 列属性, ...</span><br><span class="line">    ...</span><br><span class="line">    列名n ...</span><br><span class="line">)表属性, ...;</span><br></pre></td></tr></table></figure>
</li>
<li><p>常见<code>列属性</code>: </p>
<p>null/not null: 空属性.</p>
<p>default: 默认值, 后面跟默认值. </p>
<p>primary key: 主键, 可在列属性设置, 也可在列字段后面加入.</p>
<p>unique key: 唯一键, 保证字段唯一性, 默认自动允许为空, 加入值后必须唯一, 设置唯一键时和主键类似.</p>
<p>auto_increment: 自增, 对应字段不给值, 给默认值或 null 时, 系统从当前字段中已有的<code>最大值+1</code> 进行填充, 通常和主键搭配.</p>
<p>自增的特点: 自身必须是一个索引(设置了key); 通常是整型; 一个表只能有一个自增.</p>
<p>comment: 列描述, 用来描述字段.</p>
</li>
<li><p><code>表属性</code>有引擎, 编码, 排序等.</p>
</li>
<li><p>主键可以建完表后再追加: <code>alter table 表名 add primary key(字段1, ...);</code>, 删除主键: <code>alter talbe 表名 drop primary key;</code>, 只会删除约束, 不会删除列(唯一键同理).</p>
</li>
<li><p>添加自增: <code>alter table 表名 modify 列名 数据类型 auto_increment;</code> 或 <code>alter table 表名 change 列名 列名 数据类型 auto_increment;</code>, 删除自增: <code>alter table 表名 modify 列名 数据类型;</code> 或 <code>alter table 表名 change 列名 列名 数据类型;</code>.</p>
</li>
</ul>
<p>4, 查看, 删除表: </p>
<p>查看所有表: <code>show tables;</code>.</p>
<p>以表格方式查看表: <code>describe 表名;</code> 或 <code>desc 表名;</code>.</p>
<p>查看建表语句: <code>show create table 表名;</code>.</p>
<p>删除表: <code>drop table 表名;</code>.</p>
<p>5, 修改表:</p>
<p>修改表名: <code>alter table 表名 rename 新表名;</code></p>
<p>添加列: <code>alter table 表名 add 列名 数据类型 first;</code>, first 表示放在所有列之前, 默认最后.</p>
<p>删除列: <code>alter table 表名  drop 列名;</code>.</p>
<p>修改列: </p>
<ul>
<li>修改列类型: <code>alter table 表名 modify 列名 新数据类型;</code>.</li>
<li>修改列名同时修改数据类型: <code>alter table 表名 change 列名 新列名 新数据类型;</code>.</li>
</ul>
<br>


<h2 id="二-单表基础操作"><a href="#二-单表基础操作" class="headerlink" title="二, 单表基础操作"></a>二, 单表基础操作</h2><h3 id="1-准备数据"><a href="#1-准备数据" class="headerlink" title="1, 准备数据"></a>1, 准备数据</h3><p>新建一个存储用户信息的表 <code>user</code>, (jupyter 里面连接的 sql , 忽略 <code>%%sql</code> 和 <code>* mysql+pymysql://root:***@localhost/test</code>.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">%%sql</span><br><span class="line">create table user(</span><br><span class="line">    <span class="built_in">id</span> <span class="built_in">int</span> primary key comment <span class="string">&#x27;用户id&#x27;</span>,</span><br><span class="line">    name varchar(<span class="number">10</span>) <span class="keyword">not</span> null comment <span class="string">&#x27;名字&#x27;</span>,</span><br><span class="line">    age <span class="built_in">int</span> default <span class="number">18</span>,</span><br><span class="line">    birthday date</span><br><span class="line">)charset utf8mb4;</span><br><span class="line"></span><br><span class="line">desc user;  <span class="comment"># 查看表</span></span><br></pre></td></tr></table></figure>

<pre><code> * mysql+pymysql://root:***@localhost/test
0 rows affected.
4 rows affected.</code></pre>
<table>
    <tr>
        <th>Field</th>
        <th>Type</th>
        <th>Null</th>
        <th>Key</th>
        <th>Default</th>
        <th>Extra</th>
    </tr>
    <tr>
        <td>id</td>
        <td>int(11)</td>
        <td>NO</td>
        <td>PRI</td>
        <td>None</td>
        <td></td>
    </tr>
    <tr>
        <td>name</td>
        <td>varchar(10)</td>
        <td>NO</td>
        <td></td>
        <td>None</td>
        <td></td>
    </tr>
    <tr>
        <td>age</td>
        <td>int(11)</td>
        <td>YES</td>
        <td></td>
        <td>18</td>
        <td></td>
    </tr>
    <tr>
        <td>birthday</td>
        <td>date</td>
        <td>YES</td>
        <td></td>
        <td>None</td>
        <td></td>
    </tr>
</table>



<h3 id="2-插入数据"><a href="#2-插入数据" class="headerlink" title="2, 插入数据"></a>2, 插入数据</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">insert into 表名(字段<span class="number">1</span>, 字段<span class="number">2</span>, ...) values</span><br><span class="line">(值<span class="number">1</span>, 值<span class="number">2</span>, ...)</span><br><span class="line">(值<span class="number">1</span>, 值<span class="number">2</span>, ...)</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>规则:  </p>
<p><code>字段</code>和<code>值</code>数量一样且对应;  </p>
<p>每个字段的类型和属性决定插入的值, 例如主键必须有, 且不能重复;</p>
<p>字符数不能超过建表时设置的类型数量限制;  </p>
<p>可以省略字段.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">%%sql</span><br><span class="line">insert into user(<span class="built_in">id</span>, name, birthday) values(<span class="number">1</span>, <span class="string">&#x27;bill1&#x27;</span>, <span class="string">&#x27;2020-05-13&#x27;</span>);</span><br><span class="line"></span><br><span class="line">select * <span class="keyword">from</span> user;    <span class="comment"># 查看结果</span></span><br></pre></td></tr></table></figure>

<pre><code> * mysql+pymysql://root:***@localhost/test
1 rows affected.</code></pre>
<table>
    <tr>
        <th>id</th>
        <th>name</th>
        <th>age</th>
        <th>birthday</th>
    </tr>
    <tr>
        <td>1</td>
        <td>bill1</td>
        <td>18</td>
        <td>2020-05-13</td>
    </tr>
</table>




<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">%%sql</span><br><span class="line">alter table user modify <span class="built_in">id</span> <span class="built_in">int</span> auto_increment;  <span class="comment"># 设置主键 id 自增</span></span><br><span class="line">insert into user(name) values(<span class="string">&#x27;bill2&#x27;</span>), (<span class="string">&#x27;bill3&#x27;</span>);</span><br><span class="line"></span><br><span class="line">select * <span class="keyword">from</span> user;</span><br></pre></td></tr></table></figure>

<pre><code> * mysql+pymysql://root:***@localhost/test
3 rows affected.</code></pre>
<table>
    <tr>
        <th>id</th>
        <th>name</th>
        <th>age</th>
        <th>birthday</th>
    </tr>
    <tr>
        <td>1</td>
        <td>bill1</td>
        <td>18</td>
        <td>2020-05-13</td>
    </tr>
    <tr>
        <td>2</td>
        <td>bill2</td>
        <td>18</td>
        <td>None</td>
    </tr>
    <tr>
        <td>3</td>
        <td>bill3</td>
        <td>18</td>
        <td>None</td>
    </tr>
</table>




<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">%%sql</span><br><span class="line">insert into user values</span><br><span class="line">(<span class="number">4</span>, <span class="string">&#x27;bill4&#x27;</span>, <span class="number">23</span>, <span class="string">&#x27;2020-05-16&#x27;</span>),</span><br><span class="line">(<span class="number">5</span>, <span class="string">&#x27;bill5&#x27;</span>, <span class="number">23</span>, <span class="string">&#x27;2020-05-16&#x27;</span>),</span><br><span class="line">(<span class="number">6</span>, <span class="string">&#x27;bill6&#x27;</span>, <span class="number">23</span>, <span class="string">&#x27;2020-05-16&#x27;</span>);</span><br><span class="line"></span><br><span class="line">select * <span class="keyword">from</span> user;</span><br></pre></td></tr></table></figure>

<pre><code> * mysql+pymysql://root:***@localhost/test
6 rows affected.</code></pre>
<table>
    <tr>
        <th>id</th>
        <th>name</th>
        <th>age</th>
        <th>birthday</th>
    </tr>
    <tr>
        <td>1</td>
        <td>bill1</td>
        <td>18</td>
        <td>2020-05-13</td>
    </tr>
    <tr>
        <td>2</td>
        <td>bill2</td>
        <td>18</td>
        <td>None</td>
    </tr>
    <tr>
        <td>3</td>
        <td>bill3</td>
        <td>18</td>
        <td>None</td>
    </tr>
    <tr>
        <td>4</td>
        <td>bill4</td>
        <td>23</td>
        <td>2020-05-16</td>
    </tr>
    <tr>
        <td>5</td>
        <td>bill5</td>
        <td>23</td>
        <td>2020-05-16</td>
    </tr>
    <tr>
        <td>6</td>
        <td>bill6</td>
        <td>23</td>
        <td>2020-05-16</td>
    </tr>
</table>



<h3 id="3-更新数据"><a href="#3-更新数据" class="headerlink" title="3, 更新数据"></a>3, 更新数据</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">update 表名</span><br><span class="line">    <span class="built_in">set</span> 字段=值,</span><br><span class="line">        字段=值,</span><br><span class="line">        ...</span><br><span class="line">    where 条件;    <span class="comment"># 可以没有条件</span></span><br></pre></td></tr></table></figure>


<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">%%sql</span><br><span class="line">update user <span class="built_in">set</span> birthday=<span class="string">&#x27;2020-05-14&#x27;</span> where birthday <span class="keyword">is</span> null;</span><br><span class="line"><span class="comment">#  null 值不能用 = 或 != 做判断条件, 不报错, 但无效</span></span><br><span class="line"></span><br><span class="line">select * <span class="keyword">from</span> user;</span><br></pre></td></tr></table></figure>

<pre><code> * mysql+pymysql://root:***@localhost/test
2 rows affected.
6 rows affected.</code></pre>
<table>
    <tr>
        <th>id</th>
        <th>name</th>
        <th>age</th>
        <th>birthday</th>
    </tr>
    <tr>
        <td>1</td>
        <td>bill1</td>
        <td>18</td>
        <td>2020-05-13</td>
    </tr>
    <tr>
        <td>2</td>
        <td>bill2</td>
        <td>18</td>
        <td>2020-05-14</td>
    </tr>
    <tr>
        <td>3</td>
        <td>bill3</td>
        <td>18</td>
        <td>2020-05-14</td>
    </tr>
    <tr>
        <td>4</td>
        <td>bill4</td>
        <td>23</td>
        <td>2020-05-16</td>
    </tr>
    <tr>
        <td>5</td>
        <td>bill5</td>
        <td>23</td>
        <td>2020-05-16</td>
    </tr>
    <tr>
        <td>6</td>
        <td>bill6</td>
        <td>23</td>
        <td>2020-05-16</td>
    </tr>
</table>




<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">%%sql</span><br><span class="line">update user <span class="built_in">set</span> name=<span class="string">&#x27;bill&#x27;</span>, age=<span class="number">19</span> where <span class="built_in">id</span> &gt; <span class="number">2</span> <span class="keyword">and</span> <span class="built_in">id</span> &lt; <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">select * <span class="keyword">from</span> user;</span><br></pre></td></tr></table></figure>

<pre><code> * mysql+pymysql://root:***@localhost/test
2 rows affected.
6 rows affected.</code></pre>
<table>
    <tr>
        <th>id</th>
        <th>name</th>
        <th>age</th>
        <th>birthday</th>
    </tr>
    <tr>
        <td>1</td>
        <td>bill1</td>
        <td>18</td>
        <td>2020-05-13</td>
    </tr>
    <tr>
        <td>2</td>
        <td>bill2</td>
        <td>18</td>
        <td>2020-05-14</td>
    </tr>
    <tr>
        <td>3</td>
        <td>bill</td>
        <td>19</td>
        <td>2020-05-14</td>
    </tr>
    <tr>
        <td>4</td>
        <td>bill</td>
        <td>19</td>
        <td>2020-05-16</td>
    </tr>
    <tr>
        <td>5</td>
        <td>bill5</td>
        <td>23</td>
        <td>2020-05-16</td>
    </tr>
    <tr>
        <td>6</td>
        <td>bill6</td>
        <td>23</td>
        <td>2020-05-16</td>
    </tr>
</table>



<h3 id="4-删除数据"><a href="#4-删除数据" class="headerlink" title="4, 删除数据"></a>4, 删除数据</h3><p>删除满足条件的一行, 无条件就删除全部数据.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">delete <span class="keyword">from</span> 表名 where 条件; </span><br></pre></td></tr></table></figure>


<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">%%sql</span><br><span class="line">delete <span class="keyword">from</span> user where age=<span class="number">19</span>;</span><br><span class="line"></span><br><span class="line">select * <span class="keyword">from</span> user;</span><br></pre></td></tr></table></figure>

<pre><code> * mysql+pymysql://root:***@localhost/test
2 rows affected.
4 rows affected.</code></pre>
<table>
    <tr>
        <th>id</th>
        <th>name</th>
        <th>age</th>
        <th>birthday</th>
    </tr>
    <tr>
        <td>1</td>
        <td>bill1</td>
        <td>18</td>
        <td>2020-05-13</td>
    </tr>
    <tr>
        <td>2</td>
        <td>bill2</td>
        <td>18</td>
        <td>2020-05-14</td>
    </tr>
    <tr>
        <td>5</td>
        <td>bill5</td>
        <td>23</td>
        <td>2020-05-16</td>
    </tr>
    <tr>
        <td>6</td>
        <td>bill6</td>
        <td>23</td>
        <td>2020-05-16</td>
    </tr>
</table>



<h3 id="5-查询-选择数据"><a href="#5-查询-选择数据" class="headerlink" title="5, 查询/选择数据"></a>5, 查询/选择数据</h3><p>SELECT 语句定义:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&lt;SELECT clause&gt; [&lt;FROM clause&gt;] [&lt;WHERE clause&gt;] [&lt;GROUP BY clause&gt;] [&lt;HAVING clause&gt;] [&lt;ORDER BY clause&gt;] [&lt;LIMIT clause&gt;] </span><br></pre></td></tr></table></figure>

<h4 id="5-1-基本的查询规则"><a href="#5-1-基本的查询规则" class="headerlink" title="5.1, 基本的查询规则:"></a>5.1, 基本的查询规则:</h4><p>a, 语句的顺序固定, 除了 SELECT, FROM 必选, 其他都是可选.</p>
<p>b, 执行顺序与 SELECT 语句顺序不一样, 执行顺序为: </p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">FROM -&gt; WHERE -&gt; GROUP BY -&gt; HAVING -&gt; ORDER BY -&gt; SELECT -&gt; LIMIT</span><br></pre></td></tr></table></figure>

<p>从 GROUP BY 开始可使用 SELECT 设置的别名，后面的语句中都可以使用.</p>
<p>c, 每个子句执行后都会产生一个中间结果，供接下来的子句使用.</p>
<p>d, WHERE 只能筛选表的字段, HAVING 筛选中间结果.</p>
<h4 id="5-2-准备数据"><a href="#5-2-准备数据" class="headerlink" title="5.2, 准备数据"></a>5.2, 准备数据</h4><p>创建雇员信息表 <code>employee</code>:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">%%sql</span><br><span class="line">create table employee(</span><br><span class="line">  no <span class="built_in">int</span> comment <span class="string">&quot;员工编号&quot;</span>,</span><br><span class="line">  name varchar(<span class="number">20</span>) comment <span class="string">&quot;姓名&quot;</span>,</span><br><span class="line">  job varchar(<span class="number">40</span>) comment <span class="string">&quot;职位&quot;</span>,</span><br><span class="line">  mgr <span class="built_in">int</span> comment <span class="string">&quot;上司id&quot;</span>,</span><br><span class="line">  hiredate date comment <span class="string">&quot;雇佣时间&quot;</span>,</span><br><span class="line">  sal double(<span class="number">10</span>, <span class="number">2</span>) comment <span class="string">&quot;工资&quot;</span>,</span><br><span class="line">  comm double(<span class="number">10</span>, <span class="number">2</span>) comment <span class="string">&quot;奖金&quot;</span>,</span><br><span class="line">  deptno <span class="built_in">int</span> comment <span class="string">&quot;部门id&quot;</span></span><br><span class="line">) charset=utf8;</span><br><span class="line"></span><br><span class="line">insert into employee values</span><br><span class="line">  (<span class="number">7369</span>, <span class="string">&quot;smith&quot;</span>, <span class="string">&quot;clerk&quot;</span>, <span class="number">7902</span>, <span class="string">&quot;1981-03-12&quot;</span>, <span class="number">800.00</span>, NULL, <span class="number">20</span>),</span><br><span class="line">  (<span class="number">7499</span>, <span class="string">&quot;allen&quot;</span>, <span class="string">&quot;salesman&quot;</span>, <span class="number">7698</span>, <span class="string">&quot;1982-03-12&quot;</span>, <span class="number">1600.00</span>, <span class="number">300.00</span>, <span class="number">30</span>),</span><br><span class="line">  (<span class="number">7521</span>, <span class="string">&quot;ward&quot;</span>, <span class="string">&quot;salesman&quot;</span>, <span class="number">7698</span>, <span class="string">&quot;1983-03-12&quot;</span>, <span class="number">1250.00</span>, <span class="number">500.00</span>, <span class="number">30</span>),</span><br><span class="line">  (<span class="number">7566</span>, <span class="string">&quot;jones&quot;</span>, <span class="string">&quot;manager&quot;</span>, <span class="number">7839</span>, <span class="string">&quot;1981-03-12&quot;</span>, <span class="number">2975.00</span>, NULL, <span class="number">20</span>),</span><br><span class="line">  (<span class="number">7654</span>, <span class="string">&quot;martin&quot;</span>, <span class="string">&quot;salesman&quot;</span>, <span class="number">7698</span>, <span class="string">&quot;1981-03-12&quot;</span>, <span class="number">1250.00</span>, <span class="number">1400.00</span>, <span class="number">30</span>),</span><br><span class="line">  (<span class="number">7698</span>, <span class="string">&quot;blake&quot;</span>, <span class="string">&quot;manager&quot;</span>, <span class="number">7839</span>, <span class="string">&quot;1981-03-12&quot;</span>, <span class="number">2850.00</span>, NULL, <span class="number">30</span>),</span><br><span class="line">  (<span class="number">7782</span>, <span class="string">&quot;clark&quot;</span>, <span class="string">&quot;manager&quot;</span>, <span class="number">7839</span>, <span class="string">&quot;1985-03-12&quot;</span>, <span class="number">2450.00</span>, NULL, <span class="number">10</span>),</span><br><span class="line">  (<span class="number">7788</span>, <span class="string">&quot;scott&quot;</span>, <span class="string">&quot;analyst&quot;</span>, <span class="number">7566</span>, <span class="string">&quot;1981-03-12&quot;</span>, <span class="number">3000.00</span>, NULL, <span class="number">20</span>),</span><br><span class="line">  (<span class="number">7839</span>, <span class="string">&quot;king&quot;</span>, <span class="string">&quot;president&quot;</span>, NULL, <span class="string">&quot;1981-03-12&quot;</span>, <span class="number">5000.00</span>, NULL, <span class="number">10</span>),</span><br><span class="line">  (<span class="number">7844</span>, <span class="string">&quot;turner&quot;</span>, <span class="string">&quot;salesman&quot;</span>, <span class="number">7698</span>, <span class="string">&quot;1989-03-12&quot;</span>, <span class="number">1500.00</span>, <span class="number">0.00</span>, <span class="number">30</span>),</span><br><span class="line">  (<span class="number">7876</span>, <span class="string">&quot;adams&quot;</span>, <span class="string">&quot;clerk&quot;</span>, <span class="number">7788</span>, <span class="string">&quot;1998-03-12&quot;</span>, <span class="number">1100.00</span>, NULL, <span class="number">20</span>),</span><br><span class="line">  (<span class="number">7900</span>, <span class="string">&quot;james&quot;</span>, <span class="string">&quot;clerk&quot;</span>, <span class="number">7698</span>, <span class="string">&quot;1997-03-12&quot;</span>, <span class="number">950.00</span>, NULL, <span class="number">30</span>),</span><br><span class="line">  (<span class="number">7902</span>, <span class="string">&quot;ford&quot;</span>, <span class="string">&quot;analyst&quot;</span>, <span class="number">7566</span>, <span class="string">&quot;2000-01-01&quot;</span>, <span class="number">3000.00</span>, NULL, <span class="number">20</span>),</span><br><span class="line">  (<span class="number">7934</span>, <span class="string">&quot;miller&quot;</span>, <span class="string">&quot;clerk&quot;</span>, <span class="number">7782</span>, <span class="string">&quot;1981-03-12&quot;</span>, <span class="number">1300.00</span>, NULL, <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">select * <span class="keyword">from</span> employee;</span><br></pre></td></tr></table></figure>

<pre><code> * mysql+pymysql://root:***@localhost/test
0 rows affected.
14 rows affected.
14 rows affected.</code></pre>
<table>
    <tr>
        <th>no</th>
        <th>name</th>
        <th>job</th>
        <th>mgr</th>
        <th>hiredate</th>
        <th>sal</th>
        <th>comm</th>
        <th>deptno</th>
    </tr>
    <tr>
        <td>7369</td>
        <td>smith</td>
        <td>clerk</td>
        <td>7902</td>
        <td>1981-03-12</td>
        <td>800.0</td>
        <td>None</td>
        <td>20</td>
    </tr>
    <tr>
        <td>7499</td>
        <td>allen</td>
        <td>salesman</td>
        <td>7698</td>
        <td>1982-03-12</td>
        <td>1600.0</td>
        <td>300.0</td>
        <td>30</td>
    </tr>
    <tr>
        <td>7521</td>
        <td>ward</td>
        <td>salesman</td>
        <td>7698</td>
        <td>1983-03-12</td>
        <td>1250.0</td>
        <td>500.0</td>
        <td>30</td>
    </tr>
    <tr>
        <td>7566</td>
        <td>jones</td>
        <td>manager</td>
        <td>7839</td>
        <td>1981-03-12</td>
        <td>2975.0</td>
        <td>None</td>
        <td>20</td>
    </tr>
    <tr>
        <td>7654</td>
        <td>martin</td>
        <td>salesman</td>
        <td>7698</td>
        <td>1981-03-12</td>
        <td>1250.0</td>
        <td>1400.0</td>
        <td>30</td>
    </tr>
    <tr>
        <td>7698</td>
        <td>blake</td>
        <td>manager</td>
        <td>7839</td>
        <td>1981-03-12</td>
        <td>2850.0</td>
        <td>None</td>
        <td>30</td>
    </tr>
    <tr>
        <td>7782</td>
        <td>clark</td>
        <td>manager</td>
        <td>7839</td>
        <td>1985-03-12</td>
        <td>2450.0</td>
        <td>None</td>
        <td>10</td>
    </tr>
    <tr>
        <td>7788</td>
        <td>scott</td>
        <td>analyst</td>
        <td>7566</td>
        <td>1981-03-12</td>
        <td>3000.0</td>
        <td>None</td>
        <td>20</td>
    </tr>
    <tr>
        <td>7839</td>
        <td>king</td>
        <td>president</td>
        <td>None</td>
        <td>1981-03-12</td>
        <td>5000.0</td>
        <td>None</td>
        <td>10</td>
    </tr>
    <tr>
        <td>7844</td>
        <td>turner</td>
        <td>salesman</td>
        <td>7698</td>
        <td>1989-03-12</td>
        <td>1500.0</td>
        <td>0.0</td>
        <td>30</td>
    </tr>
    <tr>
        <td>7876</td>
        <td>adams</td>
        <td>clerk</td>
        <td>7788</td>
        <td>1998-03-12</td>
        <td>1100.0</td>
        <td>None</td>
        <td>20</td>
    </tr>
    <tr>
        <td>7900</td>
        <td>james</td>
        <td>clerk</td>
        <td>7698</td>
        <td>1997-03-12</td>
        <td>950.0</td>
        <td>None</td>
        <td>30</td>
    </tr>
    <tr>
        <td>7902</td>
        <td>ford</td>
        <td>analyst</td>
        <td>7566</td>
        <td>2000-01-01</td>
        <td>3000.0</td>
        <td>None</td>
        <td>20</td>
    </tr>
    <tr>
        <td>7934</td>
        <td>miller</td>
        <td>clerk</td>
        <td>7782</td>
        <td>1981-03-12</td>
        <td>1300.0</td>
        <td>None</td>
        <td>10</td>
    </tr>
</table>



<h4 id="5-3-结果去重"><a href="#5-3-结果去重" class="headerlink" title="5.3, 结果去重"></a>5.3, 结果去重</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">%%sql</span><br><span class="line">select distinct job <span class="keyword">from</span> employee;</span><br></pre></td></tr></table></figure>

<pre><code> * mysql+pymysql://root:***@localhost/test
5 rows affected.</code></pre>
<table>
    <tr>
        <th>job</th>
    </tr>
    <tr>
        <td>clerk</td>
    </tr>
    <tr>
        <td>salesman</td>
    </tr>
    <tr>
        <td>manager</td>
    </tr>
    <tr>
        <td>analyst</td>
    </tr>
    <tr>
        <td>president</td>
    </tr>
</table>



<h4 id="5-4-结果运算"><a href="#5-4-结果运算" class="headerlink" title="5.4, 结果运算"></a>5.4, 结果运算</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">%%sql</span><br><span class="line">select name, sal*<span class="number">12</span> <span class="keyword">from</span> employee;</span><br></pre></td></tr></table></figure>

<pre><code> * mysql+pymysql://root:***@localhost/test
14 rows affected.</code></pre>
<table>
    <tr>
        <th>name</th>
        <th>sal*12</th>
    </tr>
    <tr>
        <td>smith</td>
        <td>9600.0</td>
    </tr>
    <tr>
        <td>allen</td>
        <td>19200.0</td>
    </tr>
    <tr>
        <td>ward</td>
        <td>15000.0</td>
    </tr>
    <tr>
        <td>jones</td>
        <td>35700.0</td>
    </tr>
    <tr>
        <td>martin</td>
        <td>15000.0</td>
    </tr>
    <tr>
        <td>blake</td>
        <td>34200.0</td>
    </tr>
    <tr>
        <td>clark</td>
        <td>29400.0</td>
    </tr>
    <tr>
        <td>scott</td>
        <td>36000.0</td>
    </tr>
    <tr>
        <td>king</td>
        <td>60000.0</td>
    </tr>
    <tr>
        <td>turner</td>
        <td>18000.0</td>
    </tr>
    <tr>
        <td>adams</td>
        <td>13200.0</td>
    </tr>
    <tr>
        <td>james</td>
        <td>11400.0</td>
    </tr>
    <tr>
        <td>ford</td>
        <td>36000.0</td>
    </tr>
    <tr>
        <td>miller</td>
        <td>15600.0</td>
    </tr>
</table>




<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">%%sql</span><br><span class="line">select name <span class="keyword">as</span> <span class="string">&#x27;姓名&#x27;</span>, sal*<span class="number">12</span> <span class="string">&#x27;年薪&#x27;</span> <span class="keyword">from</span> employee; <span class="comment"># as 设置别名, 可以省略</span></span><br></pre></td></tr></table></figure>

<pre><code> * mysql+pymysql://root:***@localhost/test
14 rows affected.</code></pre>
<table>
    <tr>
        <th>姓名</th>
        <th>年薪</th>
    </tr>
    <tr>
        <td>smith</td>
        <td>9600.0</td>
    </tr>
    <tr>
        <td>allen</td>
        <td>19200.0</td>
    </tr>
    <tr>
        <td>ward</td>
        <td>15000.0</td>
    </tr>
    <tr>
        <td>jones</td>
        <td>35700.0</td>
    </tr>
    <tr>
        <td>martin</td>
        <td>15000.0</td>
    </tr>
    <tr>
        <td>blake</td>
        <td>34200.0</td>
    </tr>
    <tr>
        <td>clark</td>
        <td>29400.0</td>
    </tr>
    <tr>
        <td>scott</td>
        <td>36000.0</td>
    </tr>
    <tr>
        <td>king</td>
        <td>60000.0</td>
    </tr>
    <tr>
        <td>turner</td>
        <td>18000.0</td>
    </tr>
    <tr>
        <td>adams</td>
        <td>13200.0</td>
    </tr>
    <tr>
        <td>james</td>
        <td>11400.0</td>
    </tr>
    <tr>
        <td>ford</td>
        <td>36000.0</td>
    </tr>
    <tr>
        <td>miller</td>
        <td>15600.0</td>
    </tr>
</table>



<h4 id="5-5-函数和方法对结果进行处理"><a href="#5-5-函数和方法对结果进行处理" class="headerlink" title="5.5, 函数和方法对结果进行处理"></a>5.5, 函数和方法对结果进行处理</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">%%sql</span><br><span class="line">select count(*) <span class="keyword">from</span> employee;  <span class="comment"># count(*) 会统计所有值个数</span></span><br></pre></td></tr></table></figure>

<pre><code> * mysql+pymysql://root:***@localhost/test
1 rows affected.</code></pre>
<table>
    <tr>
        <th>count(*)</th>
    </tr>
    <tr>
        <td>14</td>
    </tr>
</table>




<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">%%sql</span><br><span class="line">select count(comm) <span class="keyword">from</span> employee;  <span class="comment"># count(字段) 统计非 null 的值个数</span></span><br></pre></td></tr></table></figure>

<pre><code> * mysql+pymysql://root:***@localhost/test
1 rows affected.</code></pre>
<table>
    <tr>
        <th>count(comm)</th>
    </tr>
    <tr>
        <td>4</td>
    </tr>
</table>



<p>统计函数 avg, sum, max, min 等, 统计时忽略 null 值, 都是 null 值或空表时, count 返回 0 , 其他返回 null.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">%%sql</span><br><span class="line">select concat(name, <span class="string">&#x27;的年薪: &#x27;</span>, sal*<span class="number">12</span>) <span class="string">&#x27;薪资&#x27;</span> <span class="keyword">from</span> employee;  <span class="comment"># concat() 拼接字符串</span></span><br></pre></td></tr></table></figure>

<pre><code> * mysql+pymysql://root:***@localhost/test
14 rows affected.</code></pre>
<table>
    <tr>
        <th>薪资</th>
    </tr>
    <tr>
        <td>smith的年薪: 9600.00</td>
    </tr>
    <tr>
        <td>allen的年薪: 19200.00</td>
    </tr>
    <tr>
        <td>ward的年薪: 15000.00</td>
    </tr>
    <tr>
        <td>jones的年薪: 35700.00</td>
    </tr>
    <tr>
        <td>martin的年薪: 15000.00</td>
    </tr>
    <tr>
        <td>blake的年薪: 34200.00</td>
    </tr>
    <tr>
        <td>clark的年薪: 29400.00</td>
    </tr>
    <tr>
        <td>scott的年薪: 36000.00</td>
    </tr>
    <tr>
        <td>king的年薪: 60000.00</td>
    </tr>
    <tr>
        <td>turner的年薪: 18000.00</td>
    </tr>
    <tr>
        <td>adams的年薪: 13200.00</td>
    </tr>
    <tr>
        <td>james的年薪: 11400.00</td>
    </tr>
    <tr>
        <td>ford的年薪: 36000.00</td>
    </tr>
    <tr>
        <td>miller的年薪: 15600.00</td>
    </tr>
</table>



<h4 id="5-6-where-条件查询"><a href="#5-6-where-条件查询" class="headerlink" title="5.6, where 条件查询"></a>5.6, where 条件查询</h4><p>运算符有 <code>&gt;</code>, <code>&lt;</code>, <code>=</code>, <code>!=</code> 或 <code>&lt;&gt;</code>, <code>&lt;=</code>, <code>&gt;=</code>, <code>and</code> 或 <code>&amp;&amp;</code>, <code>or</code> 或 <code>||</code>, <code>xor</code>, <code>not</code> 或 <code>!</code>. 灵活运用, 不同的组合可以得到一样的结果, 也可用 <code>between and</code>, <code>in</code> 限制范围, <code>like</code> 模糊查询.</p>
<p>注意区分 <code>null</code>, <code>None</code>, <code>NaN</code>, <code>0</code> 和 <code>&#39;&#39;</code>.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">%%sql</span><br><span class="line">select job, name <span class="keyword">from</span> employee </span><br><span class="line">where job != <span class="string">&#x27;clerk&#x27;</span> <span class="keyword">and</span> sal &gt; <span class="number">1000</span>;</span><br></pre></td></tr></table></figure>

<pre><code> * mysql+pymysql://root:***@localhost/test
10 rows affected.</code></pre>
<table>
    <tr>
        <th>job</th>
        <th>name</th>
    </tr>
    <tr>
        <td>salesman</td>
        <td>allen</td>
    </tr>
    <tr>
        <td>salesman</td>
        <td>ward</td>
    </tr>
    <tr>
        <td>manager</td>
        <td>jones</td>
    </tr>
    <tr>
        <td>salesman</td>
        <td>martin</td>
    </tr>
    <tr>
        <td>manager</td>
        <td>blake</td>
    </tr>
    <tr>
        <td>manager</td>
        <td>clark</td>
    </tr>
    <tr>
        <td>analyst</td>
        <td>scott</td>
    </tr>
    <tr>
        <td>president</td>
        <td>king</td>
    </tr>
    <tr>
        <td>salesman</td>
        <td>turner</td>
    </tr>
    <tr>
        <td>analyst</td>
        <td>ford</td>
    </tr>
</table>




<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">%%sql</span><br><span class="line">select job <span class="keyword">from</span> employee </span><br><span class="line">where sal between <span class="number">1000</span> <span class="keyword">and</span> <span class="number">2000</span>;</span><br></pre></td></tr></table></figure>

<pre><code> * mysql+pymysql://root:***@localhost/test
6 rows affected.</code></pre>
<table>
    <tr>
        <th>job</th>
    </tr>
    <tr>
        <td>salesman</td>
    </tr>
    <tr>
        <td>salesman</td>
    </tr>
    <tr>
        <td>salesman</td>
    </tr>
    <tr>
        <td>salesman</td>
    </tr>
    <tr>
        <td>clerk</td>
    </tr>
    <tr>
        <td>clerk</td>
    </tr>
</table>




<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">%%sql</span><br><span class="line">select name, sal <span class="keyword">from</span> employee where job <span class="keyword">in</span> (<span class="string">&#x27;analyst&#x27;</span>, <span class="string">&#x27;president&#x27;</span>);</span><br></pre></td></tr></table></figure>

<pre><code> * mysql+pymysql://root:***@localhost/test
3 rows affected.</code></pre>
<table>
    <tr>
        <th>name</th>
        <th>sal</th>
    </tr>
    <tr>
        <td>scott</td>
        <td>3000.0</td>
    </tr>
    <tr>
        <td>king</td>
        <td>5000.0</td>
    </tr>
    <tr>
        <td>ford</td>
        <td>3000.0</td>
    </tr>
</table>



<p><code>like</code> 匹配, <code>_</code>表示匹配单个字符串, <code>%</code>匹配任意长度的字符串, 包括 0 个.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">%%sql</span><br><span class="line">select name <span class="keyword">from</span> employee where name like <span class="string">&#x27;_m%&#x27;</span>;</span><br></pre></td></tr></table></figure>

<pre><code> * mysql+pymysql://root:***@localhost/test
1 rows affected.</code></pre>
<table>
    <tr>
        <th>name</th>
    </tr>
    <tr>
        <td>smith</td>
    </tr>
</table>




<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">%%sql</span><br><span class="line">select name <span class="keyword">from</span> employee where name like <span class="string">&#x27;%M%&#x27;</span>;</span><br></pre></td></tr></table></figure>

<pre><code> * mysql+pymysql://root:***@localhost/test
5 rows affected.</code></pre>
<table>
    <tr>
        <th>name</th>
    </tr>
    <tr>
        <td>smith</td>
    </tr>
    <tr>
        <td>martin</td>
    </tr>
    <tr>
        <td>adams</td>
    </tr>
    <tr>
        <td>james</td>
    </tr>
    <tr>
        <td>miller</td>
    </tr>
</table>



<h4 id="5-7-排序查询"><a href="#5-7-排序查询" class="headerlink" title="5.7, 排序查询"></a>5.7, 排序查询</h4><p>用 <code>order by asc/desc</code> 语句排序, asc 为升序(默认), desc 降序.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">%%sql</span><br><span class="line">select name, sal, hiredate <span class="keyword">from</span> employee </span><br><span class="line">order by hiredate, sal desc;  <span class="comment"># 先按前一个排序, 再第二个</span></span><br></pre></td></tr></table></figure>

<pre><code> * mysql+pymysql://root:***@localhost/test
14 rows affected.</code></pre>
<table>
    <tr>
        <th>name</th>
        <th>sal</th>
        <th>hiredate</th>
    </tr>
    <tr>
        <td>king</td>
        <td>5000.0</td>
        <td>1981-03-12</td>
    </tr>
    <tr>
        <td>scott</td>
        <td>3000.0</td>
        <td>1981-03-12</td>
    </tr>
    <tr>
        <td>jones</td>
        <td>2975.0</td>
        <td>1981-03-12</td>
    </tr>
    <tr>
        <td>blake</td>
        <td>2850.0</td>
        <td>1981-03-12</td>
    </tr>
    <tr>
        <td>miller</td>
        <td>1300.0</td>
        <td>1981-03-12</td>
    </tr>
    <tr>
        <td>martin</td>
        <td>1250.0</td>
        <td>1981-03-12</td>
    </tr>
    <tr>
        <td>smith</td>
        <td>800.0</td>
        <td>1981-03-12</td>
    </tr>
    <tr>
        <td>allen</td>
        <td>1600.0</td>
        <td>1982-03-12</td>
    </tr>
    <tr>
        <td>ward</td>
        <td>1250.0</td>
        <td>1983-03-12</td>
    </tr>
    <tr>
        <td>clark</td>
        <td>2450.0</td>
        <td>1985-03-12</td>
    </tr>
    <tr>
        <td>turner</td>
        <td>1500.0</td>
        <td>1989-03-12</td>
    </tr>
    <tr>
        <td>james</td>
        <td>950.0</td>
        <td>1997-03-12</td>
    </tr>
    <tr>
        <td>adams</td>
        <td>1100.0</td>
        <td>1998-03-12</td>
    </tr>
    <tr>
        <td>ford</td>
        <td>3000.0</td>
        <td>2000-01-01</td>
    </tr>
</table>



<h4 id="5-8-限制查询结果的输出数"><a href="#5-8-限制查询结果的输出数" class="headerlink" title="5.8, 限制查询结果的输出数"></a>5.8, 限制查询结果的输出数</h4><p>用 <code>limit 行数</code> 或 <code>limit 起始, 行数</code> 限制显示数量.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">%%sql</span><br><span class="line">select * <span class="keyword">from</span> employee </span><br><span class="line">where comm <span class="keyword">is</span> null </span><br><span class="line">limit <span class="number">2</span>;</span><br></pre></td></tr></table></figure>

<pre><code> * mysql+pymysql://root:***@localhost/test
2 rows affected.</code></pre>
<table>
    <tr>
        <th>no</th>
        <th>name</th>
        <th>job</th>
        <th>mgr</th>
        <th>hiredate</th>
        <th>sal</th>
        <th>comm</th>
        <th>deptno</th>
    </tr>
    <tr>
        <td>7369</td>
        <td>smith</td>
        <td>clerk</td>
        <td>7902</td>
        <td>1981-03-12</td>
        <td>800.0</td>
        <td>None</td>
        <td>20</td>
    </tr>
    <tr>
        <td>7566</td>
        <td>jones</td>
        <td>manager</td>
        <td>7839</td>
        <td>1981-03-12</td>
        <td>2975.0</td>
        <td>None</td>
        <td>20</td>
    </tr>
</table>




<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">%%sql</span><br><span class="line">select * <span class="keyword">from</span> employee </span><br><span class="line">where comm <span class="keyword">is</span> null </span><br><span class="line">limit <span class="number">1</span>, <span class="number">2</span>;</span><br></pre></td></tr></table></figure>

<pre><code> * mysql+pymysql://root:***@localhost/test
2 rows affected.</code></pre>
<table>
    <tr>
        <th>no</th>
        <th>name</th>
        <th>job</th>
        <th>mgr</th>
        <th>hiredate</th>
        <th>sal</th>
        <th>comm</th>
        <th>deptno</th>
    </tr>
    <tr>
        <td>7566</td>
        <td>jones</td>
        <td>manager</td>
        <td>7839</td>
        <td>1981-03-12</td>
        <td>2975.0</td>
        <td>None</td>
        <td>20</td>
    </tr>
    <tr>
        <td>7698</td>
        <td>blake</td>
        <td>manager</td>
        <td>7839</td>
        <td>1981-03-12</td>
        <td>2850.0</td>
        <td>None</td>
        <td>30</td>
    </tr>
</table>



<h4 id="5-9-分组查询"><a href="#5-9-分组查询" class="headerlink" title="5.9, 分组查询"></a>5.9, 分组查询</h4><p>用分组语句 <code>group by</code> 指定分组.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">%%sql</span><br><span class="line">select avg(sal) <span class="keyword">from</span> employee </span><br><span class="line">where job=<span class="string">&#x27;clerk&#x27;</span>;  <span class="comment"># 简单分组</span></span><br></pre></td></tr></table></figure>

<pre><code> * mysql+pymysql://root:***@localhost/test
1 rows affected.</code></pre>
<table>
    <tr>
        <th>avg(sal)</th>
    </tr>
    <tr>
        <td>1037.5</td>
    </tr>
</table>




<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">%%sql</span><br><span class="line">select name, job, avg(sal) <span class="string">&#x27;平均薪资&#x27;</span> <span class="keyword">from</span> employee</span><br><span class="line">group by job;  <span class="comment"># 按job 分组, name 只显示第一个</span></span><br></pre></td></tr></table></figure>

<pre><code> * mysql+pymysql://root:***@localhost/test
5 rows affected.</code></pre>
<table>
    <tr>
        <th>name</th>
        <th>job</th>
        <th>平均薪资</th>
    </tr>
    <tr>
        <td>scott</td>
        <td>analyst</td>
        <td>3000.0</td>
    </tr>
    <tr>
        <td>smith</td>
        <td>clerk</td>
        <td>1037.5</td>
    </tr>
    <tr>
        <td>jones</td>
        <td>manager</td>
        <td>2758.333333</td>
    </tr>
    <tr>
        <td>king</td>
        <td>president</td>
        <td>5000.0</td>
    </tr>
    <tr>
        <td>allen</td>
        <td>salesman</td>
        <td>1400.0</td>
    </tr>
</table>




<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">%%sql</span><br><span class="line">select </span><br><span class="line">    group_concat(name) <span class="string">&#x27;所有员工&#x27;</span>,  <span class="comment"># 显示所有 name</span></span><br><span class="line">    job, </span><br><span class="line">    avg(sal) </span><br><span class="line">    <span class="keyword">from</span> employee</span><br><span class="line">group by job;</span><br></pre></td></tr></table></figure>

<pre><code> * mysql+pymysql://root:***@localhost/test
5 rows affected.</code></pre>
<table>
    <tr>
        <th>所有员工</th>
        <th>job</th>
        <th>avg(sal)</th>
    </tr>
    <tr>
        <td>scott,ford</td>
        <td>analyst</td>
        <td>3000.0</td>
    </tr>
    <tr>
        <td>smith,adams,james,miller</td>
        <td>clerk</td>
        <td>1037.5</td>
    </tr>
    <tr>
        <td>jones,blake,clark</td>
        <td>manager</td>
        <td>2758.333333</td>
    </tr>
    <tr>
        <td>king</td>
        <td>president</td>
        <td>5000.0</td>
    </tr>
    <tr>
        <td>allen,ward,martin,turner</td>
        <td>salesman</td>
        <td>1400.0</td>
    </tr>
</table>




<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">%%sql</span><br><span class="line">select </span><br><span class="line">    deptno, </span><br><span class="line">    group_concat(name, <span class="string">&#x27;:&#x27;</span>, sal order by sal desc) names </span><br><span class="line">    <span class="keyword">from</span> employee </span><br><span class="line">group by deptno;</span><br></pre></td></tr></table></figure>

<pre><code> * mysql+pymysql://root:***@localhost/test
3 rows affected.</code></pre>
<table>
    <tr>
        <th>deptno</th>
        <th>names</th>
    </tr>
    <tr>
        <td>10</td>
        <td>king:5000.00,clark:2450.00,miller:1300.00</td>
    </tr>
    <tr>
        <td>20</td>
        <td>ford:3000.00,scott:3000.00,jones:2975.00,adams:1100.00,smith:800.00</td>
    </tr>
    <tr>
        <td>30</td>
        <td>blake:2850.00,allen:1600.00,turner:1500.00,martin:1250.00,ward:1250.00,james:950.00</td>
    </tr>
</table>




<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">%%sql</span><br><span class="line">select </span><br><span class="line">    deptno, </span><br><span class="line">    hiredate, </span><br><span class="line">    group_concat(name) names, </span><br><span class="line">    count(name) </span><br><span class="line">    <span class="keyword">from</span> employee</span><br><span class="line">group by deptno, hiredate;</span><br></pre></td></tr></table></figure>

<pre><code> * mysql+pymysql://root:***@localhost/test
10 rows affected.</code></pre>
<table>
    <tr>
        <th>deptno</th>
        <th>hiredate</th>
        <th>names</th>
        <th>count(name)</th>
    </tr>
    <tr>
        <td>10</td>
        <td>1981-03-12</td>
        <td>king,miller</td>
        <td>2</td>
    </tr>
    <tr>
        <td>10</td>
        <td>1985-03-12</td>
        <td>clark</td>
        <td>1</td>
    </tr>
    <tr>
        <td>20</td>
        <td>1981-03-12</td>
        <td>smith,jones,scott</td>
        <td>3</td>
    </tr>
    <tr>
        <td>20</td>
        <td>1998-03-12</td>
        <td>adams</td>
        <td>1</td>
    </tr>
    <tr>
        <td>20</td>
        <td>2000-01-01</td>
        <td>ford</td>
        <td>1</td>
    </tr>
    <tr>
        <td>30</td>
        <td>1981-03-12</td>
        <td>martin,blake</td>
        <td>2</td>
    </tr>
    <tr>
        <td>30</td>
        <td>1982-03-12</td>
        <td>allen</td>
        <td>1</td>
    </tr>
    <tr>
        <td>30</td>
        <td>1983-03-12</td>
        <td>ward</td>
        <td>1</td>
    </tr>
    <tr>
        <td>30</td>
        <td>1989-03-12</td>
        <td>turner</td>
        <td>1</td>
    </tr>
    <tr>
        <td>30</td>
        <td>1997-03-12</td>
        <td>james</td>
        <td>1</td>
    </tr>
</table>



<h4 id="5-10-having-条件查询"><a href="#5-10-having-条件查询" class="headerlink" title="5.10, having 条件查询"></a>5.10, having 条件查询</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">%%sql</span><br><span class="line">select name, sal <span class="keyword">from</span> employee</span><br><span class="line">having sal &gt; <span class="number">2000</span>;  <span class="comment"># 最好用 where, 能用 where 的地方最好用 where</span></span><br></pre></td></tr></table></figure>

<pre><code> * mysql+pymysql://root:***@localhost/test
6 rows affected.</code></pre>
<table>
    <tr>
        <th>name</th>
        <th>sal</th>
    </tr>
    <tr>
        <td>jones</td>
        <td>2975.0</td>
    </tr>
    <tr>
        <td>blake</td>
        <td>2850.0</td>
    </tr>
    <tr>
        <td>clark</td>
        <td>2450.0</td>
    </tr>
    <tr>
        <td>scott</td>
        <td>3000.0</td>
    </tr>
    <tr>
        <td>king</td>
        <td>5000.0</td>
    </tr>
    <tr>
        <td>ford</td>
        <td>3000.0</td>
    </tr>
</table>




<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">%%sql</span><br><span class="line">select </span><br><span class="line">    group_concat(<span class="string">&#x27; &#x27;</span>, name) names, </span><br><span class="line">    deptno, </span><br><span class="line">    avg(sal) ag </span><br><span class="line">    <span class="keyword">from</span> employee</span><br><span class="line">group by deptno</span><br><span class="line">having ag &gt; <span class="number">2000</span> <span class="keyword">and</span> names like <span class="string">&#x27;%m%&#x27;</span>;  <span class="comment"># 不能用 name</span></span><br></pre></td></tr></table></figure>

<pre><code> * mysql+pymysql://root:***@localhost/test
2 rows affected.</code></pre>
<table>
    <tr>
        <th>names</th>
        <th>deptno</th>
        <th>ag</th>
    </tr>
    <tr>
        <td> clark, king, miller</td>
        <td>10</td>
        <td>2916.666667</td>
    </tr>
    <tr>
        <td> smith, jones, scott, adams, ford</td>
        <td>20</td>
        <td>2175.0</td>
    </tr>
</table>
]]></content>
      <categories>
        <category>数据分析</category>
      </categories>
      <tags>
        <tag>Mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>腾讯/阿里云服务器 + Hexo 部署个人网站</title>
    <url>/other/Build-a-blog-ed67779a8537/</url>
    <content><![CDATA[<blockquote>
<p>用 Hexo 部署自己的静态网站上云, 没有想象的那么难, 如果有兴趣, 可以在 github, gitee, coding 等免费平台熟悉一下.</p>
</blockquote>
<h2 id="前期准备"><a href="#前期准备" class="headerlink" title="前期准备"></a>前期准备</h2><h3 id="1-购买一台云服务器"><a href="#1-购买一台云服务器" class="headerlink" title="1, 购买一台云服务器"></a>1, 购买一台云服务器</h3><ul>
<li><a href="https://cloud.tencent.com/act">腾讯云服务器</a>.</li>
<li><a href="https://www.aliyun.com/activity?spm=a2cle.14465449.h2v3icoap.1.2e8e1d682iAEpi#/promotionArea">阿里云服务器</a>.</li>
</ul>
<h3 id="2-本地安装-Hexo"><a href="#2-本地安装-Hexo" class="headerlink" title="2, 本地安装 Hexo"></a>2, 本地安装 Hexo</h3><ul>
<li><a href="https://hexo.io/zh-cn/docs/">Hexo 官方网站</a>, 有详细的安装配置教程, 同时必须安装 <code>Node.js</code> 和 <code>Git</code>. 教程都有, 不再累述.</li>
</ul>
<h2 id="云服务器端安装和配置-腾讯为例"><a href="#云服务器端安装和配置-腾讯为例" class="headerlink" title="云服务器端安装和配置(腾讯为例)"></a>云服务器端安装和配置(腾讯为例)</h2><h3 id="1-登陆"><a href="#1-登陆" class="headerlink" title="1, 登陆"></a>1, 登陆</h3><ul>
<li><p>登陆<code>腾讯云</code>, 进入<code>控制台</code>, 点击<code>云服务器</code>, 即可看见购买的服务器, 我的是 CentOS 系统.</p>
</li>
<li><p><code>消息中心</code>查看自己的服务器初始密码, 回到服务器点击<code>登陆</code>, 以<code>推荐</code>方式输入密码即可登陆.</p>
</li>
</ul>
<h3 id="2-安装和配置-git"><a href="#2-安装和配置-git" class="headerlink" title="2, 安装和配置 git"></a>2, 安装和配置 git</h3><ul>
<li><p>更新 CentOS 系统.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum -y update</span><br></pre></td></tr></table></figure>
</li>
<li><p>卸载 git 过低版本.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git --version      # 查看 git 版本</span><br><span class="line">yum remove git     # 卸载低版本 git</span><br></pre></td></tr></table></figure></li>
<li><p>安装 git 依赖库.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum install curl-devel expat-devel gettext-devel openssl-devel zlib-devel</span><br></pre></td></tr></table></figure></li>
<li><p>安装编译工具.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum install gcc perl-ExtUtils-MakeMaker package</span><br></pre></td></tr></table></figure>
</li>
<li><p>下载并安装 <code>git</code>到 <code>/usr/local/git</code> 文件夹里.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 选择将安装包下载到如下文件夹</span><br><span class="line">cd &#x2F;usr&#x2F;local&#x2F;src</span><br><span class="line"></span><br><span class="line"># 下载</span><br><span class="line">wget https:&#x2F;&#x2F;www.kernel.org&#x2F;pub&#x2F;software&#x2F;scm&#x2F;git&#x2F;git-2.16.2.tar.gz</span><br><span class="line"></span><br><span class="line"># 解压 git-2.16.2.tar.gz</span><br><span class="line">tar -zvxf git-2.16.2.tar.gz</span><br><span class="line"></span><br><span class="line"># 进入 git-2.16.2.tar.gz 目录</span><br><span class="line">cd git-2.16.2</span><br><span class="line"></span><br><span class="line"># 执行编译</span><br><span class="line">make all prefix&#x3D;&#x2F;usr&#x2F;local&#x2F;git</span><br><span class="line"></span><br><span class="line"># 安装 git 到 &#x2F;usr&#x2F;local&#x2F;git 目录下</span><br><span class="line">make install prefix&#x3D;&#x2F;usr&#x2F;local&#x2F;git</span><br></pre></td></tr></table></figure></li>
<li><p>配置 git 环境变量</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 将 git 加入 PATH 目录中</span><br><span class="line">echo &#39;export PATH&#x3D;$PATH:&#x2F;usr&#x2F;local&#x2F;git&#x2F;bin&#39; &gt;&gt; &#x2F;etc&#x2F;bashrc</span><br><span class="line"></span><br><span class="line"># 使 git 环境变量生效</span><br><span class="line">source &#x2F;etc&#x2F;bashrc</span><br></pre></td></tr></table></figure></li>
<li><p>验证 git 是否安装成功</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 如果查看到版本号, 成功</span><br><span class="line">git --version</span><br></pre></td></tr></table></figure></li>
<li><p>创建 <code>hexoBlog.git</code> 仓库，用于存放博客网站资源.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 创建 home&#x2F;git 目录</span><br><span class="line">mkdir &#x2F;home&#x2F;git&#x2F;</span><br><span class="line"></span><br><span class="line"># 修改目录权限</span><br><span class="line">chown -R $USER:$USER &#x2F;home&#x2F;git&#x2F;</span><br><span class="line">chmod -R 755 &#x2F;home&#x2F;git&#x2F;</span><br><span class="line"></span><br><span class="line"># 进入目录</span><br><span class="line">cd &#x2F;home&#x2F;git&#x2F;</span><br><span class="line"></span><br><span class="line"># 创建一个裸的 hexoBlog.git 仓库</span><br><span class="line">git init --bare hexoBlog.git</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建一个 git 钩子, 用于自动部署.<br>1, 在 <code>/home/git/hexoBlog.git</code> 下，有一个自动生成的 <code>hooks</code> 文件夹. 我们需要在里边新建一个新的钩子文件 <code>post-receive</code>.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vim &#x2F;home&#x2F;git&#x2F;hexoBlog.git&#x2F;hooks&#x2F;post-receive</span><br></pre></td></tr></table></figure>
<p>2, 按 <code>i</code> 键进入编辑模式，在该文件中复制粘贴两行代码.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!&#x2F;bin&#x2F;bash</span><br><span class="line">git --work-tree&#x3D;&#x2F;home&#x2F;hexoBlog --git-dir&#x3D;&#x2F;home&#x2F;git&#x2F;hexoBlog.git checkout -f</span><br></pre></td></tr></table></figure>
<p>3, 按 <code>Esc</code> 键退出编辑模式，输入<code>:wq</code> 保存退出.</p>
<p>4, 修改文件权限，使得其可执行.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">chmod +x &#x2F;home&#x2F;git&#x2F;hexoBlog.git&#x2F;hooks&#x2F;post-receive</span><br></pre></td></tr></table></figure>

<p>到这里，git 安装配置完毕.</p>
</li>
</ul>
<h3 id="3-安装和配置-Nginx"><a href="#3-安装和配置-Nginx" class="headerlink" title="3, 安装和配置 Nginx"></a>3, 安装和配置 Nginx</h3><ul>
<li><p>安装 Nginx.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum install -y nginx</span><br></pre></td></tr></table></figure></li>
<li><p>启动 Nginx.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">service nginx start</span><br></pre></td></tr></table></figure></li>
<li><p>创建 <code>/home/hexoBlog</code> 目录，用于 Nginx 托管文件.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mkdir &#x2F;home&#x2F;hexoBlog&#x2F;</span><br><span class="line">chown -R $USER:$USER &#x2F;home&#x2F;hexoBlog&#x2F;</span><br><span class="line">chmod -R 755 &#x2F;home&#x2F;hexoBlog&#x2F;</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看 Nginx 的默认配置的安装位置.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nginx -t</span><br></pre></td></tr></table></figure>
</li>
<li><p>修改Nginx的默认配置.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vim &#x2F;etc&#x2F;nginx&#x2F;nginx.conf</span><br></pre></td></tr></table></figure>

<p>按方向键，找到如下位置:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">  listen 80 default_server;</span><br><span class="line">  listen [::]:80 default_server;</span><br><span class="line">  root &#x2F;home&#x2F;hexoBlog;    # 修改</span><br><span class="line">  </span><br><span class="line">  server_name www.billwuhao.com; # 修改</span><br><span class="line">  </span><br><span class="line">  # Load configuration files for the default server block.</span><br><span class="line">  include &#x2F;etc&#x2F;nginx&#x2F;default.d&#x2F;*.conf;</span><br><span class="line">  location &#x2F; &#123;</span><br><span class="line">  &#125;</span><br><span class="line">  error_page 404 &#x2F;404.html;</span><br><span class="line">      location &#x3D; &#x2F;40x.html &#123;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>将其中的 <code>roo</code>t 之后改为 <code>/home/hexoBlog</code>, 将 <code>server_name</code> 之后改成你的域名, 如暂无域名, 改成服务器公网 ip .</p>
</li>
<li><p>添加 <code>index.html</code> 文件用于检测配置 Nginx 是否成功.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vim &#x2F;home&#x2F;hexoBlog&#x2F;index.html</span><br></pre></td></tr></table></figure>
<p>添加如下代码:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">  &lt;head&gt;</span><br><span class="line">    &lt;title&gt;&lt;&#x2F;title&gt;</span><br><span class="line">    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;</span><br><span class="line">  &lt;&#x2F;head&gt;</span><br><span class="line">  &lt;body&gt;</span><br><span class="line">    &lt;p&gt;Nginx running&lt;&#x2F;p&gt;</span><br><span class="line">  &lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>重启 Nginx 服务</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">service nginx restart</span><br></pre></td></tr></table></figure></li>
<li><p>访问服务器 <code>IP</code> 或者<code>域名</code>显示 <code>Nginx running</code>, 则 Nginx 配置成功.</p>
</li>
</ul>
<h2 id="本地配置和部署"><a href="#本地配置和部署" class="headerlink" title="本地配置和部署"></a>本地配置和部署</h2><h3 id="1-配置本地-Hexo-配置文件"><a href="#1-配置本地-Hexo-配置文件" class="headerlink" title="1, 配置本地 Hexo 配置文件"></a>1, 配置本地 Hexo 配置文件</h3><p>  默认已按官网完成相关安装和配置<br>  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: root@你的云服务器的IP地址:&#x2F;home&#x2F;git&#x2F;hexoBlog.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure></p>
<h3 id="2-将网站部署上云"><a href="#2-将网站部署上云" class="headerlink" title="2, 将网站部署上云"></a>2, 将网站部署上云</h3><p>  <code>cd</code> 到你的本地网站目录<br>  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo g</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure><br>  输入云服务器端<code>服务器的登陆密码</code>, 即可成功部署, 打开自己的域名, 或公网 IP, 即可查看. 顺便宣传一下自己的站点:<br>  next 主题: <a href="billwuhao.com">WuHao’s official website</a><br>  stun 主题: <a href="billwuhao.github.io">WuHao’s official website</a></p>
<h3 id="3-无需输入密码部署"><a href="#3-无需输入密码部署" class="headerlink" title="3, 无需输入密码部署"></a>3, 无需输入密码部署</h3><ul>
<li>默认已经生成了密钥, 我的密钥是之前部署到 github 时生成的, 怎么生成密钥: <a href="https://cloud.tencent.com/document/product/213/16691#creatSSH">腾讯云, 管理 SSH 密钥</a>, 试了试没成功.</li>
<li>我的方法: 登陆腾讯云, 进入控制台, 在服务器最后点击<code>更多</code>, 点击<code>密码/密钥</code>, 点击<code>加载密钥</code>, 复制本地公钥粘贴进去, 保存, 从此自动用密钥部署, 不需要输入密码.</li>
</ul>
<h2 id="部署上阿里云"><a href="#部署上阿里云" class="headerlink" title="部署上阿里云"></a>部署上阿里云</h2><p>  查看: <a href="https://mp.weixin.qq.com/s/Ff_7X6u82chWspTsigFv9w">手把手教你从零搭建和部署自己的个人博客</a></p>
<p>  注意点:<br>  1, 安全组的配置, 阿里云有提示.<br>  2, 开放 linux 的 80 端口命令有误, 改为:<br>  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;sbin&#x2F;iptables -I INPUT -p tcp --dport 80 -j ACCEPT </span><br></pre></td></tr></table></figure><br>  3, 其他按照教程无脑操作.</p>
<br>

<hr>
<p>参考文章: <a href="https://bujige.net/blog/hexoBlog-deployed-server.html">Hexo 博客部署到腾讯云教程</a></p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>建站</tag>
      </tags>
  </entry>
  <entry>
    <title>综合实践练习</title>
    <url>/data/case-ede78215895b/</url>
    <content><![CDATA[<blockquote>
<p>通过每个经典习题和案例, 逐步进行逻辑拆分和梳理, 熟练掌握数据分析工具的运用, 强化数据分析相关知识点的学习记忆和运用, 以求融汇贯通, 增强实践能力, 培养数据分析思维和方法论.</p>
</blockquote>
<br>

<p><font color=#00A600 >2020年5月6日更新</font></p>
<br>

<h2 id="练习-1-北京全年天气分析"><a href="#练习-1-北京全年天气分析" class="headerlink" title="练习 1, 北京全年天气分析"></a>练习 1, 北京全年天气分析</h2><blockquote>
<p>可能用其他方法更快, 比如 excel, 但主要是用来强化数据分析知识点运用, 数据量小, 代表性不强</p>
</blockquote>
<p>读取数据, 看看数据构成</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line">data = pd.read_csv(<span class="string">&#x27;./BJ_tianqi.csv&#x27;</span>)</span><br><span class="line">data.head()</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th></th>
<th>日期</th>
<th>最高温度</th>
<th>最低温度</th>
<th>天气</th>
<th>风向</th>
<th>风级</th>
<th>空气质量</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>2019/1/1</td>
<td>1℃</td>
<td>-10℃</td>
<td>晴~多云</td>
<td>西北风</td>
<td>1级</td>
<td>良</td>
</tr>
<tr>
<td>1</td>
<td>2019/1/2</td>
<td>1℃</td>
<td>-9℃</td>
<td>多云</td>
<td>东北风</td>
<td>1级</td>
<td>良</td>
</tr>
<tr>
<td>2</td>
<td>2019/1/3</td>
<td>2℃</td>
<td>-7℃</td>
<td>霾</td>
<td>东北风</td>
<td>1级</td>
<td>中度污染</td>
</tr>
<tr>
<td>3</td>
<td>2019/1/4</td>
<td>2℃</td>
<td>-7℃</td>
<td>晴</td>
<td>西北风</td>
<td>2级</td>
<td>优</td>
</tr>
<tr>
<td>4</td>
<td>2019/1/5</td>
<td>0℃</td>
<td>-8℃</td>
<td>多云</td>
<td>东北风</td>
<td>2级</td>
<td>优</td>
</tr>
</tbody></table>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">data.info()   <span class="comment"># 查看数据基本信息, 输出如下:</span></span><br><span class="line"></span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> &#x27;<span class="title">pandas</span>.<span class="title">core</span>.<span class="title">frame</span>.<span class="title">DataFrame</span>&#x27;&gt;</span></span><br><span class="line"><span class="class"><span class="title">RangeIndex</span>:</span> <span class="number">365</span> entries, <span class="number">0</span> to <span class="number">364</span></span><br><span class="line">Data columns (total <span class="number">7</span> columns):</span><br><span class="line"> <span class="comment">#   Column  Non-Null Count  Dtype </span></span><br><span class="line">---  ------  --------------  ----- </span><br><span class="line"> <span class="number">0</span>   日期      <span class="number">365</span> non-null    <span class="built_in">object</span></span><br><span class="line"> <span class="number">1</span>   最高温度    <span class="number">365</span> non-null    <span class="built_in">object</span></span><br><span class="line"> <span class="number">2</span>   最低温度    <span class="number">365</span> non-null    <span class="built_in">object</span></span><br><span class="line"> <span class="number">3</span>   天气      <span class="number">365</span> non-null    <span class="built_in">object</span></span><br><span class="line"> <span class="number">4</span>   风向      <span class="number">365</span> non-null    <span class="built_in">object</span></span><br><span class="line"> <span class="number">5</span>   风级      <span class="number">365</span> non-null    <span class="built_in">object</span></span><br><span class="line"> <span class="number">6</span>   空气质量    <span class="number">365</span> non-null    <span class="built_in">object</span></span><br><span class="line">dtypes: <span class="built_in">object</span>(<span class="number">7</span>)</span><br><span class="line">memory usage: <span class="number">20.1</span>+ KB</span><br></pre></td></tr></table></figure>

<p>得到一些对数据处理有用的信息:<br>365行, 7列; 数据干净,无需清洗; 无空值; 日期类型为 <code>object</code>; 温度数据后面有 <code>℃</code>符号.</p>
<p>数据处理</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 将温度数据去掉 ℃ 转换成 int 类型</span></span><br><span class="line">data.loc[:, <span class="string">&#x27;最高温度&#x27;</span>] = data[<span class="string">&#x27;最高温度&#x27;</span>].<span class="built_in">str</span>.replace(<span class="string">&#x27;℃&#x27;</span>, <span class="string">&#x27;&#x27;</span>).astype(<span class="string">&#x27;int32&#x27;</span>)</span><br><span class="line">data.loc[:, <span class="string">&#x27;最低温度&#x27;</span>] = data[<span class="string">&#x27;最低温度&#x27;</span>].<span class="built_in">str</span>.replace(<span class="string">&#x27;℃&#x27;</span>, <span class="string">&#x27;&#x27;</span>).astype(<span class="string">&#x27;int32&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将日期设置为索引(保留原时间列)</span></span><br><span class="line">data.set_index(<span class="string">&#x27;日期&#x27;</span>, inplace=<span class="literal">True</span>, drop=<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加两个辅助列 温差 和 温差类型(温差大于 10 为大温差)</span></span><br><span class="line">data.loc[:, <span class="string">&#x27;温差&#x27;</span>] = data[<span class="string">&#x27;最高温度&#x27;</span>] - data[<span class="string">&#x27;最低温度&#x27;</span>]</span><br><span class="line">data.loc[:, <span class="string">&quot;温差类型&quot;</span>] = [<span class="string">&#x27;大温差&#x27;</span> <span class="keyword">if</span> value &gt;= <span class="number">10</span> <span class="keyword">else</span> <span class="string">&#x27;正常&#x27;</span> <span class="keyword">for</span> value <span class="keyword">in</span> data[<span class="string">&#x27;温差&#x27;</span>]]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 再次查看数据</span></span><br><span class="line">data.head()</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th></th>
<th>日期</th>
<th>最高温度</th>
<th>最低温度</th>
<th>天气</th>
<th>风向</th>
<th>风级</th>
<th>空气质量</th>
<th>温差</th>
<th>温差类型</th>
</tr>
</thead>
<tbody><tr>
<td>日期</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>2019/1/1</td>
<td>2019/1/1</td>
<td>1</td>
<td>-10</td>
<td>晴~多云</td>
<td>西北风</td>
<td>1级</td>
<td>良</td>
<td>11</td>
<td>大温差</td>
</tr>
<tr>
<td>2019/1/2</td>
<td>2019/1/2</td>
<td>1</td>
<td>-9</td>
<td>多云</td>
<td>东北风</td>
<td>1级</td>
<td>良</td>
<td>10</td>
<td>大温差</td>
</tr>
<tr>
<td>2019/1/3</td>
<td>2019/1/3</td>
<td>2</td>
<td>-7</td>
<td>霾</td>
<td>东北风</td>
<td>1级</td>
<td>中度污染</td>
<td>9</td>
<td>正常</td>
</tr>
<tr>
<td>2019/1/4</td>
<td>2019/1/4</td>
<td>2</td>
<td>-7</td>
<td>晴</td>
<td>西北风</td>
<td>2级</td>
<td>优</td>
<td>9</td>
<td>正常</td>
</tr>
<tr>
<td>2019/1/5</td>
<td>2019/1/5</td>
<td>0</td>
<td>-8</td>
<td>多云</td>
<td>东北风</td>
<td>2级</td>
<td>优</td>
<td>8</td>
<td>正常</td>
</tr>
</tbody></table>
<p>获取想要的数据信息</p>
<p>1, 看看全年温度最高那一天的信息: </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">data.sort_values(<span class="string">&#x27;最高温度&#x27;</span>).iloc[<span class="number">-1</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">日期      <span class="number">2019</span>/<span class="number">7</span>/<span class="number">4</span></span><br><span class="line">最高温度          <span class="number">38</span></span><br><span class="line">最低温度          <span class="number">25</span></span><br><span class="line">天气          晴~多云</span><br><span class="line">风向           西南风</span><br><span class="line">风级            <span class="number">2</span>级</span><br><span class="line">空气质量           良</span><br><span class="line">温差            <span class="number">13</span></span><br><span class="line">温差类型         大温差</span><br><span class="line">Name: <span class="number">2019</span>/<span class="number">7</span>/<span class="number">4</span>, dtype: <span class="built_in">object</span></span><br></pre></td></tr></table></figure>

<p>2, 看看 8 月的天气情况:</p>
<ul>
<li>方法一: 转换索引取值</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">index_list = data.index.tolist()</span><br><span class="line">result = [i.startswith(<span class="string">&#x27;2019/8&#x27;</span>) <span class="keyword">for</span> i <span class="keyword">in</span> index_list]</span><br><span class="line">data.loc[result]</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th></th>
<th>日期</th>
<th>最高温度</th>
<th>最低温度</th>
<th>天气</th>
<th>风向</th>
<th>风级</th>
<th>空气质量</th>
<th>温差</th>
<th>温差类型</th>
</tr>
</thead>
<tbody><tr>
<td>日期</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>2019/8/1</td>
<td>2019/8/1</td>
<td>32</td>
<td>24</td>
<td>中雨~雷阵雨</td>
<td>东南风</td>
<td>2级</td>
<td>良</td>
<td>8</td>
<td>正常</td>
</tr>
<tr>
<td>2019/8/2</td>
<td>2019/8/2</td>
<td>30</td>
<td>24</td>
<td>雷阵雨~小雨</td>
<td>东南风</td>
<td>2级</td>
<td>良</td>
<td>6</td>
<td>正常</td>
</tr>
<tr>
<td>2019/8/3</td>
<td>2019/8/3</td>
<td>31</td>
<td>24</td>
<td>阴</td>
<td>东南风</td>
<td>2级</td>
<td>良</td>
<td>7</td>
<td>正常</td>
</tr>
</tbody></table>
<ul>
<li>方法二: 时间索引取值</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">data.index = pd.to_datetime(data.index, <span class="built_in">format</span>=<span class="string">&#x27;%Y/%m/%d&#x27;</span>)</span><br><span class="line">data[<span class="string">&#x27;2019-8&#x27;</span>]</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th></th>
<th>日期</th>
<th>最高温度</th>
<th>最低温度</th>
<th>天气</th>
<th>风向</th>
<th>风级</th>
<th>空气质量</th>
<th>温差</th>
<th>温差类型</th>
</tr>
</thead>
<tbody><tr>
<td>日期</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>2019-08-01</td>
<td>2019/8/1</td>
<td>32</td>
<td>24</td>
<td>中雨~雷阵雨</td>
<td>东南风</td>
<td>2级</td>
<td>良</td>
<td>8</td>
<td>正常</td>
</tr>
<tr>
<td>2019-08-02</td>
<td>2019/8/2</td>
<td>30</td>
<td>24</td>
<td>雷阵雨~小雨</td>
<td>东南风</td>
<td>2级</td>
<td>良</td>
<td>6</td>
<td>正常</td>
</tr>
</tbody></table>
<ul>
<li>方法三: 时间序列取值, 此方法对后面的分析更加便捷</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">data[<span class="string">&#x27;日期&#x27;</span>] = pd.to_datetime(data[<span class="string">&#x27;日期&#x27;</span>], <span class="built_in">format</span>=<span class="string">&#x27;%Y/%m/%d&#x27;</span>)</span><br><span class="line">data[<span class="string">&#x27;月份&#x27;</span>] = data[<span class="string">&#x27;日期&#x27;</span>].dt.month</span><br><span class="line">data[data[<span class="string">&#x27;月份&#x27;</span>]==<span class="number">8</span>]</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th></th>
<th>日期</th>
<th>最高温度</th>
<th>最低温度</th>
<th>天气</th>
<th>风向</th>
<th>风级</th>
<th>空气质量</th>
<th>温差</th>
<th>温差类型</th>
<th>月份</th>
</tr>
</thead>
<tbody><tr>
<td>日期</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>2019-08-01</td>
<td>2019-08-01</td>
<td>32</td>
<td>24</td>
<td>中雨~雷阵雨</td>
<td>东南风</td>
<td>2级</td>
<td>良</td>
<td>8</td>
<td>正常</td>
<td>8</td>
</tr>
<tr>
<td>2019-08-02</td>
<td>2019-08-02</td>
<td>30</td>
<td>24</td>
<td>雷阵雨~小雨</td>
<td>东南风</td>
<td>2级</td>
<td>良</td>
<td>6</td>
<td>正常</td>
<td>8</td>
</tr>
</tbody></table>
<p>3, 看看全年的风向:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">data.loc[:, <span class="string">&#x27;风向&#x27;</span>].value_counts()</span><br><span class="line"></span><br><span class="line">结果: </span><br><span class="line">东南风    <span class="number">104</span>    <span class="comment"># 东南风 104 天最多</span></span><br><span class="line">西北风    <span class="number">100</span></span><br><span class="line">西南风     <span class="number">81</span></span><br><span class="line">东北风     <span class="number">78</span></span><br><span class="line">南风       <span class="number">1</span></span><br><span class="line">北风       <span class="number">1</span></span><br><span class="line">Name: 风向, dtype: int64</span><br></pre></td></tr></table></figure>

<p>4, 看看<code>大温差</code>集中在哪些月份:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 拆分日期, 并添加辅助列 月份</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">split_date</span>(<span class="params">date</span>):</span></span><br><span class="line">    position = date.rfind(<span class="string">&#x27;/&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> date[<span class="number">5</span>:position]</span><br><span class="line"></span><br><span class="line">data[<span class="string">&#x27;月份&#x27;</span>] = data[<span class="string">&#x27;日期&#x27;</span>].apply(split_date).astype(<span class="built_in">int</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 以 月份 为键, 对 大温差 分组</span></span><br><span class="line">groups = data[data[<span class="string">&#x27;温差类型&#x27;</span>]==<span class="string">&#x27;大温差&#x27;</span>].groupby(data[<span class="string">&#x27;月份&#x27;</span>])</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 可视化显示中文</span></span><br><span class="line">plt.rcParams[<span class="string">&#x27;font.sans-serif&#x27;</span>] = [<span class="string">&#x27;SimHei&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 以 月份 和 大温差天数 做柱状图</span></span><br><span class="line"><span class="keyword">for</span> group_name, group <span class="keyword">in</span> groups:</span><br><span class="line">    plt.bar(<span class="string">f&#x27;<span class="subst">&#123;group_name&#125;</span>月&#x27;</span>, group[<span class="string">&#x27;温差类型&#x27;</span>].count())</span><br></pre></td></tr></table></figure>

<br>

<br>

<h2 id="练习-2"><a href="#练习-2" class="headerlink" title="练习 2,"></a>练习 2,</h2>]]></content>
      <categories>
        <category>数据分析</category>
      </categories>
      <tags>
        <tag>数据分析案例</tag>
      </tags>
  </entry>
  <entry>
    <title>matplotlib</title>
    <url>/data/matplotlib-bfa2528613f9/</url>
    <content><![CDATA[<blockquote>
<p>整理 matplotlib 基础知识点, 快速入门, 然后在练习和实践中慢慢提升</p>
</blockquote>
<p><font color=#00A600 >2020年6月28日更新</font></p>
<p><a href="https://matplotlib.org/">matpotlib官网</a></p>
<h2 id="1-以一个例子开始"><a href="#1-以一个例子开始" class="headerlink" title="1, 以一个例子开始"></a>1, 以一个例子开始</h2><p>matpotlib 绘图非常灵活, 方法和参数繁多, 同样的效果, 可以有很多实现方法, 因此常常让人很混乱和困惑, 理解了绘图的层级结构, 使用起来更得心应手:</p>
<p><img src="https://wx2.sbimg.cn/2020/07/01/2wlRe.jpg"></p>
<p>下面将其分四个层级来作说明: 画布 Figure, 绘图对象 Axes, 坐标和图像, 以及图像调整和辅助描述</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 导入库</span></span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">设置 rc 参数: 可以用来修改图形的各种默认属性</span></span><br><span class="line"><span class="string">包括窗体大小, 线条宽度, 颜色, 符号, 字体等等</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">plt.rcParams[<span class="string">&#x27;font.family&#x27;</span>] = <span class="string">&#x27;YouYuan&#x27;</span> <span class="comment"># 字体</span></span><br><span class="line">plt.rcParams[<span class="string">&#x27;font.size&#x27;</span>] = <span class="number">18</span> <span class="comment"># 全体字体大小</span></span><br><span class="line">plt.rcParams[<span class="string">&#x27;legend.fontsize&#x27;</span>] = <span class="number">12</span> <span class="comment"># 图例标签字体大小</span></span><br><span class="line">plt.rcParams[<span class="string">&#x27;axes.unicode_minus&#x27;</span>] = <span class="literal">False</span> <span class="comment"># 正常显示符号</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建画布对象 Figure, 可以设置大小等</span></span><br><span class="line">fig = plt.figure()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 用 add_subplot()在画布上面创建绘图对象 Axes, 默认创建一个</span></span><br><span class="line"><span class="comment"># 也可以用 subplots() 直接将 Figure 和 Axes 一起创建</span></span><br><span class="line">ax = fig.add_subplot()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在绘图对象 ax 上绘图, 并设置标签</span></span><br><span class="line">x = <span class="built_in">range</span>(<span class="number">-9</span>, <span class="number">10</span>)</span><br><span class="line">y = [n**<span class="number">3</span> <span class="keyword">for</span> n <span class="keyword">in</span> x]</span><br><span class="line">ax.plot(x, y, label=<span class="string">&#x27;曲线&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 绘制点 P(5, 125)</span></span><br><span class="line">ax.scatter(<span class="number">5</span>, <span class="number">125</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 绘制曲线过 P 点的切线</span></span><br><span class="line">y1 = [<span class="number">3</span>*(<span class="number">5</span>**<span class="number">2</span>)*(m - <span class="number">5</span>) + <span class="number">125</span> <span class="keyword">for</span> m <span class="keyword">in</span> x]</span><br><span class="line">ax.plot(x, y1, label=<span class="string">&#x27;切线&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 一次性设置 ax 的多个属性</span></span><br><span class="line">ax.<span class="built_in">set</span>(title=<span class="string">&#x27;y=x**3&#x27;</span>, <span class="comment"># ax 标题</span></span><br><span class="line">       xlabel=<span class="string">&#x27;x&#x27;</span>, <span class="comment"># x轴标题</span></span><br><span class="line">       ylabel=<span class="string">&#x27;y&#x27;</span>, <span class="comment"># y轴标题</span></span><br><span class="line">       xlim=(<span class="number">-10</span>,<span class="number">10</span>), <span class="comment"># x轴范围</span></span><br><span class="line">       ylim=(<span class="number">-500</span>, <span class="number">600</span>), <span class="comment"># y轴范围</span></span><br><span class="line">       xticks=<span class="built_in">range</span>(<span class="number">-10</span>, <span class="number">11</span>, <span class="number">2</span>), <span class="comment"># x轴刻度和标签</span></span><br><span class="line">       yticks=<span class="built_in">range</span>(<span class="number">-500</span>, <span class="number">600</span>, <span class="number">100</span>) <span class="comment"># y轴刻度和标签       </span></span><br><span class="line">      ) </span><br><span class="line"><span class="comment"># 上述属性设置方法, 都可以改为如下方法: </span></span><br><span class="line"><span class="comment"># ax.set_title() 或 plt.title()</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 注释标注 P 点, (4, 160) 为 P 的坐标</span></span><br><span class="line">ax.text(<span class="number">4</span>, <span class="number">160</span>, <span class="string">&#x27;P&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置轴标签字体和倾斜度</span></span><br><span class="line">ax.tick_params(labelsize=<span class="number">12</span>, labelrotation=<span class="number">20</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 去除非 x, y 轴的包围线</span></span><br><span class="line">ax.spines[<span class="string">&#x27;right&#x27;</span>].set_color(<span class="string">&#x27;none&#x27;</span>)</span><br><span class="line">ax.spines[<span class="string">&#x27;top&#x27;</span>].set_color(<span class="string">&#x27;none&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示每个图的标签</span></span><br><span class="line">plt.legend(fontsize=<span class="number">15</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示</span></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>


<p><img src="https://wx1.sbimg.cn/2020/07/01/2wT6j.png" alt="png"></p>
<p>通过上例, 能够对 matplotlib 绘图有初步了解:</p>
<p>先有一个画布”桌子”, 然后在上面放”画纸”, 有了”画纸”, 就可以开始画图, 然后按照需求去选”笔”, 布局, 着色, 顺便”作诗落款”注释一下</p>
<h2 id="2-绘制多个绘图对象-Axes"><a href="#2-绘制多个绘图对象-Axes" class="headerlink" title="2, 绘制多个绘图对象 Axes"></a>2, 绘制多个绘图对象 Axes</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> math</span><br><span class="line"></span><br><span class="line">fig = plt.figure(figsize=(<span class="number">20</span>, <span class="number">12</span>), dpi=<span class="number">120</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># &#x27;222&#x27;表示第 2 行, 第 2 列的第 2 个位置</span></span><br><span class="line">ax1 = fig.add_subplot(<span class="number">222</span>)</span><br><span class="line">ax1.plot(<span class="built_in">range</span>(<span class="number">8</span>), [x**<span class="number">2</span> <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">8</span>)])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 可以逗号隔开</span></span><br><span class="line">ax2 = fig.add_subplot(<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line">ax2.plot(<span class="built_in">range</span>(<span class="number">8</span>), [math.sin(x) <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">8</span>)])</span><br><span class="line"></span><br><span class="line">ax3 = fig.add_subplot(<span class="number">221</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># gca() 获取当前绘图对象, 最后绘制的那个</span></span><br><span class="line"><span class="comment"># 如果没有, 将创建一个新的</span></span><br><span class="line">pg = plt.gca()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置属性</span></span><br><span class="line">pg.<span class="built_in">set</span>(title=<span class="string">&#x27;最后绘制的图&#x27;</span>, xlabel=<span class="string">&#x27;x轴&#x27;</span>)</span><br><span class="line">pg.set_ylabel(<span class="string">&#x27;y轴&#x27;</span>, rotation=<span class="number">0</span>) <span class="comment"># 设置 y 轴标签水平显示</span></span><br><span class="line"></span><br><span class="line">pg.plot(<span class="built_in">range</span>(<span class="number">10</span>), <span class="built_in">range</span>(<span class="number">10</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将 y 轴移动到 x=4 处</span></span><br><span class="line">pg.spines[<span class="string">&#x27;left&#x27;</span>].set_position((<span class="string">&#x27;data&#x27;</span>, <span class="number">4</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加网格线, 设置颜色, 透明度</span></span><br><span class="line">pg.grid(color=<span class="string">&#x27;r&#x27;</span>, linestyle=<span class="string">&#x27;-.&#x27;</span>, alpha=<span class="number">0.5</span>)</span><br><span class="line"></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>


<p><img src="https://wx1.sbimg.cn/2020/07/01/2wytk.md.png" alt="png"></p>
<p>有了层次结构的了解, 就可以更潇洒地直接使用 <code>plt</code> 绘图了, 用 <code>plt</code> 直接绘图, 如果不创建画布, 画布 和 绘图对象 自动生成</p>
<p>下面用常用的图形风格举例(参数非常多, 不做详细介绍):</p>
<h2 id="3-折线图"><a href="#3-折线图" class="headerlink" title="3, 折线图"></a>3, 折线图</h2><p>折线图一般用来反映数据的变化情况和趋势 </p>
<p>上面例子中绘制的都是折线图, 下面<strong>将折线图映射成一排排点, 比较数据的分散程度:</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建两组数据</span></span><br><span class="line">x1 = np.random.randint(<span class="number">0</span>, <span class="number">20</span>, size=<span class="number">500</span>)</span><br><span class="line">x2 = np.random.randint(<span class="number">2</span>, <span class="number">10</span>, size=<span class="number">500</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 映射成两排点</span></span><br><span class="line">plt.figure(figsize=(<span class="number">15</span>, <span class="number">4</span>))</span><br><span class="line">plt.ylim(<span class="number">-0.5</span>, <span class="number">1.5</span>)</span><br><span class="line">plt.plot(x1, np.zeros(<span class="built_in">len</span>(x1)),</span><br><span class="line">         ls=<span class="string">&#x27;&#x27;</span>, <span class="comment"># 线条设为空</span></span><br><span class="line">         marker=<span class="string">&#x27;o&#x27;</span>, <span class="comment"># 数据点的样式</span></span><br><span class="line">         ms=<span class="number">10</span>, <span class="comment"># 点的大小</span></span><br><span class="line">         label=<span class="string">&#x27;x1&#x27;</span>)</span><br><span class="line">plt.plot(x2, np.ones(<span class="built_in">len</span>(x2)), ls=<span class="string">&#x27;&#x27;</span>, marker=<span class="string">&#x27;o&#x27;</span>, ms=<span class="number">10</span>, label=<span class="string">&#x27;x2&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 绘出两组数据均值所在位置</span></span><br><span class="line">plt.axvline(x1.mean(),</span><br><span class="line">            <span class="number">0.1</span>, <span class="number">0.4</span>, <span class="comment"># 竖线的范围, 取值为 0~1 之间</span></span><br><span class="line">            ls=<span class="string">&#x27;--&#x27;</span>, <span class="comment"># 线条样式</span></span><br><span class="line">            label=<span class="string">&#x27;x1均值&#x27;</span>)</span><br><span class="line">plt.axvline(x2.mean(), <span class="number">0.6</span>, <span class="number">0.9</span>, ls=<span class="string">&#x27;-.&#x27;</span>, color=<span class="string">&#x27;r&#x27;</span>, label=<span class="string">&#x27;x2均值&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 划出 x2 的范围线</span></span><br><span class="line">plt.hlines(<span class="number">0.8</span>, x2.<span class="built_in">min</span>(), x2.<span class="built_in">max</span>())</span><br><span class="line"></span><br><span class="line">plt.legend(fontsize=<span class="number">18</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>


<p><img src="https://wx1.sbimg.cn/2020/07/01/2wrWD.md.png" alt="png"></p>
<h2 id="4-散点图"><a href="#4-散点图" class="headerlink" title="4, 散点图"></a>4, 散点图</h2><p>散点图一般用来反映数据之间关联性(类别和分布规律)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建数据</span></span><br><span class="line">y = np.random.randn(<span class="number">2</span>, <span class="number">100</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 第一个类别</span></span><br><span class="line">plt.scatter(y[<span class="number">0</span>], y[<span class="number">1</span>], label=<span class="string">&#x27;第一类&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 第二个类别</span></span><br><span class="line">plt.scatter(y[<span class="number">0</span>] + <span class="number">1</span>, y[<span class="number">1</span>] + <span class="number">3</span>, label=<span class="string">&#x27;第二类&#x27;</span>)</span><br><span class="line"></span><br><span class="line">plt.legend()</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>


<p><img src="https://wx1.sbimg.cn/2020/07/01/2wOyN.png" alt="png"></p>
<h2 id="5-柱状图"><a href="#5-柱状图" class="headerlink" title="5, 柱状图"></a>5, 柱状图</h2><p>柱状图一般用来比较数据的统计量, 对数据进行直观的比较</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 接下来 5 天下雨的概率</span></span><br><span class="line">prob = [<span class="number">0.81</span>, <span class="number">0.22</span>, <span class="number">0.63</span>, <span class="number">0.18</span>, <span class="number">0.74</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># x 轴标签</span></span><br><span class="line">x = [<span class="string">&#x27;第一天&#x27;</span>, <span class="string">&#x27;第二天&#x27;</span>, <span class="string">&#x27;第三天&#x27;</span>, <span class="string">&#x27;第四天&#x27;</span>, <span class="string">&#x27;第五天&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 绘图并将图赋值给 rects</span></span><br><span class="line">rects = plt.bar(x, prob, width=<span class="number">0.5</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置 x 轴标签字体和倾斜度; y 轴范围</span></span><br><span class="line">plt.xticks(fontsize=<span class="number">12</span>, rotation=<span class="number">45</span>)</span><br><span class="line">plt.ylim(<span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在柱状图上添加概率标注</span></span><br><span class="line"><span class="keyword">for</span> rect <span class="keyword">in</span> rects:</span><br><span class="line">    height = rect.get_height()</span><br><span class="line">    plt.text(rect.get_x(), height + <span class="number">0.01</span>, <span class="built_in">str</span>(height))</span><br><span class="line"></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>


<p><img src="https://wx2.sbimg.cn/2020/07/01/2wVbn.png" alt="png"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 还可以横向绘制</span></span><br><span class="line">rects = plt.barh(x, prob, height=<span class="number">0.5</span>)</span><br><span class="line"></span><br><span class="line">plt.yticks(fontsize=<span class="number">12</span>, rotation=<span class="number">45</span>)</span><br><span class="line">plt.xlim(<span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在柱状图上添加概率标注</span></span><br><span class="line"><span class="keyword">for</span> rect <span class="keyword">in</span> rects:</span><br><span class="line">    width = rect.get_width()</span><br><span class="line">    plt.text(width,</span><br><span class="line">             rect.get_y() + <span class="number">0.5</span>/<span class="number">2</span>,</span><br><span class="line">             <span class="built_in">str</span>(width),</span><br><span class="line">             va=<span class="string">&#x27;center&#x27;</span>)</span><br><span class="line"></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>


<p><img src="https://wx2.sbimg.cn/2020/07/01/2wI2h.png" alt="png"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 假设概率大于 0.5 就是下雨, 展示下雨和不下雨, 同时展示概率</span></span><br><span class="line"><span class="comment"># 接下来 5 天下雨的概率</span></span><br><span class="line">prob1 = [<span class="number">0.81</span>, <span class="number">0.22</span>, <span class="number">0.63</span>, <span class="number">0.18</span>, <span class="number">0.74</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 不下雨的概率</span></span><br><span class="line">prob2 = <span class="number">1</span> - np.array(prob)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置 x 轴标签</span></span><br><span class="line">x = [<span class="string">&#x27;第一天&#x27;</span>, <span class="string">&#x27;第二天&#x27;</span>, <span class="string">&#x27;第三天&#x27;</span>, <span class="string">&#x27;第四天&#x27;</span>, <span class="string">&#x27;第五天&#x27;</span>]</span><br><span class="line">m = [<span class="string">&#x27;下雨&#x27;</span> <span class="keyword">if</span> i &gt; <span class="number">0.5</span> <span class="keyword">else</span> <span class="string">&#x27;不下&#x27;</span> <span class="keyword">for</span> i <span class="keyword">in</span> prob1]</span><br><span class="line">n = [x[i] + m[i] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(x))]</span><br><span class="line">     </span><br><span class="line"><span class="comment"># 绘图</span></span><br><span class="line">plt.bar(n, prob1, label=<span class="string">&#x27;下雨的概率&#x27;</span>)</span><br><span class="line">plt.bar(n, prob2, label=<span class="string">&#x27;不下雨的概率&#x27;</span>, bottom=prob1)</span><br><span class="line"></span><br><span class="line">plt.ylim(<span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line">plt.xticks(fontsize=<span class="number">12</span>, rotation=<span class="number">45</span>)</span><br><span class="line"></span><br><span class="line">plt.legend(fontsize=<span class="number">10</span>, loc=<span class="string">&#x27;best&#x27;</span>, bbox_to_anchor=(<span class="number">0.7</span>, <span class="number">1</span>))</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>


<p><img src="https://wx2.sbimg.cn/2020/07/01/2wfLM.png" alt="png"></p>
<h2 id="6-直方图"><a href="#6-直方图" class="headerlink" title="6, 直方图"></a>6, 直方图</h2><p>直方图用来直观地反映数据的总体分布情况</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建数据</span></span><br><span class="line">np.random.seed(<span class="number">0</span>)</span><br><span class="line">data = np.random.normal(<span class="number">30</span>, <span class="number">5</span>, size=<span class="number">1000</span>)</span><br><span class="line"><span class="comment"># 30 是数据的均值, 5 是标准差</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 绘制直方图</span></span><br><span class="line">plt.hist(data,</span><br><span class="line">         <span class="number">40</span>, <span class="comment"># 组数</span></span><br><span class="line">         density=<span class="literal">True</span> <span class="comment"># 每组以占比显示</span></span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line"><span class="comment"># 绘制概率密度曲线</span></span><br><span class="line">x = np.arange(<span class="built_in">int</span>(data.<span class="built_in">min</span>()), <span class="built_in">int</span>(data.<span class="built_in">max</span>()))</span><br><span class="line">f = <span class="keyword">lambda</span> x, mu, sigma: np.exp(-((x - mu)**<span class="number">2</span>) / (<span class="number">2</span> * sigma**<span class="number">2</span>)</span><br><span class="line">                               ) / (sigma * np.sqrt(<span class="number">2</span> * np.pi))</span><br><span class="line">y = f(x, <span class="number">30</span>, <span class="number">5</span>)</span><br><span class="line">plt.plot(x, y, ls=<span class="string">&#x27;-&#x27;</span>, color=<span class="string">&#x27;r&#x27;</span>)</span><br><span class="line"></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>


<p><img src="https://wx2.sbimg.cn/2020/07/01/2z4ia.png" alt="png"></p>
<p>上图可以利用基于 matpoltlib 的库 seaborn 绘制更方便:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> seaborn <span class="keyword">as</span> sns</span><br><span class="line">sns.distplot(data)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>


<p><img src="https://wx2.sbimg.cn/2020/07/01/2zMMR.png" alt="png"></p>
<h2 id="7-饼图"><a href="#7-饼图" class="headerlink" title="7, 饼图"></a>7, 饼图</h2><p>饼图用来直观地反映各个类别占比</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">plt.rcParams[<span class="string">&#x27;font.size&#x27;</span>] = <span class="number">14</span></span><br><span class="line">fig = plt.figure(figsize=(<span class="number">5</span>, <span class="number">6</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 准备数据</span></span><br><span class="line">x = [<span class="number">60</span>, <span class="number">45</span>, <span class="number">21</span>, <span class="number">12</span>, <span class="number">8</span>, <span class="number">2</span>] <span class="comment"># 每个类别数量</span></span><br><span class="line">labels = [<span class="string">f&#x27;<span class="subst">&#123;i&#125;</span>类&#x27;</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(x) + <span class="number">1</span>)] <span class="comment"># 类别名</span></span><br><span class="line">explode = [<span class="number">0.02</span>] * <span class="built_in">len</span>(x) <span class="comment"># 每一块离中心的距离</span></span><br><span class="line"></span><br><span class="line">plt.pie(x,</span><br><span class="line">        explode=explode,</span><br><span class="line">        labels=labels,</span><br><span class="line">        colors=<span class="literal">None</span>, <span class="comment"># 颜色不配置, 使用默认</span></span><br><span class="line">        autopct=<span class="string">&#x27;%.1f%%&#x27;</span>, <span class="comment"># 设置百分比标签</span></span><br><span class="line">        pctdistance=<span class="number">0.7</span>, <span class="comment"># 设置百分比标签离中心的距离</span></span><br><span class="line">        shadow=<span class="literal">False</span>, <span class="comment"># 设置阴影</span></span><br><span class="line">        labeldistance=<span class="number">1.05</span>, <span class="comment"># 设置类别标签离中心的距离</span></span><br><span class="line">        startangle=<span class="number">180</span>, <span class="comment"># 设置绘制起始位置</span></span><br><span class="line">        radius=<span class="number">1.1</span>, <span class="comment"># 设置饼图大小</span></span><br><span class="line">        counterclock=<span class="literal">False</span>, <span class="comment"># 设置顺逆时针</span></span><br><span class="line">       )</span><br><span class="line">      </span><br><span class="line">plt.legend(fontsize=<span class="number">16</span>, loc=<span class="string">&#x27;best&#x27;</span>, bbox_to_anchor=(<span class="number">1</span>, <span class="number">1</span>))</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>


<p><img src="https://wx1.sbimg.cn/2020/07/01/2zXRI.png" alt="png"></p>
<p><strong>拓展:</strong> 绘制三维立体图</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> mpl_toolkits.mplot3d <span class="keyword">import</span> axes3d</span><br><span class="line"></span><br><span class="line">fig = plt.figure()</span><br><span class="line">ax = fig.gca(projection=<span class="string">&#x27;3d&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 准备数据</span></span><br><span class="line">theta = np.linspace(<span class="number">-4</span> * np.pi, <span class="number">4</span> * np.pi, <span class="number">100</span>)</span><br><span class="line">z = np.linspace(<span class="number">-2</span>, <span class="number">2</span>, <span class="number">100</span>)</span><br><span class="line">r = z**<span class="number">2</span> + <span class="number">1</span></span><br><span class="line">x = r * np.sin(theta)</span><br><span class="line">y = r * np.cos(theta)</span><br><span class="line"></span><br><span class="line">ax.plot(x, y, z, label=<span class="string">&#x27;空间曲线&#x27;</span>, color=<span class="string">&#x27;r&#x27;</span>)</span><br><span class="line">ax.legend()</span><br><span class="line"></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>


<p><img src="https://wx1.sbimg.cn/2020/07/01/2zmWK.png" alt="png"></p>
]]></content>
      <categories>
        <category>数据分析</category>
      </categories>
      <tags>
        <tag>matplotlib</tag>
      </tags>
  </entry>
  <entry>
    <title>ndarray 对象的运算，方法及创建</title>
    <url>/data/numpy2-e9e4c18c3431/</url>
    <content><![CDATA[<blockquote>
<p>numpy 是 python 的强大科学计算库, 它让 python 处理数据, 进行科学计算变得极其便捷, 高效</p>
</blockquote>
<h2 id="三-ndarray-对象的运算及其方法"><a href="#三-ndarray-对象的运算及其方法" class="headerlink" title="三, ndarray 对象的运算及其方法"></a>三, ndarray 对象的运算及其方法</h2><h3 id="1-ndarray-的运算"><a href="#1-ndarray-的运算" class="headerlink" title="1, ndarray 的运算"></a>1, ndarray 的运算</h3><p>numpy 在运算时, 会通过广播机制, 将运算相对应到每个元素上:</p>
<p><strong>数和数组计算, 数会和数组中的每一个元素进行计算</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 方法 reshape 用于设置数组的形状, 后面会说</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">a = np.arange(<span class="number">9</span>).reshape((<span class="number">3</span>, <span class="number">3</span>))</span><br><span class="line">a</span><br></pre></td></tr></table></figure>




<pre><code>array([[0, 1, 2],
       [3, 4, 5],
       [6, 7, 8]])</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">b = -a * <span class="number">2</span></span><br><span class="line">b</span><br></pre></td></tr></table></figure>




<pre><code>array([[  0,  -2,  -4],
       [ -6,  -8, -10],
       [-12, -14, -16]])</code></pre>
<p><strong>相同形状的多维数组之间的运算, 对应位置的元素进行计算</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a + b</span><br></pre></td></tr></table></figure>




<pre><code>array([[ 0, -1, -2],
       [-3, -4, -5],
       [-6, -7, -8]])</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 行相同</span></span><br><span class="line">a[<span class="number">1</span>] + (a + b)</span><br></pre></td></tr></table></figure>




<pre><code>array([[ 3,  3,  3],
       [ 0,  0,  0],
       [-3, -3, -3]])</code></pre>
<p><strong>二维一列的数组和多维数组之间的运算, 需要列元素个数相同, 然后一一对应并广播计算</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 列相同</span></span><br><span class="line"><span class="comment"># a 的列取出来成了一维, 需要转为二维</span></span><br><span class="line">a[:, <span class="number">1</span>].reshape((<span class="number">3</span>, <span class="number">1</span>)) + (a + b)</span><br></pre></td></tr></table></figure>




<pre><code>array([[ 1,  0, -1],
       [ 1,  0, -1],
       [ 1,  0, -1]])</code></pre>
<h3 id="2-常用-ndarray-对象的方法"><a href="#2-常用-ndarray-对象的方法" class="headerlink" title="2, 常用 ndarray 对象的方法"></a>2, 常用 ndarray 对象的方法</h3><p>就是直接用 ndarray 对象调用的方法</p>
<h4 id="2-01-形状操作"><a href="#2-01-形状操作" class="headerlink" title="2.01, 形状操作"></a>2.01, 形状操作</h4><p><strong>flatten 或 ravel 将多维数组展开为一维, 不改变原数组</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a</span><br></pre></td></tr></table></figure>




<pre><code>array([[0, 1, 2],
       [3, 4, 5],
       [6, 7, 8]])</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 默认参数 &#x27;C&#x27; 以行展开, &#x27;F&#x27; 以列展开</span></span><br><span class="line">display(a.flatten())</span><br><span class="line">display(a.flatten(<span class="string">&#x27;F&#x27;</span>))</span><br><span class="line">a.ravel(<span class="string">&#x27;F&#x27;</span>)</span><br></pre></td></tr></table></figure>


<pre><code>array([0, 1, 2, 3, 4, 5, 6, 7, 8])

array([0, 3, 6, 1, 4, 7, 2, 5, 8])

array([0, 3, 6, 1, 4, 7, 2, 5, 8])</code></pre>
<p><strong>reshape 修改数组的形状, 不改变原数组, 行列数相乘要等于元素总数; resize 就地修改原数组形状</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 默认以行展开修改</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">b = np.arange(<span class="number">12</span>).reshape((<span class="number">3</span>, <span class="number">4</span>))</span><br><span class="line">display(b)</span><br><span class="line">b.reshape((<span class="number">2</span>, <span class="number">6</span>), order=<span class="string">&#x27;F&#x27;</span>)</span><br></pre></td></tr></table></figure>


<pre><code>array([[ 0,  1,  2,  3],
       [ 4,  5,  6,  7],
       [ 8,  9, 10, 11]])

array([[ 0,  8,  5,  2, 10,  7],
       [ 4,  1,  9,  6,  3, 11]])</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 就地修改 b</span></span><br><span class="line">display(b)</span><br><span class="line">b.resize((<span class="number">4</span>, <span class="number">3</span>))</span><br><span class="line">b</span><br></pre></td></tr></table></figure>


<pre><code>array([[ 0,  1,  2,  3],
       [ 4,  5,  6,  7],
       [ 8,  9, 10, 11]])

array([[ 0,  1,  2],
       [ 3,  4,  5],
       [ 6,  7,  8],
       [ 9, 10, 11]])</code></pre>
<h4 id="2-02-转换类型"><a href="#2-02-转换类型" class="headerlink" title="2.02, 转换类型"></a>2.02, 转换类型</h4><p><strong>tolist 数组转列表</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">b.tolist()</span><br></pre></td></tr></table></figure>




<pre><code>[[0, 1, 2], [3, 4, 5], [6, 7, 8], [9, 10, 11]]</code></pre>
<p><strong>astype 改变数组类型</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">b.astype(<span class="built_in">float</span>)</span><br></pre></td></tr></table></figure>




<pre><code>array([[ 0.,  1.,  2.],
       [ 3.,  4.,  5.],
       [ 6.,  7.,  8.],
       [ 9., 10., 11.]])</code></pre>
<h4 id="2-03-修改-排序及查找"><a href="#2-03-修改-排序及查找" class="headerlink" title="2.03, 修改, 排序及查找"></a>2.03, 修改, 排序及查找</h4><p><strong>fill 给原数组重新填值, 类型不变</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">b[<span class="number">0</span>].fill(<span class="number">2.01</span>)</span><br><span class="line">b</span><br></pre></td></tr></table></figure>




<pre><code>array([[ 2,  2,  2],
       [ 3,  4,  5],
       [ 6,  7,  8],
       [ 9, 10, 11]])</code></pre>
<p><strong>sort 就地排序, 参数 0 将列排序, 1 将行排序</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = np.array([[<span class="number">3</span>, <span class="number">0</span>, <span class="number">5</span>], [<span class="number">8</span>, <span class="number">4</span>, <span class="number">6</span>], [<span class="number">0</span>, <span class="number">7</span>, <span class="number">3</span>]])</span><br><span class="line">a.sort(<span class="number">0</span>)</span><br><span class="line">a</span><br></pre></td></tr></table></figure>




<pre><code>array([[0, 0, 3],
       [3, 4, 5],
       [8, 7, 6]])</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a.argsort() <span class="comment"># 返回排序后的索引位置</span></span><br></pre></td></tr></table></figure>




<pre><code>array([[1, 0, 2],
       [0, 1, 2],
       [2, 1, 0]], dtype=int64)</code></pre>
<p><strong>nonzero 返回非零元素的索引, 行坐标一个数组, 列坐标一个数组</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a.nonzero()</span><br></pre></td></tr></table></figure>




<pre><code>(array([0, 1, 1, 1, 2, 2, 2], dtype=int64),
 array([2, 0, 1, 2, 0, 1, 2], dtype=int64))</code></pre>
<h4 id="2-04-计算"><a href="#2-04-计算" class="headerlink" title="2.04, 计算"></a>2.04, 计算</h4><p><strong>max 返回最大值, 给定轴将返回给定轴的最大值, argmax 返回索引, 与之对应的还有最小min 和 argmin</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 参数 0 列的最大值, 参数 1 行的最大值</span></span><br><span class="line">a = np.arange(<span class="number">1.01</span>, <span class="number">13.13</span>, <span class="number">1.01</span>).reshape(<span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line">print(a)</span><br><span class="line">print(a.<span class="built_in">max</span>(), a.<span class="built_in">max</span>(axis=<span class="number">0</span>), a.<span class="built_in">max</span>(axis=<span class="number">1</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 参数 0 行索引, 1 列索引</span></span><br><span class="line">print(a.argmax(), a.argmax(<span class="number">0</span>), a.argmax(<span class="number">1</span>))</span><br></pre></td></tr></table></figure>

<pre><code>[[ 1.01  2.02  3.03  4.04]
 [ 5.05  6.06  7.07  8.08]
 [ 9.09 10.1  11.11 12.12]]
12.12 [ 9.09 10.1  11.11 12.12] [ 4.04  8.08 12.12]
11 [2 2 2 2] [3 3 3]</code></pre>
<p><strong>ptp 返回极值或给定轴的极值(最大-最小)</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a.ptp(), a.ptp(axis=<span class="number">0</span>), a.ptp(axis=<span class="number">1</span>)</span><br></pre></td></tr></table></figure>




<pre><code>(11.11, array([8.08, 8.08, 8.08, 8.08]), array([3.03, 3.03, 3.03]))</code></pre>
<p><strong>clip 返回指定值之间的数组, 小于或大于指定值的, 用指定值填充</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a.clip(<span class="number">2</span>, <span class="number">6</span>)</span><br></pre></td></tr></table></figure>




<pre><code>array([[2.  , 2.02, 3.03, 4.04],
       [5.05, 6.  , 6.  , 6.  ],
       [6.  , 6.  , 6.  , 6.  ]])</code></pre>
<p><strong>round 四舍五入到指定位数</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a.<span class="built_in">round</span>(<span class="number">1</span>)</span><br></pre></td></tr></table></figure>




<pre><code>array([[ 1. ,  2. ,  3. ,  4. ],
       [ 5. ,  6.1,  7.1,  8.1],
       [ 9.1, 10.1, 11.1, 12.1]])</code></pre>
<p><strong>sum 求和, cumsum 累积求和</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">print(a.<span class="built_in">sum</span>()) <span class="comment"># 总和</span></span><br><span class="line">print(a.<span class="built_in">sum</span>(<span class="number">0</span>)) <span class="comment"># 列求和</span></span><br><span class="line">print(a.<span class="built_in">sum</span>(<span class="number">1</span>)) <span class="comment"># 行求和</span></span><br></pre></td></tr></table></figure>

<pre><code>78.78
[15.15 18.18 21.21 24.24]
[10.1  26.26 42.42]</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">print(a.cumsum()) <span class="comment"># 全部累积</span></span><br><span class="line">print(a.cumsum(<span class="number">0</span>)) <span class="comment"># 列累积</span></span><br><span class="line">print(a.cumsum(<span class="number">1</span>)) <span class="comment"># 行累积</span></span><br></pre></td></tr></table></figure>

<pre><code>[ 1.01  3.03  6.06 10.1  15.15 21.21 28.28 36.36 45.45 55.55 66.66 78.78]
[[ 1.01  2.02  3.03  4.04]
 [ 6.06  8.08 10.1  12.12]
 [15.15 18.18 21.21 24.24]]
[[ 1.01  3.03  6.06 10.1 ]
 [ 5.05 11.11 18.18 26.26]
 [ 9.09 19.19 30.3  42.42]]</code></pre>
<p>类似还有 mean 均值, var 方差, std 标准差, prod 乘积, cumprod 累积乘积, 不在一一举例</p>
<p><strong>all 数组所有元素都判断为 True, 返回 True, 而 any 只要任何一个 True 返回 True</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = np.array([<span class="number">1</span>, <span class="number">2</span>])</span><br><span class="line">b = np.array([<span class="number">0</span>, <span class="number">0</span>])</span><br><span class="line">a.<span class="built_in">all</span>(), b.<span class="built_in">all</span>(), a.<span class="built_in">any</span>(), b.<span class="built_in">any</span>()</span><br></pre></td></tr></table></figure>




<pre><code>(True, False, True, False)</code></pre>
<h2 id="四-创建或生成-ndarray-对象"><a href="#四-创建或生成-ndarray-对象" class="headerlink" title="四, 创建或生成 ndarray 对象"></a>四, 创建或生成 ndarray 对象</h2><h3 id="1-生成随机数"><a href="#1-生成随机数" class="headerlink" title="1, 生成随机数"></a>1, 生成随机数</h3><p>利用 numpy 生成随机数的模块 random, 创建数据来作例子非常有用. 先研究一下这个模块, 再研究通用函数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成 0 ~ 1 之间的随机数</span></span><br><span class="line">display(<span class="number">1</span> + np.random.random(<span class="number">3</span>))</span><br><span class="line">np.random.random((<span class="number">2</span>,<span class="number">3</span>)) * <span class="number">10</span></span><br></pre></td></tr></table></figure>


<pre><code>array([1.82284856, 1.74169635, 1.13422422])

array([[6.36362188, 1.14392333, 8.91802989],
       [6.36495372, 3.45182186, 5.43685741]])</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 同上, 传参方式不一样</span></span><br><span class="line">display(np.random.rand(<span class="number">3</span>))</span><br><span class="line">np.random.rand(<span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>)</span><br></pre></td></tr></table></figure>


<pre><code>array([0.98425577, 0.14132891, 0.18846798])

array([[[0.45803962, 0.04218858],
        [0.63973453, 0.21237992],
        [0.70729683, 0.21256585]]])</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 返回指定范围内的随机整数 [a,b) 包含 a 不包含 b, 不指定 b 则 [0,a)</span></span><br><span class="line">display(np.random.randint(<span class="number">3</span>, size=<span class="number">3</span>))</span><br><span class="line">np.random.randint(<span class="number">1</span>, <span class="number">4</span>, (<span class="number">2</span>, <span class="number">3</span>))</span><br></pre></td></tr></table></figure>


<pre><code>array([1, 0, 0])

array([[2, 1, 3],
       [3, 2, 1]])</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 生成的随机数服从标准正态分布</span></span><br><span class="line">display(np.random.randn(<span class="number">3</span>))</span><br><span class="line">np.random.randn(<span class="number">3</span>, <span class="number">2</span>)</span><br></pre></td></tr></table></figure>


<pre><code>array([-0.09604445, -0.75864414, -1.5083506 ])

array([[-1.23948685, -0.81579078],
       [ 0.40326043,  1.09253726],
       [ 0.89420717,  1.09676142]])</code></pre>
<p>类似还有拉普拉斯分布 laplace, 逻辑分布 logistic, 正态分布 normal 等, 可以设置分布的参数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">np.random.logistic(<span class="number">5</span>, <span class="number">2</span>, (<span class="number">2</span>, <span class="number">3</span>))</span><br></pre></td></tr></table></figure>




<pre><code>array([[ 0.40236115, -3.75399016,  6.85283009],
       [ 6.68625045, 14.34102472,  6.39633631]])</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 打乱原数组元素, 二维时只能打乱行的顺序</span></span><br><span class="line">a = np.arange(<span class="number">5</span>)</span><br><span class="line">b = np.arange(<span class="number">9</span>).reshape(<span class="number">3</span>, <span class="number">3</span>)</span><br><span class="line">np.random.shuffle(a)</span><br><span class="line">np.random.shuffle(b)</span><br><span class="line">a, b</span><br></pre></td></tr></table></figure>




<pre><code>(array([1, 4, 0, 3, 2]),
 array([[3, 4, 5],
        [0, 1, 2],
        [6, 7, 8]]))</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 从一个一维数组里随机选择指定数量的元素, </span></span><br><span class="line"><span class="comment"># 或随机生成 0 到指定整数(不包含)的随机数</span></span><br><span class="line"><span class="comment"># replace=True 元素可以重复选择(默认)</span></span><br><span class="line">display(np.random.choice(<span class="number">5</span>, <span class="number">5</span>, replace=<span class="literal">False</span>))</span><br><span class="line">np.random.choice(a, (<span class="number">2</span>, <span class="number">3</span>))</span><br></pre></td></tr></table></figure>


<pre><code>array([4, 3, 0, 1, 2])

array([[4, 2, 3],
       [3, 4, 0]])</code></pre>
<h3 id="2-创建数组"><a href="#2-创建数组" class="headerlink" title="2, 创建数组"></a>2, 创建数组</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">np.empty((<span class="number">2</span>, <span class="number">3</span>))</span><br></pre></td></tr></table></figure>




<pre><code>array([[0.0e+000, 9.9e-324, 1.5e-323],
       [2.0e-323, 2.5e-323, 3.0e-323]])</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = np.eye(<span class="number">3</span>)</span><br><span class="line">a</span><br></pre></td></tr></table></figure>




<pre><code>array([[1., 0., 0.],
       [0., 1., 0.],
       [0., 0., 1.]])</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">np.ones((<span class="number">2</span>, <span class="number">3</span>))</span><br></pre></td></tr></table></figure>




<pre><code>array([[1., 1., 1.],
       [1., 1., 1.]])</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">np.ones_like(a)</span><br></pre></td></tr></table></figure>




<pre><code>array([[1., 1., 1.],
       [1., 1., 1.],
       [1., 1., 1.]])</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">np.zeros((<span class="number">2</span>, <span class="number">3</span>))</span><br></pre></td></tr></table></figure>




<pre><code>array([[0., 0., 0.],
       [0., 0., 0.]])</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">np.full((<span class="number">2</span>, <span class="number">3</span>), <span class="number">3</span>)</span><br></pre></td></tr></table></figure>




<pre><code>array([[3, 3, 3],
       [3, 3, 3]])</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">np.array(<span class="built_in">list</span>)</span><br></pre></td></tr></table></figure>




<pre><code>array(&lt;class &#39;list&#39;&gt;, dtype=object)</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">np.arange(<span class="number">3</span>)</span><br></pre></td></tr></table></figure>




<pre><code>array([0, 1, 2])</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">np.linspace(<span class="number">1</span>, <span class="number">9</span>, <span class="number">3</span>)</span><br></pre></td></tr></table></figure>




<pre><code>array([1., 5., 9.])</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">np.logspace(<span class="number">1</span>, <span class="number">3</span>, <span class="number">3</span>)</span><br></pre></td></tr></table></figure>




<pre><code>array([  10.,  100., 1000.])</code></pre>
]]></content>
      <categories>
        <category>数据分析</category>
      </categories>
      <tags>
        <tag>numpy</tag>
      </tags>
  </entry>
  <entry>
    <title>ndarray 对象介绍及切片操作</title>
    <url>/data/numpy1-caa388146ce1/</url>
    <content><![CDATA[<blockquote>
<p>numpy 是 python 的强大科学计算库, 它让 python 处理数据, 进行科学计算变得极其便捷, 高效</p>
</blockquote>
<p><font color=#00A600 >2020年7月8日更新</font></p>
<p>对于数据分析, 学习 numpy 最重要的就是搞清楚 N 维数组对象 ndarray, 以及处理, 计算 ndarray 对象数据的各种操作, 运算方法</p>
<h2 id="一-ndarray-对象"><a href="#一-ndarray-对象" class="headerlink" title="一, ndarray 对象"></a>一, ndarray 对象</h2><h3 id="1-ndaraay-介绍"><a href="#1-ndaraay-介绍" class="headerlink" title="1, ndaraay 介绍"></a>1, ndaraay 介绍</h3><p>ndarray 是具有相同类型和大小的项目的多维容器, 它的数据存储效率和输入输出性能远远优于 python 中等价的数据结构</p>
<h4 id="1-01-理解-ndarray"><a href="#1-01-理解-ndarray" class="headerlink" title="1.01, 理解 ndarray"></a>1.01, 理解 ndarray</h4><p>创建 ndarray 用方法 <code>np.array()</code>, 下面只介绍 3 维以下数组, 理解它们的结构</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment"># 一维</span></span><br><span class="line">a = np.array([<span class="number">1</span>, <span class="string">&#x27;a&#x27;</span>])</span><br><span class="line">print(a)</span><br><span class="line">a</span><br></pre></td></tr></table></figure>

<pre><code>[&#39;1&#39; &#39;a&#39;]

array([&#39;1&#39;, &#39;a&#39;], dtype=&#39;&lt;U11&#39;)</code></pre>
<p>上例可见, 打印结果是一个列表, 元素都是字符串, 但其实它是一个 ndarray, 它其中每个元素息息相关, 数据类型都统一成 Unicode, 元素位长是 11, 所以说它是一个具有相同类型和大小的项目的多维容器</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 二维</span></span><br><span class="line">a = np.array([[<span class="number">1</span>, <span class="number">2</span>], [<span class="number">3</span>, <span class="string">&#x27;4&#x27;</span>]])</span><br><span class="line">print(a)</span><br><span class="line">a</span><br></pre></td></tr></table></figure>

<pre><code>[[&#39;1&#39; &#39;2&#39;]
 [&#39;3&#39; &#39;4&#39;]]

array([[&#39;1&#39;, &#39;2&#39;],
       [&#39;3&#39;, &#39;4&#39;]], dtype=&#39;&lt;U11&#39;)</code></pre>
<p>二维就像一个表格, 横着的就是一行, 竖着的就是一列</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 三维</span></span><br><span class="line">a = np.array([[[<span class="number">1</span>, <span class="number">2</span>], [<span class="number">1</span>, <span class="number">2</span>]], [[<span class="number">3</span>, <span class="number">4</span>], [<span class="number">3</span>, <span class="number">4</span>]]])</span><br><span class="line">print(a)</span><br><span class="line">a</span><br></pre></td></tr></table></figure>

<pre><code>[[[1 2]
  [1 2]]

 [[3 4]
  [3 4]]]

array([[[1, 2],
        [1, 2]],

       [[3, 4],
        [3, 4]]])</code></pre>
<p>三维类似多个表格放到一个 excel 文件里</p>
<h4 id="1-02-ndarray-对象计算的优势"><a href="#1-02-ndarray-对象计算的优势" class="headerlink" title="1.02, ndarray 对象计算的优势"></a>1.02, ndarray 对象计算的优势</h4><p>用实例来对比利用 ndarray 进行计算的优势</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="comment"># 假设有如下列表和 array, 使其中每个数都变成它的平方</span></span><br><span class="line">a1 = [random.random() <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">100000000</span>)]</span><br><span class="line"><span class="comment"># a2 = np.array(a1)</span></span><br><span class="line"></span><br><span class="line">t1 = time.time()</span><br><span class="line">b = [i**<span class="number">2</span> <span class="keyword">for</span> i <span class="keyword">in</span> a1]</span><br><span class="line">t2 = time.time()</span><br><span class="line">a2 = np.array(a1)</span><br><span class="line">c = a2**<span class="number">2</span></span><br><span class="line">t3 = time.time()</span><br><span class="line">print(t2 - t1, t3 - t2, sep=<span class="string">&#x27;\n&#x27;</span>)</span><br></pre></td></tr></table></figure>

<pre><code>28.430076599121094
15.24291205406189</code></pre>
<p>差距非常明显(如果 a2 在计算之前就已经是 ndarray 对象会更明显), python 计算需要遍历, numpy 有其自身机制(广播)实现快速计算</p>
<h4 id="1-03-ndarray-的数据类型和常量"><a href="#1-03-ndarray-的数据类型和常量" class="headerlink" title="1.03, ndarray 的数据类型和常量"></a>1.03, ndarray 的数据类型和常量</h4><p>ndarray 对象数据的数据类型有 <code>bool</code>, <code>int</code>, <code>float</code>, <code>U</code>(字符串), <code>O</code>(python 对象)等, 查看数据类型用 <code>dtype</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">a = np.array([<span class="number">1</span>, <span class="string">&#x27;a&#x27;</span>, np.nan])</span><br><span class="line">a.dtype, a[<span class="number">0</span>].dtype, a[<span class="number">2</span>].dtype</span><br></pre></td></tr></table></figure>




<pre><code>(dtype(&#39;&lt;U11&#39;), dtype(&#39;&lt;U1&#39;), dtype(&#39;&lt;U3&#39;))</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">np.array(<span class="literal">True</span>).dtype</span><br></pre></td></tr></table></figure>




<pre><code>dtype(&#39;bool&#39;)</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">np.array(<span class="number">123456</span>).dtype</span><br></pre></td></tr></table></figure>




<pre><code>dtype(&#39;int32&#39;)</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">np.array(<span class="number">3.1415926</span>).dtype</span><br></pre></td></tr></table></figure>




<pre><code>dtype(&#39;float64&#39;)</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">np.array(<span class="built_in">list</span>).dtype</span><br></pre></td></tr></table></figure>




<pre><code>dtype(&#39;O&#39;)</code></pre>
<p>ndarray 对象数据的常量有 <code>pi</code>, <code>e</code>, <code>nan</code> (空值), <code>inf</code> (无穷大)等</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">np.pi</span><br></pre></td></tr></table></figure>




<pre><code>3.141592653589793</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">np.e</span><br></pre></td></tr></table></figure>




<pre><code>2.718281828459045</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">np.nan</span><br></pre></td></tr></table></figure>




<pre><code>nan</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">np.inf</span><br></pre></td></tr></table></figure>




<pre><code>inf</code></pre>
<h3 id="2-ndarray-的属性"><a href="#2-ndarray-的属性" class="headerlink" title="2, ndarray 的属性"></a>2, ndarray 的属性</h3><p>常用 ndarray 对象的属性</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = np.array([[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]])</span><br><span class="line">a</span><br></pre></td></tr></table></figure>




<pre><code>array([[1, 2, 3],
       [4, 5, 6]])</code></pre>
<p>查看数组形状 <code>(行, 列)</code>, 这在数据处理和计算时非常有用, 例如遍历出所有行或列</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a.shape</span><br></pre></td></tr></table></figure>




<pre><code>(2, 3)</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 遍历所有列</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(a.shape[<span class="number">1</span>]):</span><br><span class="line">    print(a[:, i])</span><br></pre></td></tr></table></figure>

<pre><code>[1 4]
[2 5]
[3 6]</code></pre>
<p>查看数组维度</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a.ndim</span><br></pre></td></tr></table></figure>




<pre><code>2</code></pre>
<p>查看数组元素个数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a.size</span><br></pre></td></tr></table></figure>




<pre><code>6</code></pre>
<p>查看数组类型</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a.dtype</span><br></pre></td></tr></table></figure>




<pre><code>dtype(&#39;int32&#39;)</code></pre>
<p>查看数组元素的大小, 字节为单位</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a.itemsize</span><br></pre></td></tr></table></figure>




<pre><code>4</code></pre>
<p>数组转置, 就是行列互换</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a.T</span><br></pre></td></tr></table></figure>




<pre><code>array([[1, 4],
       [2, 5],
       [3, 6]])</code></pre>
<h2 id="二-ndarray-对象的切片操作"><a href="#二-ndarray-对象的切片操作" class="headerlink" title="二, ndarray 对象的切片操作"></a>二, ndarray 对象的切片操作</h2><p>与 python 的 range 对应的 numpy 方法是 arange, 下面用它创建数组作为例子</p>
<h3 id="1-切片取值"><a href="#1-切片取值" class="headerlink" title="1, 切片取值"></a>1, 切片取值</h3><p>ndarray 的切片操作和 python 类似, 一维切片 <code>[起始:结束:步长]</code>, 二维的切片 <code>[起始行:结束行:步长, 起始列:结束列:步长]</code> 或 <code>[[行, ...], [列, ...]]</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = np.arange(<span class="number">20</span>)</span><br><span class="line">a.shape = (<span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line">a</span><br></pre></td></tr></table></figure>




<pre><code>array([[ 0,  1,  2,  3,  4],
       [ 5,  6,  7,  8,  9],
       [10, 11, 12, 13, 14],
       [15, 16, 17, 18, 19]])</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 第一行的第 1, 3, 5 个数</span></span><br><span class="line">a[<span class="number">0</span>][<span class="number">0</span>::<span class="number">2</span>]</span><br></pre></td></tr></table></figure>




<pre><code>array([0, 2, 4])</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a[<span class="number">2</span>, <span class="number">3</span>]</span><br></pre></td></tr></table></figure>




<pre><code>13</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a[<span class="number">0</span>:<span class="number">2</span>, <span class="number">1</span>:<span class="number">5</span>]</span><br></pre></td></tr></table></figure>




<pre><code>array([[1, 2, 3, 4],
       [6, 7, 8, 9]])</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a[<span class="number">0</span>:<span class="number">3</span>:<span class="number">2</span>, <span class="number">0</span>:<span class="number">4</span>:<span class="number">2</span>]</span><br></pre></td></tr></table></figure>




<pre><code>array([[ 0,  2],
       [10, 12]])</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a[[<span class="number">1</span>, <span class="number">3</span>], <span class="number">0</span>:<span class="number">3</span>]</span><br></pre></td></tr></table></figure>




<pre><code>array([[ 5,  6,  7],
       [15, 16, 17]])</code></pre>
<p>还可以通过逻辑运算取值</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 取出数组中的数翻倍之后小于 15 的数</span></span><br><span class="line"><span class="comment"># 结果展开为 1 维</span></span><br><span class="line">a[a * <span class="number">2</span> &lt; <span class="number">15</span>]</span><br></pre></td></tr></table></figure>




<pre><code>array([0, 1, 2, 3, 4, 5, 6, 7])</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># &amp; 与</span></span><br><span class="line">a[(a &lt; <span class="number">5</span>) &amp; (a &gt; <span class="number">1</span>)]</span><br></pre></td></tr></table></figure>




<pre><code>array([2, 3, 4])</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># | 或</span></span><br><span class="line">a[(a &lt; <span class="number">3</span>) | (a &gt; <span class="number">15</span>)]</span><br></pre></td></tr></table></figure>




<pre><code>array([ 0,  1,  2, 16, 17, 18, 19])</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># ~ 非</span></span><br><span class="line">a[~ (a &gt; <span class="number">3</span>)]</span><br></pre></td></tr></table></figure>




<pre><code>array([0, 1, 2, 3])</code></pre>
<h3 id="2-利用切片修改值"><a href="#2-利用切片修改值" class="headerlink" title="2, 利用切片修改值"></a>2, 利用切片修改值</h3><p>切片修改值, 其实就是将取到的值重新赋值</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a[~ (a &gt; <span class="number">3</span>)] = <span class="number">1</span></span><br><span class="line">a</span><br></pre></td></tr></table></figure>




<pre><code>array([[ 1,  1,  1,  1,  4],
       [ 5,  6,  7,  8,  9],
       [10, 11, 12, 13, 14],
       [15, 16, 17, 18, 19]])</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 将 1 修改为 nan, nan 是 float 类型, </span></span><br><span class="line"><span class="comment"># 保证类型一致性, 需要将 a 转为 float</span></span><br><span class="line">a = a.astype(<span class="built_in">float</span>)</span><br><span class="line">a[a == <span class="number">1</span>] = np.nan</span><br><span class="line">a</span><br></pre></td></tr></table></figure>




<pre><code>array([[nan, nan, nan, nan,  4.],
       [ 5.,  6.,  7.,  8.,  9.],
       [10., 11., 12., 13., 14.],
       [15., 16., 17., 18., 19.]])</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 任何 nan 都不等于 nan, </span></span><br><span class="line"><span class="comment"># 利用此特性取 nan, 或非 nan 的数</span></span><br><span class="line">a[a != a], a[a == a]</span><br></pre></td></tr></table></figure>




<pre><code>(array([nan, nan, nan, nan]),
 array([ 4.,  5.,  6.,  7.,  8.,  9., 10., 11., 12., 13., 14., 15., 16.,
        17., 18., 19.]))</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 交换行, 交换列</span></span><br><span class="line">a[[<span class="number">0</span>, <span class="number">3</span>], :] = a[[<span class="number">3</span>, <span class="number">0</span>], :]</span><br><span class="line">a[:, [<span class="number">4</span>, <span class="number">0</span>]] = a[:, [<span class="number">0</span>, <span class="number">4</span>]]</span><br><span class="line">a</span><br></pre></td></tr></table></figure>




<pre><code>array([[19., 16., 17., 18., 15.],
       [ 9.,  6.,  7.,  8.,  5.],
       [14., 11., 12., 13., 10.],
       [ 4., nan, nan, nan, nan]])</code></pre>
]]></content>
      <categories>
        <category>数据分析</category>
      </categories>
      <tags>
        <tag>numpy</tag>
      </tags>
  </entry>
  <entry>
    <title>常用的通函数及 API</title>
    <url>/data/numpy3-2300149490ed/</url>
    <content><![CDATA[<blockquote>
<p>numpy 是 python 的强大科学计算库, 它让 python 处理数据, 进行科学计算变得极其便捷, 高效</p>
</blockquote>
<h2 id="五-常用的通函数及-API"><a href="#五-常用的通函数及-API" class="headerlink" title="五, 常用的通函数及 API"></a>五, 常用的通函数及 API</h2><p>numpy 调用, 用来操作 ndarray 对象的函数</p>
<h3 id="1-修改数组形状"><a href="#1-修改数组形状" class="headerlink" title="1, 修改数组形状"></a>1, 修改数组形状</h3><p><strong>reshape 与 ndarray 对象的方法一样, 另有 resize 只能按行展开</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = np.random.choice(<span class="number">5</span>, (<span class="number">2</span>, <span class="number">3</span>))</span><br><span class="line">display(a)</span><br><span class="line">np.reshape(a,(<span class="number">1</span>, <span class="number">6</span>), <span class="string">&#x27;F&#x27;</span>)</span><br></pre></td></tr></table></figure>


<pre><code>array([[4, 2, 3],
       [1, 0, 0]])

array([[4, 1, 2, 0, 3, 0]])</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">np.resize(a, (<span class="number">1</span>, <span class="number">6</span>))</span><br></pre></td></tr></table></figure>




<pre><code>array([[4, 2, 3, 1, 0, 0]])</code></pre>
<p><strong>ravel 展开为一维(ndarray 对象也有该方法)</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">np.ravel(a, <span class="string">&#x27;F&#x27;</span>)</span><br></pre></td></tr></table></figure>




<pre><code>array([2, 1, 1, 2, 4, 3])</code></pre>
<h3 id="2-组合数组"><a href="#2-组合数组" class="headerlink" title="2, 组合数组"></a>2, 组合数组</h3><p><strong>concatenate, hstack, vstack 连接数组</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># axis=0, 行方向连接(默认), axis=1, 列方向连接</span></span><br><span class="line">b = np.random.choice(<span class="number">6</span>, (<span class="number">2</span>, <span class="number">3</span>))</span><br><span class="line">np.concatenate((a, b), axis=<span class="number">1</span>)</span><br></pre></td></tr></table></figure>




<pre><code>array([[2, 1, 4, 3, 0, 1],
       [1, 2, 3, 3, 2, 1]])</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">np.hstack((a, b)) <span class="comment"># 列方向连接</span></span><br></pre></td></tr></table></figure>




<pre><code>array([[2, 1, 4, 3, 0, 1],
       [1, 2, 3, 3, 2, 1]])</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">np.vstack((a, b)) <span class="comment"># 行方向连接</span></span><br></pre></td></tr></table></figure>




<pre><code>array([[2, 1, 4],
       [1, 2, 3],
       [3, 0, 1],
       [3, 2, 1]])</code></pre>
<p><strong>stack 堆叠数组, 堆叠后维度增加 1</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># axis=0, 行方向堆叠(默认), axis=1, 列方向堆叠</span></span><br><span class="line">np.stack((a[<span class="number">0</span>], b[<span class="number">0</span>])), np.stack((a[<span class="number">0</span>], b[<span class="number">0</span>]), axis=<span class="number">1</span>)</span><br></pre></td></tr></table></figure>




<pre><code>(array([[2, 1, 4],
        [3, 0, 1]]),
 array([[2, 3],
        [1, 0],
        [4, 1]]))</code></pre>
<h3 id="3-拆分数组"><a href="#3-拆分数组" class="headerlink" title="3, 拆分数组"></a>3, 拆分数组</h3><p><strong>split, hsplit, vsplit 将数组拆分, 返回为列表</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">np.split(a, <span class="number">2</span>), np.vsplit(a, <span class="number">2</span>), np.hsplit(a, <span class="number">3</span>)</span><br></pre></td></tr></table></figure>




<pre><code>([array([[2, 1, 4]]), array([[1, 2, 3]])],
 [array([[2, 1, 4]]), array([[1, 2, 3]])],
 [array([[2],
         [1]]),
  array([[1],
         [2]]),
  array([[4],
         [3]])])</code></pre>
<h3 id="4-添加-删除元素"><a href="#4-添加-删除元素" class="headerlink" title="4, 添加, 删除元素"></a>4, 添加, 删除元素</h3><p><strong>delete 删除指定索引的元素, 行或列</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a, np.delete(a, <span class="number">1</span>) <span class="comment"># 删除第 2 个元素</span></span><br></pre></td></tr></table></figure>




<pre><code>(array([[2, 1, 4],
        [1, 2, 3]]),
 array([2, 4, 1, 2, 3]))</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 删除第 2 行, 或第 2 列</span></span><br><span class="line">np.delete(a, <span class="number">1</span>, axis=<span class="number">0</span>), np.delete(a, <span class="number">1</span>, axis=<span class="number">1</span>)</span><br></pre></td></tr></table></figure>




<pre><code>(array([[2, 1, 4]]),
 array([[2, 4],
        [1, 3]]))</code></pre>
<p><strong>insert 在指定索引前插入元素, 行或列</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">np.insert(a, <span class="number">1</span>, <span class="number">9</span>)</span><br></pre></td></tr></table></figure>




<pre><code>array([2, 9, 1, 4, 1, 2, 3])</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">np.insert(a, <span class="number">1</span>, <span class="number">9</span>, axis=<span class="number">0</span>), np.insert(a, <span class="number">1</span>, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], axis=<span class="number">0</span>)</span><br></pre></td></tr></table></figure>




<pre><code>(array([[2, 1, 4],
        [9, 9, 9],
        [1, 2, 3]]),
 array([[2, 1, 4],
        [1, 2, 3],
        [1, 2, 3]]))</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">np.insert(a, <span class="number">1</span>, [<span class="number">1</span>, <span class="number">3</span>], axis=<span class="number">1</span>)</span><br></pre></td></tr></table></figure>




<pre><code>array([[2, 1, 1, 4],
       [1, 3, 2, 3]])</code></pre>
<p><strong>append 在数组末尾(或行,列末尾)加入元素, 行或列(维数必须相同)</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">np.append(a, <span class="number">2</span>)</span><br></pre></td></tr></table></figure>




<pre><code>array([2, 1, 4, 1, 2, 3, 2])</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">np.append(a, [[<span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>]], axis=<span class="number">0</span>), np.append(a, [[<span class="number">2</span>], [<span class="number">2</span>]], axis=<span class="number">1</span>)</span><br></pre></td></tr></table></figure>




<pre><code>(array([[2, 1, 4],
        [1, 2, 3],
        [2, 2, 2]]),
 array([[2, 1, 4, 2],
        [1, 2, 3, 2]]))</code></pre>
<p><strong>unique 查找数组中的唯一值</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = np.random.choice(<span class="number">4</span>, (<span class="number">2</span>, <span class="number">3</span>))</span><br><span class="line">display(a)</span><br><span class="line">np.unique(a,return_index=<span class="literal">True</span>,</span><br><span class="line">             return_inverse=<span class="literal">True</span>,</span><br><span class="line">             return_counts=<span class="literal">True</span>, axis=<span class="literal">None</span>)</span><br></pre></td></tr></table></figure>


<pre><code>array([[2, 3, 2],
       [2, 2, 0]])

(array([0, 2, 3]),
 array([5, 0, 1], dtype=int64),
 array([1, 2, 1, 1, 1, 0], dtype=int64),
 array([1, 4, 1], dtype=int64))</code></pre>
<h3 id="5-重新排列元素"><a href="#5-重新排列元素" class="headerlink" title="5, 重新排列元素"></a>5, 重新排列元素</h3><p><strong>flip, fliplr, flipud 翻转数组</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">np.flip(a), np.flip(a, <span class="number">0</span>), np.flip(a, <span class="number">1</span>)</span><br></pre></td></tr></table></figure>




<pre><code>(array([[0, 2, 2],
        [2, 3, 2]]),
 array([[2, 2, 0],
        [2, 3, 2]]),
 array([[2, 3, 2],
        [0, 2, 2]]))</code></pre>
<p><strong>sort 排序数组元素</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">np.sort(a)</span><br></pre></td></tr></table></figure>




<pre><code>array([[2, 2, 3],
       [0, 2, 2]])</code></pre>
<p><strong>roll 滚动数组元素</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">np.roll(a, <span class="number">1</span>), np.roll(a, <span class="number">1</span>, axis=<span class="number">0</span>), np.roll(a, <span class="number">1</span>, axis=<span class="number">1</span>)</span><br></pre></td></tr></table></figure>




<pre><code>(array([[0, 2, 3],
        [2, 2, 2]]),
 array([[2, 2, 0],
        [2, 3, 2]]),
 array([[2, 2, 3],
        [0, 2, 2]]))</code></pre>
<h3 id="6-常用数学运算函数"><a href="#6-常用数学运算函数" class="headerlink" title="6, 常用数学运算函数"></a>6, 常用数学运算函数</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="comment"># 固定随机种子</span></span><br><span class="line">np.random.seed(<span class="number">0</span>)</span><br><span class="line">a = np.random.randint(<span class="number">1</span>, <span class="number">6</span>, (<span class="number">3</span>, <span class="number">4</span>))</span><br><span class="line">b = np.arange(<span class="number">12</span>).reshape((<span class="number">3</span>, <span class="number">4</span>))</span><br><span class="line">a, b</span><br></pre></td></tr></table></figure>




<pre><code>(array([[5, 1, 4, 4],
        [4, 2, 4, 3],
        [5, 1, 1, 5]]),
 array([[ 0,  1,  2,  3],
        [ 4,  5,  6,  7],
        [ 8,  9, 10, 11]]))</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">np.power(b, a) <span class="comment"># b**a</span></span><br></pre></td></tr></table></figure>




<pre><code>array([[     0,      1,     16,     81],
       [   256,     25,   1296,    343],
       [ 32768,      9,     10, 161051]], dtype=int32)</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">np.<span class="built_in">divmod</span>(b, a) <span class="comment"># 商 和 余</span></span><br></pre></td></tr></table></figure>




<pre><code>(array([[ 0,  1,  0,  0],
        [ 1,  2,  1,  2],
        [ 1,  9, 10,  2]], dtype=int32),
 array([[0, 0, 2, 3],
        [0, 1, 2, 1],
        [3, 0, 0, 1]], dtype=int32))</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">np.fabs(-a), np.<span class="built_in">abs</span>(-a) <span class="comment"># 取绝对值</span></span><br></pre></td></tr></table></figure>




<pre><code>(array([[5., 1., 4., 4.],
        [4., 2., 4., 3.],
        [5., 1., 1., 5.]]),
 array([[5, 1, 4, 4],
        [4, 2, 4, 3],
        [5, 1, 1, 5]]))</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">c = np.random.rand(<span class="number">3</span>, <span class="number">4</span>) * <span class="number">10</span></span><br><span class="line">display(c)</span><br><span class="line">np.rint(c) <span class="comment"># 舍入最接近的整数</span></span><br></pre></td></tr></table></figure>


<pre><code>array([[5.81272873, 8.81735362, 6.9253159 , 7.2525428 ],
       [5.01324382, 9.56083635, 6.43990199, 4.23855049],
       [6.06393214, 0.19193198, 3.01574817, 6.60173537]])

array([[ 6.,  9.,  7.,  7.],
       [ 5., 10.,  6.,  4.],
       [ 6.,  0.,  3.,  7.]])</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">np.exp(a).<span class="built_in">round</span>(<span class="number">1</span>) <span class="comment"># np.e ** a</span></span><br></pre></td></tr></table></figure>




<pre><code>array([[148.4,   2.7,  54.6,  54.6],
       [ 54.6,   7.4,  54.6,  20.1],
       [148.4,   2.7,   2.7, 148.4]])</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">b = np.exp2(a) <span class="comment"># 2**a</span></span><br><span class="line">a, b</span><br></pre></td></tr></table></figure>




<pre><code>(array([[5, 1, 4, 4],
        [4, 2, 4, 3],
        [5, 1, 1, 5]]),
 array([[32.,  2., 16., 16.],
        [16.,  4., 16.,  8.],
        [32.,  2.,  2., 32.]]))</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">np.log(a)</span><br><span class="line">np.log2(a)</span><br><span class="line">np.log10(a)</span><br><span class="line">np.sqrt(a) <span class="comment"># 开根号</span></span><br><span class="line">np.gcd(a, b.astype(<span class="built_in">int</span>)) <span class="comment"># 最大公约数</span></span><br><span class="line">np.lcm(a, b.astype(<span class="built_in">int</span>)) <span class="comment"># 最小公倍数</span></span><br></pre></td></tr></table></figure>




<pre><code>array([[160,   2,  16,  16],
       [ 16,   4,  16,  24],
       [160,   2,   2, 160]])</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">np.sin(a)</span><br><span class="line">np.cos(a)</span><br><span class="line">np.tan(a)</span><br></pre></td></tr></table></figure>




<pre><code>array([[-3.38051501,  1.55740772,  1.15782128,  1.15782128],
       [ 1.15782128, -2.18503986,  1.15782128, -0.14254654],
       [-3.38051501,  1.55740772,  1.55740772, -3.38051501]])</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">np.greater(a, b) <span class="comment"># a &gt; b</span></span><br><span class="line">np.less(a, b) <span class="comment"># a &lt; b</span></span><br><span class="line">a != b <span class="comment"># np.not_equal(a, b)</span></span><br><span class="line">(a &gt; <span class="number">2</span>) | ~(b &lt; <span class="number">5</span>) <span class="comment"># np.logical_or(a&gt;2, ~(b&lt;5))</span></span><br></pre></td></tr></table></figure>




<pre><code>array([[ True, False,  True,  True],
       [ True, False,  True,  True],
       [ True, False, False,  True]])</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 两者取其大, 同 np.fmax(a*5, b) 对应还有 minimum, fmin</span></span><br><span class="line">np.maximum(a*<span class="number">5</span>, b) </span><br></pre></td></tr></table></figure>




<pre><code>array([[32.,  5., 20., 20.],
       [20., 10., 20., 15.],
       [32.,  5.,  5., 32.]])</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">np.isinf(a) <span class="comment"># 判断是否正负无穷大</span></span><br><span class="line">np.isnan(a) <span class="comment"># 判断是否 nan</span></span><br></pre></td></tr></table></figure>




<pre><code>array([[False, False, False, False],
       [False, False, False, False],
       [False, False, False, False]])</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">np.modf(c) <span class="comment"># 分别返回小数和整数部分</span></span><br></pre></td></tr></table></figure>




<pre><code>(array([[0.81272873, 0.81735362, 0.9253159 , 0.2525428 ],
        [0.01324382, 0.56083635, 0.43990199, 0.23855049],
        [0.06393214, 0.19193198, 0.01574817, 0.60173537]]),
 array([[5., 8., 6., 7.],
        [5., 9., 6., 4.],
        [6., 0., 3., 6.]]))</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">np.fmod(b, a) <span class="comment"># 返回余数</span></span><br></pre></td></tr></table></figure>




<pre><code>array([[2., 0., 0., 0.],
       [0., 0., 0., 2.],
       [2., 0., 0., 2.]])</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">c = np.random.rand(<span class="number">3</span>, <span class="number">4</span>) * <span class="number">10</span></span><br><span class="line">display(c)</span><br><span class="line">np.floor(c) <span class="comment"># 向下取整</span></span><br><span class="line">np.ceil(c) <span class="comment"># 向上取整</span></span><br></pre></td></tr></table></figure>


<pre><code>array([[9.61570155, 2.31701626, 9.49318822, 9.41377705],
       [7.99202587, 6.30447937, 8.74287967, 2.93020285],
       [8.48943555, 6.17876692, 0.13236858, 3.47233518]])

array([[10.,  3., 10., 10.],
       [ 8.,  7.,  9.,  3.],
       [ 9.,  7.,  1.,  4.]])</code></pre>
<h3 id="7-字符串操作"><a href="#7-字符串操作" class="headerlink" title="7, 字符串操作"></a>7, 字符串操作</h3><p>字符串的操作函数, 和 python 的操作函数相似, 只是 numpy 作用到整个数组上</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = np.array([[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>], [<span class="number">20</span>, <span class="number">19</span>, <span class="number">18</span>]])</span><br><span class="line">np.char.add(a, a)</span><br></pre></td></tr></table></figure>




<pre><code>array([[&#39;aa&#39;, &#39;bb&#39;, &#39;cc&#39;],
       [&#39;2020&#39;, &#39;1919&#39;, &#39;1818&#39;]], dtype=&#39;&lt;U4&#39;)</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">np.char.multiply(a, <span class="number">3</span>)</span><br></pre></td></tr></table></figure>




<pre><code>array([[&#39;aaa&#39;, &#39;bbb&#39;, &#39;ccc&#39;],
       [&#39;202020&#39;, &#39;191919&#39;, &#39;181818&#39;]], dtype=&#39;&lt;U6&#39;)</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 将每一个制表符替换成指定个数的空格</span></span><br><span class="line">b = np.array(<span class="string">&#x27;\ta\t\tbc\td&#x27;</span>)</span><br><span class="line">np.char.expandtabs(b, <span class="number">1</span>)</span><br></pre></td></tr></table></figure>




<pre><code>array(&#39; a  bc d&#39;, dtype=&#39;&lt;U8&#39;)</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">np.char.replace(a, <span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;2&#x27;</span>) <span class="comment"># 替换</span></span><br></pre></td></tr></table></figure>




<pre><code>array([[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;],
       [&#39;20&#39;, &#39;29&#39;, &#39;28&#39;]], dtype=&#39;&lt;U2&#39;)</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">np.char.title(a)</span><br></pre></td></tr></table></figure>




<pre><code>array([[&#39;A&#39;, &#39;B&#39;, &#39;C&#39;],
       [&#39;20&#39;, &#39;19&#39;, &#39;18&#39;]], dtype=&#39;&lt;U2&#39;)</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">b = np.char.zfill(a, <span class="number">4</span>)</span><br><span class="line">b</span><br></pre></td></tr></table></figure>




<pre><code>array([[&#39;000a&#39;, &#39;000b&#39;, &#39;000c&#39;],
       [&#39;0020&#39;, &#39;0019&#39;, &#39;0018&#39;]], dtype=&#39;&lt;U4&#39;)</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">np.char.count(b, <span class="string">&#x27;0&#x27;</span>) <span class="comment"># 0 出现的次数</span></span><br></pre></td></tr></table></figure>




<pre><code>array([[3, 3, 3],
       [3, 2, 2]])</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">np.char.str_len(a) <span class="comment"># 字符串长度</span></span><br></pre></td></tr></table></figure>




<pre><code>array([[1, 1, 1],
       [2, 2, 2]])</code></pre>
<h3 id="8-索引与迭代"><a href="#8-索引与迭代" class="headerlink" title="8, 索引与迭代"></a>8, 索引与迭代</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = np.random.choice(<span class="number">4</span>, (<span class="number">3</span>, <span class="number">4</span>))</span><br><span class="line">display(a)</span><br><span class="line">np.nonzero(a) <span class="comment"># 非 0 索引</span></span><br></pre></td></tr></table></figure>


<pre><code>array([[0, 0, 1, 0],
       [1, 0, 3, 2],
       [2, 1, 0, 0]])

(array([0, 1, 1, 1, 2, 2], dtype=int64),
 array([2, 0, 2, 3, 0, 1], dtype=int64))</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 返回指定条件的元素的索引, 并可进行替换</span></span><br><span class="line"><span class="comment"># 不设条件, 和 nonzero 一样</span></span><br><span class="line">np.where(a&gt;<span class="number">0</span>)</span><br></pre></td></tr></table></figure>




<pre><code>(array([0, 1, 1, 1, 2, 2], dtype=int64),
 array([2, 0, 2, 3, 0, 1], dtype=int64))</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 大于 0 都换成 a, 否则都换成 b</span></span><br><span class="line">np.where(a&gt;<span class="number">0</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>)</span><br></pre></td></tr></table></figure>




<pre><code>array([[&#39;b&#39;, &#39;b&#39;, &#39;a&#39;, &#39;b&#39;],
       [&#39;a&#39;, &#39;b&#39;, &#39;a&#39;, &#39;a&#39;],
       [&#39;a&#39;, &#39;a&#39;, &#39;b&#39;, &#39;b&#39;]], dtype=&#39;&lt;U1&#39;)</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">np.nditer(a) <span class="comment"># 将数组变成一个高效的迭代器</span></span><br></pre></td></tr></table></figure>




<pre><code>&lt;numpy.nditer at 0x2066f761710&gt;</code></pre>
<h3 id="9-统计运算函数"><a href="#9-统计运算函数" class="headerlink" title="9, 统计运算函数"></a>9, 统计运算函数</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 下述与 ndarray 对象直接调用的方法一样</span></span><br><span class="line">a = np.random.rand(<span class="number">3</span>, <span class="number">4</span>) * <span class="number">5</span></span><br><span class="line">np.<span class="built_in">all</span>(a)</span><br><span class="line">np.<span class="built_in">any</span>(a)</span><br><span class="line">np.<span class="built_in">max</span>(a)</span><br><span class="line">np.<span class="built_in">sum</span>(a)</span><br><span class="line">np.mean(a)</span><br><span class="line">np.cumsum(a)</span><br><span class="line">np.var(a)</span><br><span class="line">np.std(a)</span><br><span class="line">np.clip(a, <span class="number">1</span>, <span class="number">3</span>)</span><br><span class="line">np.around(a, <span class="number">2</span>) <span class="comment"># ndarray 对象的方法是 round</span></span><br><span class="line"><span class="comment"># 等等</span></span><br></pre></td></tr></table></figure>




<pre><code>array([[0.38, 2.59, 1.53, 2.89],
       [4.8 , 3.23, 0.18, 2.15],
       [2.55, 2.68, 3.41, 1.39]])</code></pre>
<p>任何数与 nan 计算都是 nan, 可以用相应的函数排除 nan</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">b = np.array([<span class="number">1</span>, np.nan, <span class="number">3</span>, <span class="number">4</span>])</span><br><span class="line">np.<span class="built_in">sum</span>(b), np.nansum(b)</span><br></pre></td></tr></table></figure>




<pre><code>(nan, 8.0)</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">np.nancumsum(b)</span><br></pre></td></tr></table></figure>




<pre><code>array([1., 1., 4., 8.])</code></pre>
]]></content>
      <categories>
        <category>数据分析</category>
      </categories>
      <tags>
        <tag>numpy</tag>
      </tags>
  </entry>
  <entry>
    <title>时间序列，导入导出与可视化</title>
    <url>/data/pandas3-bd0cfff75a2b/</url>
    <content><![CDATA[<blockquote>
<p>pandas 是 Python 的核心数据分析支持库, 基于 NumPy 创建, 它使 python 成为强大而高效的数据分析环境 </p>
</blockquote>
<blockquote>
<p>pandas 基础最重要知识点就是两个数据结构 Series(一维) 和 DataFrame(二维), 处理这两个数据结构的方法和函数, 以及运用的逻辑</p>
</blockquote>
<blockquote>
<p>下文约定 NumPy 简写 <code>np</code>, Pandas 简写 <code>pd</code>, Series 简写 <code>s</code>, DataFrame 简写 <code>df</code></p>
</blockquote>
<h2 id="三-时间序列"><a href="#三-时间序列" class="headerlink" title="三, 时间序列"></a>三, 时间序列</h2><p>时间序列对数据分析很重要, 很多数据都和时间发生的先后顺序相关</p>
<p><strong>date_range 生成时间序列</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line">pd.date_range(start=<span class="string">&#x27;20200701&#x27;</span>, end=<span class="string">&#x27;20200705&#x27;</span>)</span><br></pre></td></tr></table></figure>




<pre><code>DatetimeIndex([&#39;2020-07-01&#39;, &#39;2020-07-02&#39;, &#39;2020-07-03&#39;, &#39;2020-07-04&#39;,
               &#39;2020-07-05&#39;],
              dtype=&#39;datetime64[ns]&#39;, freq=&#39;D&#39;)</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 可以指定生成个数与频率等</span></span><br><span class="line">pd.date_range(start=<span class="string">&#x27;6/1/2020&#x27;</span>, periods=<span class="number">5</span>, freq=<span class="string">&#x27;10D&#x27;</span>)</span><br></pre></td></tr></table></figure>




<pre><code>DatetimeIndex([&#39;2020-06-01&#39;, &#39;2020-06-11&#39;, &#39;2020-06-21&#39;, &#39;2020-07-01&#39;,
               &#39;2020-07-11&#39;],
              dtype=&#39;datetime64[ns]&#39;, freq=&#39;10D&#39;)</code></pre>
<p><strong>to_datetime 转换时间格式</strong></p>
<p>1970年 1 月 1 日 00:00:00 UTC+00:00 时区的时刻称为 epoch time，记为 0，当前时间就是相对于 epoch time 的秒数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 获取本地当前时间</span></span><br><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime</span><br><span class="line">print(datetime.now())</span><br><span class="line">d = datetime.now().timestamp()</span><br><span class="line">print(datetime.fromtimestamp(d))</span><br><span class="line">d</span><br></pre></td></tr></table></figure>

<pre><code>2020-07-17 10:57:59.465220
2020-07-17 10:57:59.465220

1594954679.46522</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 数字形式的时间, 用 to_datetime 转换为时间格式后与上述有差别,</span></span><br><span class="line"><span class="comment"># 是由于时区的原因, 转换时区即可一样</span></span><br><span class="line">print(pd.to_datetime(d, utc=<span class="literal">True</span>, unit=<span class="string">&#x27;s&#x27;</span>))</span><br><span class="line">d = pd.Series(d)</span><br><span class="line">pd.to_datetime(d, utc=<span class="literal">True</span>, unit=<span class="string">&#x27;s&#x27;</span>).dt.tz_convert(<span class="string">&#x27;Asia/Shanghai&#x27;</span>)</span><br></pre></td></tr></table></figure>

<pre><code>0   2020-07-17 02:57:59.465219975+00:00
dtype: datetime64[ns, UTC]

0   2020-07-17 10:57:59.465219975+08:00
dtype: datetime64[ns, Asia/Shanghai]</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 各种日期格式的转换</span></span><br><span class="line">print(pd.to_datetime([<span class="string">&#x27;07-17-2020&#x27;</span>, <span class="string">&#x27;11-07-2020&#x27;</span>], dayfirst=<span class="literal">True</span>))</span><br><span class="line">print(pd.to_datetime(<span class="string">&#x27;2020年7月17日&#x27;</span>, <span class="built_in">format</span>=<span class="string">&#x27;%Y年%m月%d日&#x27;</span>))</span><br><span class="line">pd.to_datetime([<span class="string">&#x27;jul 17, 2020&#x27;</span>,</span><br><span class="line">                <span class="string">&#x27;2020-07-17&#x27;</span>,</span><br><span class="line">                <span class="string">&#x27;20200717&#x27;</span>,</span><br><span class="line">                <span class="string">&#x27;2020/07/17&#x27;</span>,</span><br><span class="line">                <span class="string">&#x27;2020.07.17&#x27;</span>, </span><br><span class="line">                np.nan])</span><br></pre></td></tr></table></figure>

<pre><code>DatetimeIndex([&#39;2020-07-17&#39;, &#39;2020-07-11&#39;], dtype=&#39;datetime64[ns]&#39;, freq=None)
2020-07-17 00:00:00

DatetimeIndex([&#39;2020-07-17&#39;, &#39;2020-07-17&#39;, &#39;2020-07-17&#39;, &#39;2020-07-17&#39;,
               &#39;2020-07-17&#39;, &#39;NaT&#39;],
              dtype=&#39;datetime64[ns]&#39;, freq=None)</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 可以跳过非时间, 可以转换 df 但索引名是固定的名称</span></span><br><span class="line">print(pd.to_datetime([<span class="string">&#x27;2020.07.17&#x27;</span>, <span class="string">&#x27;日期&#x27;</span>], errors=<span class="string">&#x27;coerce&#x27;</span>))</span><br><span class="line">df = pd.DataFrame(&#123;<span class="string">&#x27;year&#x27;</span>: [<span class="number">2019</span>, <span class="number">2020</span>],</span><br><span class="line">              <span class="string">&#x27;month&#x27;</span>: [<span class="number">6</span>, <span class="number">7</span>],</span><br><span class="line">              <span class="string">&#x27;day&#x27;</span>: [<span class="number">4</span>, <span class="number">5</span>]&#125;)</span><br><span class="line">pd.to_datetime(df)</span><br></pre></td></tr></table></figure>

<pre><code>DatetimeIndex([&#39;2020-07-17&#39;, &#39;NaT&#39;], dtype=&#39;datetime64[ns]&#39;, freq=None)

0   2019-06-04
1   2020-07-05
dtype: datetime64[ns]</code></pre>
<p><strong>tshift 时间索引移动, 数据不变</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df = pd.DataFrame(np.random.randint(<span class="number">0</span>, <span class="number">10</span>, (<span class="number">5</span>, <span class="number">2</span>)),</span><br><span class="line">                  index=pd.date_range(<span class="string">&#x27;20180717&#x27;</span>, periods=<span class="number">5</span>, freq=<span class="string">&#x27;200D&#x27;</span>))</span><br><span class="line">df, df.tshift(<span class="number">2</span>), df.tshift(<span class="number">-2</span>)</span><br></pre></td></tr></table></figure>




<pre><code>(            0  1
 2018-07-17  0  5
 2019-02-02  7  9
 2019-08-21  2  4
 2020-03-08  5  8
 2020-09-24  8  6,
             0  1
 2019-08-21  0  5
 2020-03-08  7  9
 2020-09-24  2  4
 2021-04-12  5  8
 2021-10-29  8  6,
             0  1
 2017-06-12  0  5
 2017-12-29  7  9
 2018-07-17  2  4
 2019-02-02  5  8
 2019-08-21  8  6)</code></pre>
<p><strong>时间索引取值, between_time 取时间段</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df[<span class="string">&#x27;2018&#x27;</span>:<span class="string">&#x27;2019&#x27;</span>], df[<span class="string">&#x27;2019-01&#x27;</span>:<span class="string">&#x27;2020-01&#x27;</span>]</span><br></pre></td></tr></table></figure>




<pre><code>(            0  1
 2018-07-17  0  5
 2019-02-02  7  9
 2019-08-21  2  4,
             0  1
 2019-02-02  7  9
 2019-08-21  2  4)</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df.index = pd.date_range(<span class="string">&#x27;20200717&#x27;</span>, periods=<span class="number">5</span>, freq=<span class="string">&#x27;2H&#x27;</span>)</span><br><span class="line">print(df.between_time(<span class="string">&#x27;3:00&#x27;</span>, <span class="string">&#x27;7:00&#x27;</span>))</span><br></pre></td></tr></table></figure>

<pre><code>                     0  1
2020-07-17 04:00:00  2  4
2020-07-17 06:00:00  5  8</code></pre>
<p><strong>时间序列作为数据的操作</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df.index = pd.date_range(<span class="string">&#x27;20180717&#x27;</span>, periods=<span class="number">5</span>, freq=<span class="string">&#x27;100D&#x27;</span>)</span><br><span class="line">df.index.name = <span class="string">&#x27;日期&#x27;</span></span><br><span class="line">df.reset_index(inplace=<span class="literal">True</span>)</span><br><span class="line">df, df.日期.dt.day</span><br></pre></td></tr></table></figure>




<pre><code>(                   日期  0  1  月份
 2018-07-17 2018-07-17  0  5   7
 2018-10-25 2018-10-25  7  9  10
 2019-02-02 2019-02-02  2  4   2
 2019-05-13 2019-05-13  5  8   5
 2019-08-21 2019-08-21  8  6   8,
 2018-07-17    17
 2018-10-25    25
 2019-02-02     2
 2019-05-13    13
 2019-08-21    21
 Freq: 100D, Name: 日期, dtype: int64)</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df[<span class="string">&#x27;月份&#x27;</span>] = df[<span class="string">&#x27;日期&#x27;</span>].dt.month</span><br><span class="line">df, df[df.日期.dt.month &gt;= <span class="number">5</span>], df[df.月份 &gt;= <span class="number">5</span>]</span><br></pre></td></tr></table></figure>




<pre><code>(                   日期  0  1  月份
 2018-07-17 2018-07-17  0  5   7
 2018-10-25 2018-10-25  7  9  10
 2019-02-02 2019-02-02  2  4   2
 2019-05-13 2019-05-13  5  8   5
 2019-08-21 2019-08-21  8  6   8,
                    日期  0  1  月份
 2018-07-17 2018-07-17  0  5   7
 2018-10-25 2018-10-25  7  9  10
 2019-05-13 2019-05-13  5  8   5
 2019-08-21 2019-08-21  8  6   8,
                    日期  0  1  月份
 2018-07-17 2018-07-17  0  5   7
 2018-10-25 2018-10-25  7  9  10
 2019-05-13 2019-05-13  5  8   5
 2019-08-21 2019-08-21  8  6   8)</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">d = df.日期.astype(<span class="built_in">str</span>).<span class="built_in">str</span>.split(<span class="string">&#x27;-&#x27;</span>, expand=<span class="literal">True</span>)</span><br><span class="line">df, d, df[d[<span class="number">0</span>] ==<span class="string">&#x27;2018&#x27;</span>]</span><br></pre></td></tr></table></figure>




<pre><code>(                   日期  0  1  月份
 2018-07-17 2018-07-17  0  5   7
 2018-10-25 2018-10-25  7  9  10
 2019-02-02 2019-02-02  2  4   2
 2019-05-13 2019-05-13  5  8   5
 2019-08-21 2019-08-21  8  6   8,
                0   1   2
 2018-07-17  2018  07  17
 2018-10-25  2018  10  25
 2019-02-02  2019  02  02
 2019-05-13  2019  05  13
 2019-08-21  2019  08  21,
                    日期  0  1  月份
 2018-07-17 2018-07-17  0  5   7
 2018-10-25 2018-10-25  7  9  10)</code></pre>
<h2 id="四-数据的导入导出与可视化"><a href="#四-数据的导入导出与可视化" class="headerlink" title="四, 数据的导入导出与可视化"></a>四, 数据的导入导出与可视化</h2><h3 id="1-pd-可以导入导出多种格式的数据"><a href="#1-pd-可以导入导出多种格式的数据" class="headerlink" title="1, pd 可以导入导出多种格式的数据:"></a>1, pd 可以导入导出多种格式的数据:</h3><p>read_csv,    to_csv<br>read_json,    to_json<br>read_html,    to_html<br>read_excel,    to_excel<br>read_hdf,    to_hdf<br>等等</p>
<p>参数非常多, 简单看几个</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 默认读取第一个 sheet, 默认第一行为列索引</span></span><br><span class="line">df = pd.read_excel(<span class="string">&#x27;数据/sheet.xlsx&#x27;</span>,</span><br><span class="line">                   sheet_name=<span class="number">0</span>, header=<span class="number">0</span>)</span><br><span class="line">print(df)</span><br></pre></td></tr></table></figure>

<pre><code>   名次  战队名         说明
0   1  FPX      四包二战术
1   2   G2      个人能力强
2   3   IG       喜欢打架
3   4  SKT  Faker状态低迷
4   5  GRF      上单是短板
5   6  DWG        下路弱
6   7  FNC       欧洲强队
7   8  SPY        AD强
8   9  RNG        四保一
9  10   TL       北美强队</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 可以设置将某列作为行索引, 某列作为列索引</span></span><br><span class="line">df1 = pd.read_excel(<span class="string">&#x27;数据/sheet.xlsx&#x27;</span>,</span><br><span class="line">                   sheet_name=<span class="number">1</span>)</span><br><span class="line">df2 = pd.read_excel(<span class="string">&#x27;数据/sheet.xlsx&#x27;</span>,</span><br><span class="line">                   sheet_name=<span class="number">1</span>,</span><br><span class="line">                   header=<span class="number">1</span>,</span><br><span class="line">                   index_col=<span class="number">0</span>)</span><br><span class="line">df1, df2</span><br></pre></td></tr></table></figure>




<pre><code>(   名次        上单
 0   1   GIMGOOM
 1   2    WUNDER
 2   3      KHAN
 3   4   FLANDER
 4   5    THESHY
 5   6    NUGURI
 6   7     BWIPO
 7   8   IPMPACT
 8   9  LICORICE
 9  10      HUNI,
      GIMGOOM
 1           
 2     WUNDER
 3       KHAN
 4    FLANDER
 5     THESHY
 6     NUGURI
 7      BWIPO
 8    IPMPACT
 9   LICORICE
 10      HUNI)</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 有时报错需要根据文件调节编码和引擎参数</span></span><br><span class="line">df = pd.read_csv(<span class="string">&#x27;数据/ratings_chinses.csv&#x27;</span>,</span><br><span class="line">                 engine=<span class="literal">None</span>,</span><br><span class="line">                 encoding=<span class="string">&#x27;gbk&#x27;</span>)</span><br><span class="line">print(df)</span><br></pre></td></tr></table></figure>

<pre><code>       数量   收获  评分
0     1.0  235   4
1     1.0  260   4
2     2.0  296   4
3     2.0  316   5
4     2.5  333   5
..    ...  ...  ..
97   39.7  231   4
98   40.1  235   5
99   40.5  260   4
100  40.9  296   5
101  41.3  316   3

[102 rows x 3 columns]</code></pre>
<h3 id="2-可视化"><a href="#2-可视化" class="headerlink" title="2, 可视化"></a>2, 可视化</h3><p>pd 有自己简单的可视化方法, 但通常使用 matplotlib, 或一起使用</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">plt.rcParams[<span class="string">&#x27;font.family&#x27;</span>] = <span class="string">&#x27;YouYuan&#x27;</span> </span><br><span class="line">plt.rcParams[<span class="string">&#x27;font.size&#x27;</span>] = <span class="number">12</span></span><br><span class="line"></span><br><span class="line">df.收获.plot() </span><br></pre></td></tr></table></figure>


<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df[<span class="string">&#x27;评分&#x27;</span>].plot(kind=<span class="string">&#x27;hist&#x27;</span>) </span><br></pre></td></tr></table></figure>


<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df.plot(x=<span class="string">&#x27;数量&#x27;</span>, y=<span class="string">&#x27;评分&#x27;</span>) </span><br></pre></td></tr></table></figure>


<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df.评分.plot.box()</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据分析</category>
      </categories>
      <tags>
        <tag>pandas</tag>
      </tags>
  </entry>
  <entry>
    <title>认识 python</title>
    <url>/data/python1-8843db772140/</url>
    <content><![CDATA[<blockquote>
<p>整理更偏重数据分析方向的 python 基础知识, 快速入门. python 应用领域广泛, 在科学计算, 统计, 人工智能等领域有巨大优势, 学好 python 基础对入门数据分析来说, 是基石</p>
</blockquote>
<p><a href="https://docs.python.org/zh-cn/3.8/">python官方文档</a></p>
<p><font color=#00A600 >2020年6月19日更新</font></p>
<h2 id="一-认识-python"><a href="#一-认识-python" class="headerlink" title="一, 认识 python"></a>一, 认识 python</h2><p>学习环境: <a href="https://www.anaconda.com/">anaconda</a> 的 jupyter lab</p>
<h3 id="1-数据类型"><a href="#1-数据类型" class="headerlink" title="1, 数据类型"></a>1, 数据类型</h3><p>python 的数据类型, 就像数学中的整数, 分数, 小数, 复数…一样, 是计算机用来计算的数据对象的分类</p>
<h4 id="a-常用数据类型"><a href="#a-常用数据类型" class="headerlink" title="a, 常用数据类型:"></a>a, 常用数据类型:</h4><p>整型 int, 例如 1, 2, 3</p>
<p>浮点型 float, 例如 1.2, 3.14</p>
<p>字符型 str, 例如 ‘1’, ‘python’, ‘数据分析’</p>
<p>布尔型 bool, 只有 True 和 False</p>
<p>列表 list, 例如 [1, ‘1’, 3.14, True]</p>
<p>元组 tuple, 例如 (1, ‘a’, False)</p>
<p>字典 dict, 例如 {‘a’: 1, 2: ‘b’}</p>
<p>集合 set, 例如 {1, ‘a’, False}</p>
<p>空值 None</p>
<h4 id="b-查看数据类型-type"><a href="#b-查看数据类型-type" class="headerlink" title="b, 查看数据类型 type():"></a>b, 查看数据类型 <code>type()</code>:</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">type</span>(<span class="number">1</span>)</span><br></pre></td></tr></table></figure>




<pre><code>int</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">type</span>(<span class="number">3.14</span>)</span><br></pre></td></tr></table></figure>




<pre><code>float</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">type</span>(<span class="string">&#x27;1&#x27;</span>)</span><br></pre></td></tr></table></figure>




<pre><code>str</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">type</span>(<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>




<pre><code>bool</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">type</span>([<span class="number">1</span>,<span class="string">&#x27;1&#x27;</span>])</span><br></pre></td></tr></table></figure>




<pre><code>list</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">type</span>((<span class="number">1</span>,<span class="string">&#x27;1&#x27;</span>))</span><br></pre></td></tr></table></figure>




<pre><code>tuple</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">type</span>(<span class="literal">None</span>)</span><br></pre></td></tr></table></figure>




<pre><code>NoneType</code></pre>
<h4 id="c-数据类型间通常可以相互转换"><a href="#c-数据类型间通常可以相互转换" class="headerlink" title="c, 数据类型间通常可以相互转换:"></a>c, 数据类型间通常可以相互转换:</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span>(<span class="string">&#x27;1&#x27;</span>) </span><br></pre></td></tr></table></figure>




<pre><code>1</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">str</span>(<span class="number">1</span>)</span><br></pre></td></tr></table></figure>




<pre><code>&#39;1&#39;</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">float</span>(<span class="number">1</span>)</span><br></pre></td></tr></table></figure>




<pre><code>1.0</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">list</span>(<span class="string">&#x27;123&#x27;</span>)</span><br></pre></td></tr></table></figure>




<pre><code>[&#39;1&#39;, &#39;2&#39;, &#39;3&#39;]</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">str</span>([<span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;2&#x27;</span>, <span class="string">&#x27;3&#x27;</span>])</span><br></pre></td></tr></table></figure>




<pre><code>&quot;[&#39;1&#39;, &#39;2&#39;, &#39;3&#39;]&quot;</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">tuple</span>([<span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;2&#x27;</span>, <span class="string">&#x27;3&#x27;</span>])</span><br></pre></td></tr></table></figure>




<pre><code>(&#39;1&#39;, &#39;2&#39;, &#39;3&#39;)</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">list</span>(&#123;<span class="string">&#x27;a&#x27;</span>: <span class="number">1</span>, <span class="number">2</span>: <span class="string">&#x27;b&#x27;</span>&#125;)</span><br></pre></td></tr></table></figure>




<pre><code>[&#39;a&#39;, 2]</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">list</span>(&#123;<span class="number">1</span>, <span class="string">&#x27;a&#x27;</span>, <span class="literal">False</span>&#125;)</span><br></pre></td></tr></table></figure>




<pre><code>[&#39;a&#39;, 1, False]</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">bool</span>(<span class="string">&#x27;a&#x27;</span>)</span><br></pre></td></tr></table></figure>




<pre><code>True</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span>(<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>




<pre><code>1</code></pre>
<h4 id="d-bool-类型"><a href="#d-bool-类型" class="headerlink" title="d, bool 类型"></a>d, <code>bool</code> 类型</h4><p><code>bool</code> 类型相当于将对象都转换为计算机底层的 <code>0</code> 和 <code>1</code>. <code>判断为错误</code>(例如 1&gt;2), <code>0</code>或<code>空</code>为 False, <code>判断为正确</code>, <code>非0</code>或<code>非空</code>即是 True</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">bool</span>(<span class="number">1</span>)</span><br></pre></td></tr></table></figure>




<pre><code>True</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">bool</span>(<span class="number">1</span>==<span class="number">1</span>)</span><br></pre></td></tr></table></figure>




<pre><code>True</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">bool</span>(<span class="number">1</span>==<span class="number">2</span>)</span><br></pre></td></tr></table></figure>




<pre><code>False</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">bool</span>(<span class="number">0</span>)</span><br></pre></td></tr></table></figure>




<pre><code>False</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">bool</span>([]) <span class="comment"># []空列表</span></span><br></pre></td></tr></table></figure>




<pre><code>False</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">bool</span>(<span class="literal">None</span>)</span><br></pre></td></tr></table></figure>




<pre><code>False</code></pre>
<h3 id="2-运算符"><a href="#2-运算符" class="headerlink" title="2, 运算符"></a>2, 运算符</h3><p>计算机中的运算符, 相当于数学中的加减乘除等将数据进行运算的符号.</p>
<h4 id="a-算术运算符"><a href="#a-算术运算符" class="headerlink" title="a, 算术运算符:"></a>a, 算术运算符:</h4><p><code>+</code> 加, <code>-</code> 减 (或负号), <code>*</code> 乘, <code>/</code> 除, <code>//</code> 取整除, <code>%</code> 取余, <code>**</code>指数, 括号 <code>()</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> + <span class="number">3</span></span><br></pre></td></tr></table></figure>




<pre><code>4</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="literal">True</span> + <span class="number">1</span></span><br></pre></td></tr></table></figure>




<pre><code>2</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;a&#x27;</span> + <span class="string">&#x27;b&#x27;</span></span><br></pre></td></tr></table></figure>




<pre><code>&#39;ab&#39;</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">-1</span> + <span class="number">3</span></span><br></pre></td></tr></table></figure>




<pre><code>2</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">2</span> * (<span class="number">3</span> / <span class="number">5</span>)</span><br></pre></td></tr></table></figure>




<pre><code>1.2</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">9</span> // <span class="number">4</span></span><br></pre></td></tr></table></figure>




<pre><code>2</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">9</span> % <span class="number">4</span></span><br></pre></td></tr></table></figure>




<pre><code>1</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">2</span>**<span class="number">3</span></span><br></pre></td></tr></table></figure>




<pre><code>8</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">2</span>]*<span class="number">2</span></span><br></pre></td></tr></table></figure>




<pre><code>[1, 2, 1, 2]</code></pre>
<p>优先级: 指数 <code>&gt;</code> 乘, 除, 取整除, 取余 <code>&gt;</code> 加, 减. 用 <code>()</code> 可调整优先级, 增强可读性</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">3</span> + <span class="number">2</span> - <span class="number">5</span> * (<span class="number">3</span> / <span class="number">2</span> - <span class="number">5</span>)**(<span class="number">-2</span>)</span><br></pre></td></tr></table></figure>




<pre><code>4.591836734693878</code></pre>
<h4 id="b-赋值运算符"><a href="#b-赋值运算符" class="headerlink" title="b, 赋值运算符:"></a>b, 赋值运算符:</h4><p>把 <code>=</code> 号<em>右边的数据</em> 赋给 <em>左边的变量</em></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = <span class="string">&#x27;a&#x27;</span></span><br><span class="line">b = <span class="string">&#x27;b&#x27;</span></span><br><span class="line">a + b</span><br></pre></td></tr></table></figure>




<pre><code>&#39;ab&#39;</code></pre>
<p>复合赋值运算符: </p>
<p><code>+=</code> , <code>-=</code> , <code>*=</code> , <code>/=</code> , <code>%=</code> , <code>**=</code> , <code>//=</code> , 例如 <code>a += b</code> 等价于 <code>a = a + b</code> , 以此类推.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = <span class="number">2</span></span><br><span class="line">b = <span class="number">3</span></span><br><span class="line">a = a**b</span><br><span class="line">a</span><br></pre></td></tr></table></figure>




<pre><code>8</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = <span class="number">2</span></span><br><span class="line">b = <span class="number">3</span></span><br><span class="line">a **= b</span><br><span class="line">a</span><br></pre></td></tr></table></figure>




<pre><code>8</code></pre>
<h4 id="c-比较运算符"><a href="#c-比较运算符" class="headerlink" title="c, 比较运算符"></a>c, 比较运算符</h4><p><code>&gt;</code>, <code>&gt;=</code>, <code>&lt;</code>, <code>&lt;=</code>, <code>==</code>, <code>!=</code>, 比较结果正确即是 True, 错误为 False</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> &gt; <span class="number">3</span></span><br></pre></td></tr></table></figure>




<pre><code>False</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> &lt;= <span class="number">3</span></span><br></pre></td></tr></table></figure>




<pre><code>True</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = <span class="number">1</span></span><br><span class="line"><span class="string">&#x27;1&#x27;</span> == <span class="built_in">str</span>(a)</span><br></pre></td></tr></table></figure>




<pre><code>True</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="literal">False</span> == <span class="number">0</span></span><br></pre></td></tr></table></figure>




<pre><code>True</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[] == <span class="number">0</span></span><br></pre></td></tr></table></figure>




<pre><code>False</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">bool</span>([]) == <span class="number">0</span></span><br></pre></td></tr></table></figure>




<pre><code>True</code></pre>
<h4 id="d-逻辑运算符"><a href="#d-逻辑运算符" class="headerlink" title="d, 逻辑运算符:"></a>d, 逻辑运算符:</h4><p><code>and</code> 左右两侧同时为 True 则结果为 True, <code>or</code> 左右两侧一个为 True, 结果为 True, <code>not</code> 对结果取反. 优先级 <code>not</code>&gt;<code>and</code>&gt;<code>or</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">bool</span>(<span class="string">&#x27;&#x27;</span>) == <span class="number">0</span> <span class="keyword">or</span> <span class="keyword">not</span> <span class="number">0</span> <span class="keyword">and</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>




<pre><code>True</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">not</span> <span class="number">0</span> <span class="keyword">and</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>




<pre><code>False</code></pre>
<h4 id="e-归属运算符"><a href="#e-归属运算符" class="headerlink" title="e, 归属运算符"></a>e, 归属运算符</h4><p><code>in</code>, 判断一个对象是否归属另一个对象, 是则为 True, 反之 False, <code>not in</code>结果取反</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;a&#x27;</span> <span class="keyword">in</span> <span class="string">&#x27;abc&#x27;</span></span><br></pre></td></tr></table></figure>




<pre><code>True</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;ac&#x27;</span> <span class="keyword">in</span> <span class="string">&#x27;abc&#x27;</span></span><br></pre></td></tr></table></figure>




<pre><code>False</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;a&#x27;</span> <span class="keyword">and</span> <span class="string">&#x27;c&#x27;</span> <span class="keyword">in</span> <span class="string">&#x27;abc&#x27;</span></span><br></pre></td></tr></table></figure>




<pre><code>True</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;a&#x27;</span> <span class="keyword">and</span> <span class="string">&#x27;c&#x27;</span> <span class="keyword">in</span> [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>]</span><br></pre></td></tr></table></figure>




<pre><code>True</code></pre>
<h4 id="f-身份运算符"><a href="#f-身份运算符" class="headerlink" title="f, 身份运算符"></a>f, 身份运算符</h4><p><code>is</code>, 判断两个对象是否为同一个对象(内存地址), <code>is not</code> 反之. <code>==</code> 和 <code>!=</code> 只判断值相等还是不相等</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = <span class="number">1</span></span><br><span class="line">b = <span class="number">1</span></span><br><span class="line">a <span class="keyword">is</span> b</span><br></pre></td></tr></table></figure>




<pre><code>True</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = <span class="string">&#x27;abc&#x27;</span></span><br><span class="line">b = a[:]</span><br><span class="line">a <span class="keyword">is</span> b</span><br></pre></td></tr></table></figure>




<pre><code>True</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">b = a[:]</span><br><span class="line">a <span class="keyword">is</span> b</span><br></pre></td></tr></table></figure>




<pre><code>False</code></pre>
<h3 id="3-输入-input-和-输出-print-函数"><a href="#3-输入-input-和-输出-print-函数" class="headerlink" title="3, 输入(input) 和 输出(print) 函数"></a>3, 输入(input) 和 输出(print) 函数</h3><p>查看函数详情用 <code>函数?</code>, <code>函数??</code> 或 <code>help(函数)</code></p>
<p><code>input()</code>函数, 接受用户的输入, 通常将输入赋值给一个变量</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">print?</span><br></pre></td></tr></table></figure>



<pre><code>print(value, ..., sep=&#39; &#39;, end=&#39;\n&#39;, file=sys.stdout, flush=False)

Prints the values to a stream, or to sys.stdout by default.
Optional keyword arguments:
file:  a file-like object (stream); defaults to the current sys.stdout.
sep:   string inserted between values, default a space.
end:   string appended after the last value, default a newline.
flush: whether to forcibly flush the stream.
      builtin_function_or_method</code></pre>
<p><code>print()</code> 函数将结果打印(或输出), 常用参数解释:</p>
<p>参数 <code>value</code> 要打印的值</p>
<p>参数 <code>sep=&#39; &#39;</code> 每个值之间的分隔符, 默认是空格</p>
<p>参数 <code>end=&#39;\n&#39;</code> 打印结束后的分隔符, 默认是换行</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">name = <span class="built_in">input</span>(<span class="string">&#x27;请输入姓名:&#x27;</span>)</span><br><span class="line">print(<span class="string">&#x27;你叫:&#x27;</span>, name)</span><br></pre></td></tr></table></figure>

<pre><code>请输入姓名: 吴明文


你叫: 吴明文</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">print(<span class="string">&#x27;我&#x27;</span>, <span class="string">&#x27;叫&#x27;</span>, <span class="string">&#x27;吴明文&#x27;</span>, sep=<span class="string">&#x27;-&#x27;</span>, end=<span class="string">&#x27;***&#x27;</span>)</span><br></pre></td></tr></table></figure>

<pre><code>我-叫-吴明文***</code></pre>
<p><strong>格式化输出</strong>:</p>
<p>a, 第一种方式: 常用格式化符号, <code>%s</code> 输出字符串, <code>%d</code> 输出整型数, <code>%f</code> 输出浮点数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">num = <span class="number">40</span></span><br><span class="line">str_1 = <span class="string">&#x27;考了&#x27;</span></span><br><span class="line">print(<span class="string">&#x27;我%s%.2f分&#x27;</span> % (str_1, num*<span class="number">2</span>))</span><br></pre></td></tr></table></figure>

<pre><code>我考了80.00分</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">num = <span class="number">40</span></span><br><span class="line">print(<span class="string">&#x27;我考了 %s 分&#x27;</span> % (num*<span class="number">2</span>))</span><br></pre></td></tr></table></figure>

<pre><code>我考了 80 分</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">num = <span class="string">&#x27;40&#x27;</span></span><br><span class="line">print(<span class="string">&#x27;我考了 %s 分&#x27;</span> % (num*<span class="number">2</span>))</span><br></pre></td></tr></table></figure>

<pre><code>我考了 4040 分</code></pre>
<p>b, 第二种方式: format() 方法</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">print(<span class="string">&#x27;我考了&#123;&#125;分&#x27;</span>.<span class="built_in">format</span>(<span class="number">80</span>))</span><br></pre></td></tr></table></figure>

<pre><code>我考了80分</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">num = <span class="number">40</span></span><br><span class="line">print(<span class="string">&#x27;我&#123;&#125;&#123;&#125;分&#x27;</span>.<span class="built_in">format</span>(<span class="string">&#x27;考了&#x27;</span>, num*<span class="number">2</span>))</span><br></pre></td></tr></table></figure>

<pre><code>我考了80分</code></pre>
<p>c, 第三种方法: f’{}’</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">num = <span class="number">40</span></span><br><span class="line">str_1 = <span class="string">&#x27;考了&#x27;</span></span><br><span class="line">print(<span class="string">f&#x27;我<span class="subst">&#123;str_1&#125;</span><span class="subst">&#123;num*<span class="number">2</span>&#125;</span>分&#x27;</span>)</span><br></pre></td></tr></table></figure>

<pre><code>我考了80分</code></pre>
<h3 id="4-变量和关键字"><a href="#4-变量和关键字" class="headerlink" title="4, 变量和关键字"></a>4, 变量和关键字</h3><h4 id="1-变量"><a href="#1-变量" class="headerlink" title="1, 变量"></a>1, 变量</h4><p>可将变量定义为: 储存数据对象的容器</p>
<p>定义变量的格式: <code>变量名 = 数据对象</code>, 变量名尽量见名知意, 可读性高. 变量必须定义才能使用.</p>
<p>命名规则: 只能由字母, 数字, 下划线组成, 大小写敏感, 且不能以数字开头, 不能与 python 关键字, 函数方法名等重复. 驼峰命名法: <code>myName</code>, 下划线命名法: <code>my_name</code>(推荐).</p>
<h4 id="2-关键字"><a href="#2-关键字" class="headerlink" title="2, 关键字"></a>2, 关键字</h4><p>python 里面具有特殊功能的标识符, 查看所有关键字:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">help</span>(<span class="string">&#x27;keywords&#x27;</span>)</span><br></pre></td></tr></table></figure>


<pre><code>Here is a list of the Python keywords.  Enter any keyword to get more help.

False               class               from                or
None                continue            global              pass
True                def                 if                  raise
and                 del                 import              return
as                  elif                in                  try
assert              else                is                  while
async               except              lambda              with
await               finally             nonlocal            yield
break               for                 not                 </code></pre>
<p>查看所有内置函数和内置常量名:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">dir</span>(__builtin__)</span><br></pre></td></tr></table></figure>
<p>部分如下:<br>     ‘abs’,<br>     ‘all’,<br>     ‘any’,<br>     ‘ascii’,<br>     ‘bin’,<br>     ‘bool’,<br>     ‘breakpoint’,<br>     ‘bytearray’,<br>     ‘bytes’,<br>     ‘callable’,<br>     ‘chr’,<br>     ‘classmethod’,<br>     ‘compile’,<br>     ‘complex’,<br>     ‘copyright’,<br>     ‘credits’,<br>     ‘delattr’,<br>     ‘dict’,<br>     ‘dir’,<br>     ‘display’,<br>     ‘divmod’,<br>     ‘enumerate’,<br>     ‘eval’,<br>     ‘exec’,<br>     ‘filter’,<br>     ‘float’,<br>     ‘format’,<br>     ‘frozenset’,<br>     ‘get_ipython’,<br>     ‘getattr’,<br>     ‘globals’,<br>     ‘hasattr’,<br>     ‘hash’,<br>     ‘help’,<br>     ‘hex’,<br>     ‘id’,<br>     ‘input’,<br>     ‘int’,<br>     ‘isinstance’,<br>     ‘issubclass’,<br>     ‘iter’,<br>     ‘len’,<br>     ‘license’,<br>     ‘list’,<br>     ‘locals’,<br>     ‘map’,<br>     ‘max’,<br>     ‘memoryview’,<br>     ‘min’,<br>     ‘next’,<br>     ‘object’,<br>     ‘oct’,<br>     ‘open’,<br>     ‘ord’,<br>     ‘pow’,<br>     ‘print’,<br>     ‘property’,<br>     ‘range’,<br>     ‘repr’,<br>     ‘reversed’,<br>     ‘round’,<br>     ‘set’,<br>     ‘setattr’,<br>     ‘slice’,<br>     ‘sorted’,<br>     ‘staticmethod’,<br>     ‘str’,<br>     ‘sum’,<br>     ‘super’,<br>     ‘tuple’,<br>     ‘type’,<br>     ‘vars’,<br>     ‘zip’</p>
<h3 id="5-条件判断和循环"><a href="#5-条件判断和循环" class="headerlink" title="5, 条件判断和循环"></a>5, 条件判断和循环</h3><h4 id="5-1-if-条件判断"><a href="#5-1-if-条件判断" class="headerlink" title="5.1, if 条件判断"></a>5.1, if 条件判断</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> 判断条件<span class="number">1</span>:</span><br><span class="line">    执行语句<span class="number">1.</span>..</span><br><span class="line"><span class="keyword">elif</span> 判断条件<span class="number">2</span>:</span><br><span class="line">    执行语句<span class="number">2.</span>..</span><br><span class="line"><span class="keyword">elif</span> 判断条件<span class="number">3</span>:</span><br><span class="line">    执行语句<span class="number">3.</span>..</span><br><span class="line">...</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    执行语句n...</span><br></pre></td></tr></table></figure>

<p>从上往下判断, 如果某个判断为 True, 就执行该判断下面的执行语句, 忽略后面代码 </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">age = <span class="number">30</span></span><br><span class="line"><span class="keyword">if</span> age &gt;= <span class="number">70</span>:</span><br><span class="line">    print(<span class="string">&#x27;从心所欲, 不逾矩&#x27;</span>)</span><br><span class="line"><span class="keyword">elif</span> age &gt;= <span class="number">60</span>:</span><br><span class="line">    print(<span class="string">&#x27;耳顺&#x27;</span>)</span><br><span class="line"><span class="keyword">elif</span> age &gt;= <span class="number">50</span>:</span><br><span class="line">    print(<span class="string">&#x27;知天命&#x27;</span>)</span><br><span class="line"><span class="keyword">elif</span> age &gt;= <span class="number">40</span>:</span><br><span class="line">    print(<span class="string">&#x27;不惑&#x27;</span>)</span><br><span class="line"><span class="keyword">elif</span> age &gt;= <span class="number">30</span>:</span><br><span class="line">    print(<span class="string">&#x27;而立&#x27;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    print(<span class="string">&#x27;志于学&#x27;</span>)</span><br></pre></td></tr></table></figure>

<pre><code>而立</code></pre>
<h4 id="5-2-循环"><a href="#5-2-循环" class="headerlink" title="5.2, 循环"></a>5.2, 循环</h4><p>a, <code>while</code> 循环</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">while 判断条件(condition)：</span><br><span class="line">    执行语句(statements)……</span><br></pre></td></tr></table></figure>
<p>只要判断条件为 <code>True</code>, 循环就继续, 一定要设置退出条件, 否则进入无限死循环</p>
<p>b, <code>for</code> 循环</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for iterating_var in sequence:</span><br><span class="line">    statements(s)</span><br></pre></td></tr></table></figure>
<p>遍历序列, 将序列中的所有元素访问一遍, 循环结束</p>
<p>c, <code>break</code> : 在循环中, 如果执行到 break 语句, 退出整个循环</p>
<p>d, <code>continue</code> : 在循环中, 执行到 continue 语句, 跳过这次循环, 开始下一次循环, 循环未必结束</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">age = <span class="number">100</span></span><br><span class="line"><span class="keyword">while</span> <span class="number">1</span>:    <span class="comment"># 判断为正确, 非0 或 非空 即是 True</span></span><br><span class="line">    age -= <span class="number">10</span></span><br><span class="line">    <span class="keyword">if</span> age &gt;= <span class="number">50</span>:</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">        print(<span class="string">&#x27;知天命&#x27;</span>)</span><br><span class="line">    <span class="keyword">elif</span> age &gt;= <span class="number">40</span>:</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">        print(<span class="string">&#x27;不惑&#x27;</span>)</span><br><span class="line">    <span class="keyword">elif</span> age &gt;= <span class="number">30</span>:</span><br><span class="line">        print(<span class="string">&#x27;而立&#x27;</span>)</span><br><span class="line">        <span class="keyword">break</span></span><br></pre></td></tr></table></figure>

<pre><code>而立</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> age <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">100</span>, <span class="number">0</span>, <span class="number">-10</span>):</span><br><span class="line">    age -= <span class="number">10</span></span><br><span class="line">    <span class="keyword">if</span> age &gt;= <span class="number">50</span>:</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">        print(<span class="string">&#x27;知天命&#x27;</span>)</span><br><span class="line">    <span class="keyword">elif</span> age &gt;= <span class="number">40</span>:</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">        print(<span class="string">&#x27;不惑&#x27;</span>)</span><br><span class="line">    <span class="keyword">elif</span> age &gt;= <span class="number">30</span>:</span><br><span class="line">        print(<span class="string">&#x27;而立&#x27;</span>)</span><br><span class="line">        <span class="keyword">break</span></span><br></pre></td></tr></table></figure>

<pre><code>而立</code></pre>
<p>e, 循环还可与 else 连用, 当循环执行完成, 接着执行 else, 若因 break 跳出循环, esle 不执行</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">age = <span class="number">100</span></span><br><span class="line"><span class="keyword">while</span> age &gt; <span class="number">10</span>:    </span><br><span class="line">    age -= <span class="number">10</span></span><br><span class="line">    <span class="keyword">if</span> age &gt;= <span class="number">50</span>:</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">        print(<span class="string">&#x27;知天命&#x27;</span>)</span><br><span class="line">    <span class="keyword">elif</span> age &gt;= <span class="number">40</span>:</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">        print(<span class="string">&#x27;不惑&#x27;</span>)</span><br><span class="line">    <span class="keyword">elif</span> age &gt;= <span class="number">30</span>:</span><br><span class="line">        print(<span class="string">&#x27;而立&#x27;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    print(<span class="string">&#x27;志于学&#x27;</span>)</span><br></pre></td></tr></table></figure>

<pre><code>而立
志于学</code></pre>
<h3 id="6-python-代码结构的其他要件"><a href="#6-python-代码结构的其他要件" class="headerlink" title="6, python 代码结构的其他要件"></a>6, python 代码结构的其他要件</h3><p>python 代码通过<code>运算符</code>, <code>条件判断和循环</code>, <code>缩进</code>, <code>函数</code>, <code>模块</code>, <code>计算包</code>等, 按照需要解决的问题的需求, 设计和控制计算流程, 将输入的各种数据类型的数据对象组织到一起处理, 计算, 最终输出结果</p>
<h4 id="a-注释"><a href="#a-注释" class="headerlink" title="a, 注释:"></a>a, 注释:</h4><p>对代码的解释说明, 提高代码可读性</p>
<p>单行注释, 以 <code>#</code> 开头, 多行注释, 以三个单引号 <code>&#39;&#39;&#39; &#39;&#39;&#39;</code> 或三个双引号 <code>&quot;&quot;&quot; &quot;&quot;&quot;</code>包裹, 通常用作文档注释</p>
<h4 id="b-缩进"><a href="#b-缩进" class="headerlink" title="b, 缩进:"></a>b, 缩进:</h4><p>Python 对代码的缩进要求非常严格, 同一个级别代码块的缩进量必须一样, 因为Python 采用代码缩进和冒号 <code>:</code> 来区分代码块之间的层次, 行尾的冒号和下一行的缩进, 表示下一个代码块的开始, 而缩进的结束则表示此代码块的结束</p>
<p>Python 中实现对代码的缩进，可以使用空格(推荐)或者 Tab 键实现, 通常情况下都是采用 4 个空格长度作为一个缩进量, 默认一个 Tab 键表示 4 个空格</p>
<p>例如, 输出 1000 以内的斐波那契数列:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">这是一段计算 1000 以内</span></span><br><span class="line"><span class="string">斐波那契数列的代码</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="comment"># 定义变量 a 和 b 初始值分别为 0 和 1</span></span><br><span class="line">a, b = <span class="number">0</span>, <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 限制循环范围 1000 以内</span></span><br><span class="line"><span class="keyword">while</span> a &lt; <span class="number">1000</span>:</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 输出结果</span></span><br><span class="line">    print(a, end=<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 设置循环条件: b 赋值给 a, a + b 赋值给 b</span></span><br><span class="line">    a, b = b, a + b</span><br></pre></td></tr></table></figure>

<pre><code>0 1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987 </code></pre>
]]></content>
      <categories>
        <category>数据分析</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>函数和面向对象</title>
    <url>/data/python3-2dee073565c6/</url>
    <content><![CDATA[<blockquote>
<p>整理更偏重数据分析方向的 python 基础知识, 快速入门. python 应用领域广泛, 在科学计算, 统计, 人工智能等领域有巨大优势, 学好 python 基础对入门数据分析来说, 是基石</p>
</blockquote>
<p><a href="https://docs.python.org/zh-cn/3.8/">python官方文档</a></p>
<p><font color=#00A600 >2020年6月19日更新</font></p>
<h2 id="三-python-函数"><a href="#三-python-函数" class="headerlink" title="三, python 函数"></a>三, python 函数</h2><p>把具有独立功能的代码块以一定的方式组织到一起, 就构成一个函数</p>
<p>函数大致可以分为<strong>内建函数</strong>, <strong>方法</strong>(类里面的功能代码块), <strong>匿名函数</strong>和<strong>自定义函数</strong></p>
<p>函数的调用: <code>函数名(传递参数)</code>.  每次调用, 函数都会从头开始执行, 直到代码执行完毕或遇到 <code>return</code> 语句, 调用结束</p>
<p>函数和方法没有本质区别, 为了方便理解, 我们将可以直接调用的叫做函数, 需要实例或对象才能调用的函数叫做方法, 例如 <code>list()</code> 函数, <code>sort()</code>方法:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">list</span>(<span class="string">&#x27;6315&#x27;</span>)</span><br></pre></td></tr></table></figure>




<pre><code>[&#39;6&#39;, &#39;3&#39;, &#39;1&#39;, &#39;5&#39;]</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = [<span class="string">&#x27;6&#x27;</span>, <span class="string">&#x27;3&#x27;</span>, <span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;5&#x27;</span>]</span><br><span class="line">a.sort()</span><br><span class="line">a</span><br></pre></td></tr></table></figure>




<pre><code>[&#39;1&#39;, &#39;3&#39;, &#39;5&#39;, &#39;6&#39;]</code></pre>
<h3 id="1-函数的自定义"><a href="#1-函数的自定义" class="headerlink" title="1, 函数的自定义"></a>1, 函数的自定义</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> 函数名(<span class="params">参数</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    函数的文档说明</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    执行代码...</span><br></pre></td></tr></table></figure>

<p>例如, 定义一个加法计算器函数:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add_num</span>():</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    这是一个用来计算数字相加的函数</span></span><br><span class="line"><span class="string">    请以 num + num + ... 形式输入</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    nums_list = <span class="built_in">input</span>(<span class="string">&#x27;请输入数字以 `+` 号隔开: &#x27;</span>).split(<span class="string">&#x27;+&#x27;</span>)</span><br><span class="line">    j = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> nums_list:</span><br><span class="line">        j += <span class="built_in">int</span>(i)</span><br><span class="line">    print(j)</span><br><span class="line">    </span><br><span class="line">add_num()</span><br></pre></td></tr></table></figure>

<pre><code>请输入数字以 `+` 号隔开:  456+ 5459 + 46697


52612</code></pre>
<p>自定义函数时, 函数名的命名规则和变量类似<br>函数的参数是可选项, 根据需要设定, 函数的参数可以是函数<br>函数的文档说明, 对函数进行介绍和解释说明的文档字符串, 可以使用 <code>help()</code>函数, <code>__doc__</code> 属性,  <code>?</code> 或 <code>??</code> 查看</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">help</span>(add_num)</span><br></pre></td></tr></table></figure>

<pre><code>Help on function add_num in module __main__:

add_num()
    这是一个用来计算数字相加的函数
    请以 num + num + ... 形式输入</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">add_num.__doc__</span><br></pre></td></tr></table></figure>




<pre><code>&#39;\n    这是一个用来计算数字相加的函数\n    请以 num + num + ... 形式输入\n    &#39;</code></pre>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">add_num?</span><br></pre></td></tr></table></figure>


<pre><code>Signature: add_num()
Docstring:
这是一个用来计算数字相加的函数
请以 num + num + ... 形式输入
File:      f:\z_myfile\bigdata\学习总结\&lt;ipython-input-43-778f3089bd9f&gt;
Type:      function</code></pre>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">add_num??</span><br></pre></td></tr></table></figure>


<pre><code>Signature: add_num()
Source:   
def add_num():
    &quot;&quot;&quot;
    这是一个用来计算数字相加的函数
    请以 num + num + ... 形式输入
    &quot;&quot;&quot;
    nums_list = input(&#39;请输入数字以 `+` 号隔开: &#39;).split(&#39;+&#39;)
    j = 0
    for i in nums_list:
        j += int(i)
    print(j)
File:      f:\z_myfile\bigdata\学习总结\&lt;ipython-input-43-778f3089bd9f&gt;
Type:      function</code></pre>
<p>注意点:<br>函数内部定义的变量, 是局部变量, 只能在函数内部访问, 在函数外定义的变量是全局变量, 函数内外均可访问, 但是不建议在函数内部直接访问全局变量, 因为这给理解函数带来困难, 不知变量来源何处.<br>函数内部访问时, 用 <code>global</code> 语句声明是全局变量, 并且只有声明之后才可以在函数内给全局变量赋值</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = <span class="number">2</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f1</span>():</span></span><br><span class="line">    a = <span class="number">1</span></span><br><span class="line">    print(a)</span><br><span class="line">f1()</span><br><span class="line">print(a)</span><br></pre></td></tr></table></figure>

<pre><code>1
2</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = <span class="number">2</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span>():</span></span><br><span class="line">    <span class="keyword">global</span> a</span><br><span class="line">    a += <span class="number">1</span></span><br><span class="line">    print(a)</span><br><span class="line">f()</span><br></pre></td></tr></table></figure>

<pre><code>3</code></pre>
<h3 id="2-函数的参数"><a href="#2-函数的参数" class="headerlink" title="2, 函数的参数"></a>2, 函数的参数</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span>(<span class="params">位置参数, 默认参数, 可变参数, 命名关键字参数, 关键字参数</span>):</span>  <span class="comment"># 形参</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line">f(实参)  <span class="comment"># 传参调用函数</span></span><br></pre></td></tr></table></figure>

<p>函数的参数分为形参和实参, 形参就像变量, 实参就像变量的值, 实参将值传递给形参就像将值赋给变量</p>
<p>形参不限数量, 按照函数需要设定, 实参按照需求传递, 但必须遵守传参规则</p>
<p>函数的形参按照顺序依次为:  </p>
<p><strong>位置参数:</strong> 必传参数, 且位置必须在首位, 按照位置依次传参</p>
<p><strong>默认参数:</strong> 参数有默认值, 不传参数函数将使用默认值做实参</p>
<p><strong>可变参数:</strong> 可以传递任意个数的实参, 传入函数后以元组形式封装</p>
<p><strong>命名关键字参数:</strong> 可变参数或 <code>*</code> 号后面的参数, 传参必须用函数定义时已经命名的关键字传参</p>
<p><strong>关键字参数:</strong> 传参必须使用关键字(自定义)传参, 传入函数后以字典封装</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span>(<span class="params">a, b=<span class="string">&#x27;b&#x27;</span>, *args, c=<span class="string">&#x27;c&#x27;</span>, **kwargs</span>):</span></span><br><span class="line">    print(a, b, args, c, kwargs)</span><br><span class="line">f(<span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<pre><code>1 b () c &#123;&#125;</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">f(<span class="number">1</span>, d=<span class="number">2</span>)</span><br></pre></td></tr></table></figure>

<pre><code>1 b () c &#123;&#39;d&#39;: 2&#125;</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">f(<span class="number">1</span>, <span class="number">2</span>)</span><br></pre></td></tr></table></figure>

<pre><code>1 2 () c &#123;&#125;</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">f(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br></pre></td></tr></table></figure>

<pre><code>1 2 (3,) c &#123;&#125;</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">f(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br></pre></td></tr></table></figure>

<pre><code>1 2 (3, 4) c &#123;&#125;</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">f(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, c=<span class="number">5</span>)</span><br></pre></td></tr></table></figure>

<pre><code>1 2 (3, 4) 5 &#123;&#125;</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">f(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, c=<span class="number">5</span>, d=<span class="number">6</span>)</span><br></pre></td></tr></table></figure>

<pre><code>1 2 (3,) 5 &#123;&#39;d&#39;: 6&#125;</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">f(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, d=<span class="number">6</span>)</span><br></pre></td></tr></table></figure>

<pre><code>1 2 (3,) c &#123;&#39;d&#39;: 6&#125;</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">args = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line">kwargs = &#123;<span class="string">&#x27;c&#x27;</span>: <span class="number">5</span>, <span class="string">&#x27;d&#x27;</span>: <span class="number">6</span>&#125;</span><br><span class="line">f(*args, **kwargs)  <span class="comment"># * 和 ** 拆包传参</span></span><br></pre></td></tr></table></figure>

<pre><code>1 2 (3, 4) 5 &#123;&#39;d&#39;: 6&#125;</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f1</span>(<span class="params">a, b=<span class="string">&#x27;b&#x27;</span>, *, c, **kwargs</span>):</span></span><br><span class="line">    print(a, b, c, kwargs)</span><br><span class="line">f1(<span class="number">1</span>, c=<span class="number">5</span>, d=<span class="number">6</span>)</span><br></pre></td></tr></table></figure>

<pre><code>1 b 5 &#123;&#39;d&#39;: 6&#125;</code></pre>
<p>注意点:<br>默认参数必须指向不变对象</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add_</span>(<span class="params">l=[]</span>):</span></span><br><span class="line">    l.append(<span class="number">0</span>)</span><br><span class="line">    print(l)</span><br><span class="line">    </span><br><span class="line">add_()</span><br><span class="line">add_()</span><br></pre></td></tr></table></figure>

<pre><code>[0]
[0, 0]</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add_</span>(<span class="params">l=<span class="literal">None</span></span>):</span></span><br><span class="line">    <span class="keyword">if</span> l <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        l = []</span><br><span class="line">    l.append(<span class="number">0</span>)</span><br><span class="line">    print(l)</span><br><span class="line">    </span><br><span class="line">add_()</span><br><span class="line">add_()</span><br></pre></td></tr></table></figure>

<pre><code>[0]
[0]</code></pre>
<h3 id="3-函数的返回值-拆包和递归函数"><a href="#3-函数的返回值-拆包和递归函数" class="headerlink" title="3, 函数的返回值, 拆包和递归函数"></a>3, 函数的返回值, 拆包和递归函数</h3><p>调用函数后, 执行到 <code>return</code> 语句函数执行结束, <code>return</code> 返回的结果, 叫返回值, 返回多个值用 <code>,</code> 号隔开, 最后结果由元组封装</p>
<p>无返回值的函数默认返回 <code>None</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span>(<span class="params">a</span>):</span></span><br><span class="line">    <span class="keyword">return</span> a*<span class="number">2</span>, a**<span class="number">2</span></span><br><span class="line"></span><br><span class="line">print(f(<span class="number">8</span>))</span><br></pre></td></tr></table></figure>

<pre><code>(16, 64)</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span>(<span class="params">a</span>):</span></span><br><span class="line">    b = a*<span class="number">2</span></span><br><span class="line">    c = a**<span class="number">2</span></span><br><span class="line">    print(b, c)</span><br><span class="line">print(f(<span class="number">8</span>))</span><br></pre></td></tr></table></figure>

<pre><code>16 64
None</code></pre>
<p>有时候函数返回多个值, 而我们只需要其中的某个(些), 我们就可以对返回结果进行拆包, 例如返回姓(单姓)和名, 我们只需要姓:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">r_name</span>():</span></span><br><span class="line">    name = <span class="built_in">input</span>(<span class="string">&#x27;请输入姓名: &#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> name[<span class="number">0</span>], name[<span class="number">1</span>:]</span><br><span class="line"></span><br><span class="line">surname, _ = r_name()</span><br><span class="line">surname</span><br></pre></td></tr></table></figure>

<pre><code>请输入姓名:  吴明文

&#39;吴&#39;</code></pre>
<p>函数内部调用自身, 这个函数就是<strong>递归函数</strong></p>
<p>函数调用增加一层栈帧, 返回减少一层, 栈的大小有限, 递归次数过多, 会导致栈溢出报错</p>
<p>尾递归优化: 函数返回时, 调用自身且 <code>return</code> 语句不能包含表达式. 如果解释器针对尾递归做了优化(python解释器未优化), 可以用尾递归解决栈溢出问题</p>
<p>例, 计算 n 的阶乘:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">factorial</span>(<span class="params">n</span>):</span></span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> n * factorial(n - <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">factorial(<span class="number">10</span>)</span><br></pre></td></tr></table></figure>




<pre><code>3628800</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 尾递归优化</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">factorial</span>(<span class="params">n</span>):</span></span><br><span class="line">    <span class="keyword">return</span> fact_iter(n, <span class="number">1</span>)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fact_iter</span>(<span class="params">num, product</span>):</span></span><br><span class="line">    <span class="keyword">if</span> num == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> product</span><br><span class="line">    <span class="keyword">return</span> fact_iter(num - <span class="number">1</span>, num * product)</span><br><span class="line"></span><br><span class="line">factorial(<span class="number">10</span>)</span><br></pre></td></tr></table></figure>




<pre><code>3628800</code></pre>
<h3 id="4-匿名函数"><a href="#4-匿名函数" class="headerlink" title="4, 匿名函数"></a>4, 匿名函数</h3><p>在函数无需重复调用, 只是一次性使用时, 使用匿名函数让代码更加简洁</p>
<p>匿名函数的语法:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">lambda</span> 参数(可选可多个): 返回的表达式</span><br></pre></td></tr></table></figure>


<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 排序</span></span><br><span class="line">a = [&#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;小王&#x27;</span>, <span class="string">&#x27;age&#x27;</span>: <span class="number">20</span>&#125;, &#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;小张&#x27;</span>, <span class="string">&#x27;age&#x27;</span>: <span class="number">14</span>&#125;,</span><br><span class="line">     &#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;小李&#x27;</span>, <span class="string">&#x27;age&#x27;</span>: <span class="number">23</span>&#125;]</span><br><span class="line">a.sort(key=<span class="keyword">lambda</span> x: x[<span class="string">&#x27;age&#x27;</span>])</span><br><span class="line">a</span><br></pre></td></tr></table></figure>




<pre><code>[&#123;&#39;name&#39;: &#39;小张&#39;, &#39;age&#39;: 14&#125;,
 &#123;&#39;name&#39;: &#39;小王&#39;, &#39;age&#39;: 20&#125;,
 &#123;&#39;name&#39;: &#39;小李&#39;, &#39;age&#39;: 23&#125;]</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 高阶函数应用</span></span><br><span class="line">a = [<span class="string">&#x27;2&#x27;</span>, <span class="string">&#x27;4&#x27;</span>, <span class="string">&#x27;7&#x27;</span>, <span class="string">&#x27;3&#x27;</span>, <span class="string">&#x27;11&#x27;</span>]</span><br><span class="line">b = <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="keyword">lambda</span> x: <span class="built_in">int</span>(x)**<span class="number">2</span>, a))</span><br><span class="line">b</span><br></pre></td></tr></table></figure>




<pre><code>[4, 16, 49, 9, 121]</code></pre>
<br>

<h2 id="四-python-面向对象"><a href="#四-python-面向对象" class="headerlink" title="四, python 面向对象"></a>四, python 面向对象</h2><h3 id="1-面向对象编程基本概念"><a href="#1-面向对象编程基本概念" class="headerlink" title="1, 面向对象编程基本概念"></a>1, 面向对象编程基本概念</h3><p>面向对象编程(OOP): 把对象作为程序的基本单元进行程序设计, python 的对象可以是任何数据类型的数据或处理数据的函数</p>
<p>类: 一类事或物抽象为一个类</p>
<p>类的对象: 具体到某个事或物</p>
<p>类的实例: 明确的, 实例化的对象</p>
<p>类的属性: 类中的一个数据特性</p>
<p>类的方法: 类中处理数据的函数</p>
<p>做个类比: 车, 是一个类, 一辆车, 是一个对象, 一辆宝马, 就是一个实例, 车的发动机, 底盘, 车身, 电气设备等各种硬件参数, 就是属性, 将各种硬件组织到一起组成的点火系统, 传动系统, 制动系统等就是方法</p>
<h3 id="2-定义类和创建对象"><a href="#2-定义类和创建对象" class="headerlink" title="2, 定义类和创建对象"></a>2, 定义类和创建对象</h3><p>定义一个类用 <code>class 类名(object):</code> 语句, 类名首字母一般大写, object 是所有类的最顶级父类, 可以省略不写</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Explain</span>():</span></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    这是类的文档说明</span></span><br><span class="line"><span class="string">    这是一个对类进行解释说明的类</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    a = <span class="string">&#x27;类属性a&#x27;</span></span><br><span class="line">    __b = <span class="string">&#x27;私有类属性b&#x27;</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, e</span>):</span>  <span class="comment"># e 是创建实例对象时需要传递的参数</span></span><br><span class="line">        self.c = <span class="string">&#x27;实例属性c&#x27;</span></span><br><span class="line">        self.__d = <span class="string">&#x27;私有实例属性d&#x27;</span></span><br><span class="line">        self.e = e <span class="comment"># 实例属性 e, 属性值是传入的参数</span></span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">method1</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&#x27;输出私有类/实例属性:&#x27;</span>, Explain.__b, self.__d)</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__method2</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&#x27;私有实例方法&#x27;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">method3</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&#x27;调用类方法, 静态方法和私有实例方法:&#x27;</span>)</span><br><span class="line">        self.method4()</span><br><span class="line">        self.method5()</span><br><span class="line">        self.__method2()</span><br><span class="line">           </span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">method4</span>(<span class="params">cls</span>):</span></span><br><span class="line">        print(<span class="string">&#x27;输出私有类属性b:&#x27;</span>, cls.__b)</span><br><span class="line">        print(<span class="string">&#x27;调用静态方法:&#x27;</span>)</span><br><span class="line">        cls.method5()</span><br><span class="line">        </span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">method5</span>():</span></span><br><span class="line">        print(<span class="string">&#x27;静态方法输出类属性:&#x27;</span>, Explain.a)</span><br></pre></td></tr></table></figure>

<p><strong>创建属性和方法说明:</strong></p>
<p>类属性: 类中直接定义的变量, <code>属性名 = 数据</code></p>
<p>私有类属性: <code>__属性名 = 数据</code>, 不能在外部被访问, 但可以在内部调用</p>
<p><code>__init__(self, 形参):</code>:<br>两个下划线开始和结束的魔法方法, <code>__init__</code> 用来初始化类, 创建实例属性和设定类对象的形参<br>如果类里不写 <code>__init__</code> 方法, python会自动创建<br><code>self</code> 表示实例对象本身(约定写法, 名字可更换), 作为一个变量, 谁调用它他就是谁</p>
<p>实例属性: <code>self.属性名 = 数据</code></p>
<p>私有实例属性: <code>self.__属性名 = 数据</code>, 不能在外部被访问, 但可以在内部调用</p>
<p>实例方法: <code>def 方法名(self):</code></p>
<p>私有实例方法: <code>def __方法名(self):</code>, 不能在外部被访问, 但可以在内部调用</p>
<p>类方法: <code>@classmethod</code> 修饰 <code>def 方法名(cls):</code></p>
<p>静态方法: <code>@staticmethod</code> 修饰 <code>def 方法名():</code></p>
<p>除了 <code>__init__</code> 方法, 其他方法都是自定义的函数</p>
<h3 id="3-创建对象-访问属性和方法"><a href="#3-创建对象-访问属性和方法" class="headerlink" title="3, 创建对象, 访问属性和方法"></a>3, 创建对象, 访问属性和方法</h3><p>创建实例对象: <code>对象名 = 类名(参数)</code>, 如果设有参数, 需要传参数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">ex = Explain(<span class="string">&#x27;参数&#x27;</span>)</span><br><span class="line">ex</span><br></pre></td></tr></table></figure>




<pre><code>&lt;__main__.Explain at 0x2476aaadba8&gt;</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">ex1 = Explain  <span class="comment"># 注意和上式的区别, 这是一个类对象</span></span><br><span class="line">ex1</span><br></pre></td></tr></table></figure>




<pre><code>__main__.Explain</code></pre>
<p>类对象和实例对象都可以访问类属性:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Explain.a, ex.a</span><br></pre></td></tr></table></figure>




<pre><code>(&#39;类属性a&#39;, &#39;类属性a&#39;)</code></pre>
<p>新建或修改类属性, 必须通过类对象去访问然后修改, 通过实例对象去访问, 不能修改, 而是创建了新实例属性, 再通过实例访问时, 就屏蔽了类属性. 新建或修改实例属性只能实例去访问</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Explain.c = <span class="string">&#x27;新类属性c&#x27;</span></span><br><span class="line">ex.a = <span class="string">&#x27;新实例属性a&#x27;</span></span><br><span class="line">Explain.a = <span class="string">&#x27;修改的类属性a&#x27;</span></span><br><span class="line">Explain.c, ex.a, Explain.a, ex.c</span><br></pre></td></tr></table></figure>




<pre><code>(&#39;新类属性c&#39;, &#39;新实例属性a&#39;, &#39;修改的类属性a&#39;, &#39;实例属性c&#39;)</code></pre>
<p>访问实例属性或实例方法只能实例去访问, 实例方法可以调用类属性和实例属性</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">ex.method1()</span><br><span class="line">ex.e</span><br></pre></td></tr></table></figure>

<pre><code>输出私有类/实例属性: 私有类属性b 私有实例属性d

&#39;参数&#39;</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Explain(<span class="string">&#x27;新参数&#x27;</span>).e  <span class="comment"># Explain(&#x27;新参数&#x27;) 已经是新实例</span></span><br></pre></td></tr></table></figure>




<pre><code>&#39;新参数&#39;</code></pre>
<p>实例方法可以调用类方法, 静态方法和实例方法</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">ex.method3()</span><br></pre></td></tr></table></figure>

<pre><code>调用类方法, 静态方法和私有实例方法:
输出私有类属性b: 私有类属性b
调用静态方法:
静态方法输出类属性: 类属性a
静态方法输出类属性: 类属性a
私有实例方法</code></pre>
<p>类方法和静态方法, 通过类对象和实例对象都可以访问, 类方法内可以调用类属性和静态方法, 静态方法内可以调用类属性(注意调用方式的不同)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Explain.method4()</span><br><span class="line">ex.method4()</span><br><span class="line">Explain.method5()</span><br><span class="line">ex.method5()</span><br></pre></td></tr></table></figure>

<pre><code>输出私有类属性b: 私有类属性b
调用静态方法:
静态方法输出类属性: 类属性a
输出私有类属性b: 私有类属性b
调用静态方法:
静态方法输出类属性: 类属性a
静态方法输出类属性: 类属性a
静态方法输出类属性: 类属性a</code></pre>
<h3 id="4-封装-继承和多态"><a href="#4-封装-继承和多态" class="headerlink" title="4, 封装, 继承和多态"></a>4, 封装, 继承和多态</h3><p>面向对象编程的三大特性: 封装, 继承和多态</p>
<p><strong>封装</strong>: </p>
<p>将数据和解决问题的实现代码放在一个对象内，通过对象或实例名来访问属性和方法, 隐藏功能的实现细节，也可以设置访问权限，不能修改对象的内部实现 </p>
<p>正是由于封装机制，程序在使用某一对象时不需要关心该对象的数据结构细节及实现操作的方法，使代码更易维护，也在一定程度上保证了系统安全性</p>
<p><strong>继承</strong>: </p>
<p>将一个类(父类)的属性和方法等全部’复制’给另一个类(子类)使用, 继承机制实现了代码的复用，多个类公用的代码, 可以封装在一个类中，而其他类只需要继承这个类即可, 定义子类时, 这样继承父类: <code>class 子类名(父类名):</code></p>
<p>继承的子类在获得了父类的全部属性和方法的同时，又可以根据需要, 在父类方法不能满足子类使用时在子类内部对父类方法进行重写 </p>
<p>一个类可以继承多个父类, 也继承了所有父类的属性和方法, 子类在调用某个属性或方法时，首先在自己内部查找，如果没有找到，则开始根据继承机制在父类里查找, 若是多个父类中有相同的属性或方法名, 按<strong>先后顺序和深度优先</strong>方式查找</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>():</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">show</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&#x27;A&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>(<span class="params">A</span>):</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span>():</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span>():</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">show</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&#x27;D&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">E</span>(<span class="params">C, B, D</span>):</span>  <span class="comment"># C -&gt; B -&gt; A -&gt; D</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">e = E()</span><br><span class="line">e.show()</span><br></pre></td></tr></table></figure>

<pre><code>A</code></pre>
<p><strong>多态</strong>:</p>
<p>不同的子类对象, 调用相同的父类方法, 得到不同的执行结果. python 没有多态, 又处处是假多态</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span>():</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&#x27;小动物在跑&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pig</span>(<span class="params">Animal</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span>(<span class="params">self</span>):</span> <span class="comment"># 重写父类方法</span></span><br><span class="line">        print(<span class="string">&#x27;小猪在跑&#x27;</span>)</span><br><span class="line">        </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span>(<span class="params">Animal</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span>(<span class="params">self</span>):</span> <span class="comment"># 重写父类方法</span></span><br><span class="line">        print(<span class="string">&#x27;小狗在跑&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run_</span>(<span class="params">a</span>):</span></span><br><span class="line">    a.run()</span><br><span class="line">    </span><br><span class="line">pig = Pig()</span><br><span class="line">dog = Dog()</span><br><span class="line"></span><br><span class="line">run_(pig)</span><br><span class="line">run_(dog)</span><br></pre></td></tr></table></figure>

<pre><code>小猪在跑
小狗在跑</code></pre>
]]></content>
      <categories>
        <category>数据分析</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>异常, 模块和包, 以及文件读写</title>
    <url>/data/python4-8e8770a6503f/</url>
    <content><![CDATA[<blockquote>
<p>整理更偏重数据分析方向的 python 基础知识, 快速入门. python 应用领域广泛, 在科学计算, 统计, 人工智能等领域有巨大优势, 学好 python 基础对入门数据分析来说, 是基石</p>
</blockquote>
<p><a href="https://docs.python.org/zh-cn/3.8/">python官方文档</a></p>
<p><font color=#00A600 >2020年6月19日更新</font></p>
<h2 id="五-异常-模块和包-以及文件读写"><a href="#五-异常-模块和包-以及文件读写" class="headerlink" title="五, 异常, 模块和包, 以及文件读写"></a>五, 异常, 模块和包, 以及文件读写</h2><h3 id="1-异常处理"><a href="#1-异常处理" class="headerlink" title="1, 异常处理"></a>1, 异常处理</h3><p>一般 python 在某处无法正常执行代码时就会发生一个异常, 异常是 python 的对象, 都继承自 <code>BaseException</code> 类, 也可自定义异常对象, 如果发生异常不处理, 程序就会终止执行</p>
<p><strong>捕获异常:</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    &lt;语句&gt;        </span><br><span class="line"><span class="keyword">except</span> &lt;异常<span class="number">1</span>&gt;：</span><br><span class="line">    &lt;语句&gt;        </span><br><span class="line"><span class="keyword">except</span> &lt;异常<span class="number">2</span>&gt;:</span><br><span class="line">    &lt;语句&gt;     </span><br><span class="line"><span class="meta">... </span>     </span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    &lt;语句&gt;</span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">    &lt;语句&gt;   </span><br></pre></td></tr></table></figure>

<p><strong>处理机制</strong>:   </p>
<p><code>try</code> 之后的代码执行出错, 执行 <code>except</code>, 寻找出错的异常与指定异常匹配, 如果匹配就接着执行它下面的语句, 如果没找到下一个 <code>except</code> 接着找   </p>
<p>如果 <code>except</code> 后面指定的是一类异常, 将捕获该类异常的所有子类异常; 不指定异常, 将捕获全部异常   </p>
<p><code>except</code> 后面可以加一个 <code>esle</code> 语句, 如果没有异常发生, 执行 <code>esle</code>  </p>
<p><code>try</code> 语句后必须有一个<code>except</code> 或 <code>finally</code>   </p>
<p><code>finally</code> 始终执行  </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = <span class="built_in">input</span>(<span class="string">&#x27;输入:&#x27;</span>)</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    print(<span class="string">&#x27;try...&#x27;</span>)</span><br><span class="line">    r = <span class="number">1</span> / <span class="built_in">int</span>(a)</span><br><span class="line">    print(r)</span><br><span class="line"><span class="keyword">except</span> ValueError <span class="keyword">as</span> e:</span><br><span class="line">    print(<span class="string">&#x27;异常1:&#x27;</span>, e)</span><br><span class="line"><span class="keyword">except</span> ZeroDivisionError <span class="keyword">as</span> e:</span><br><span class="line">    print(<span class="string">&#x27;异常2:&#x27;</span>, e)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    print(<span class="string">&#x27;无异常&#x27;</span>)</span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">    print(<span class="string">&#x27;继续&#x27;</span>)</span><br></pre></td></tr></table></figure>

<pre><code>输入: a

try...
异常1: invalid literal for int() with base 10: &#39;a&#39;
继续</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = <span class="built_in">input</span>(<span class="string">&#x27;输入:&#x27;</span>)</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    print(<span class="string">&#x27;try...&#x27;</span>)</span><br><span class="line">    r = <span class="number">1</span> / <span class="built_in">int</span>(a)</span><br><span class="line">    print(r)</span><br><span class="line"><span class="keyword">except</span> ValueError <span class="keyword">as</span> e:</span><br><span class="line">    print(<span class="string">&#x27;异常1:&#x27;</span>, e)</span><br><span class="line"><span class="keyword">except</span> ZeroDivisionError <span class="keyword">as</span> e:</span><br><span class="line">    print(<span class="string">&#x27;异常2:&#x27;</span>, e)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    print(<span class="string">&#x27;无异常&#x27;</span>)</span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">    print(<span class="string">&#x27;继续&#x27;</span>)</span><br></pre></td></tr></table></figure>

<pre><code>输入: 0

try...
异常2: division by zero
继续</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = <span class="built_in">input</span>(<span class="string">&#x27;输入:&#x27;</span>)</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    print(<span class="string">&#x27;try...&#x27;</span>)</span><br><span class="line">    r = <span class="number">1</span> / <span class="built_in">int</span>(a)</span><br><span class="line">    print(r)</span><br><span class="line"><span class="keyword">except</span> ValueError <span class="keyword">as</span> e:</span><br><span class="line">    print(<span class="string">&#x27;异常1:&#x27;</span>, e)</span><br><span class="line"><span class="keyword">except</span> ZeroDivisionError <span class="keyword">as</span> e:</span><br><span class="line">    print(<span class="string">&#x27;异常2:&#x27;</span>, e)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    print(<span class="string">&#x27;无异常&#x27;</span>)</span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">    print(<span class="string">&#x27;继续&#x27;</span>)</span><br></pre></td></tr></table></figure>

<pre><code>输入: 1

try...
1.0
无异常
继续</code></pre>
<h3 id="2-模块和包"><a href="#2-模块和包" class="headerlink" title="2, 模块和包"></a>2, 模块和包</h3><p><strong>模块:</strong></p>
<p>一个 <code>文件名.py</code> 文件就是一个模块, 一般将实现某个功能的代码封装为一个模块  </p>
<p>模块有内置模块(例如 time, random 等), 也可自定义模块</p>
<p><strong>包:</strong></p>
<p>通俗理解, 就是一个包含 模块 和 一个 <code>__init__.py</code> 文件(内容可以为空)的文件夹, 包里也可以有子包, 形成多层次的目录结构, 组成一个 python 的应用环境 </p>
<p>创建包 <code>my_package</code>, 包里面有模块 <code>my_module</code>, 模块内容如下:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = <span class="string">&#x27;全局变量&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span>():</span></span><br><span class="line">    print(<span class="string">&#x27;模块中的函数&#x27;</span>)</span><br><span class="line">    </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>():</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">show_msg</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&#x27;模块中类 A 的方法&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    show()</span><br></pre></td></tr></table></figure>

<p>直接运行模块, 将执行 if 语句下面的代码:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">%run my_package/my_module</span><br></pre></td></tr></table></figure>

<pre><code>模块中的函数</code></pre>
<p>导入模块, if 语句不执行, 需要调用模块的属性和方法, 才会执行相应代码:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> my_package <span class="keyword">import</span> my_module <span class="keyword">as</span> md</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建模块中类 A 的实例</span></span><br><span class="line">ma = md.A()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 调用属性和方法</span></span><br><span class="line">print(md.a)</span><br><span class="line">md.show()</span><br><span class="line">ma.show_msg()</span><br></pre></td></tr></table></figure>

<pre><code>全局变量
模块中的函数
模块中类 A 的方法</code></pre>
<p><strong>导入模块的方法</strong>:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> my_package.my_module <span class="keyword">as</span> md <span class="comment"># as 起别名</span></span><br><span class="line">md.a</span><br></pre></td></tr></table></figure>




<pre><code>&#39;全局变量&#39;</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> my_package <span class="keyword">import</span> my_module <span class="comment"># 多个模块用 , 号隔开</span></span><br><span class="line">my_module.a</span><br></pre></td></tr></table></figure>




<pre><code>&#39;全局变量&#39;</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> my_package <span class="keyword">import</span> * <span class="comment"># 导入包里的全部模块</span></span><br><span class="line">my_module.a</span><br></pre></td></tr></table></figure>




<pre><code>&#39;全局变量&#39;</code></pre>
<p><strong>导入模块中的属性和方法</strong>:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> my_package.my_module <span class="keyword">import</span> a <span class="keyword">as</span> b, show <span class="keyword">as</span> s</span><br><span class="line">s()</span><br><span class="line">b</span><br></pre></td></tr></table></figure>

<pre><code>模块中的函数

&#39;全局变量&#39;</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> my_package.my_module <span class="keyword">import</span> *</span><br><span class="line">ma = A()</span><br><span class="line">show()</span><br><span class="line">ma.show_msg()</span><br><span class="line">a</span><br></pre></td></tr></table></figure>

<pre><code>模块中的函数
模块中类 A 的方法

&#39;全局变量&#39;</code></pre>
<p><code>if __name__ == &#39;__main__&#39;:</code>的说明:</p>
<p>直接运行模块时, 执行 <code>if</code> 下的代码, 其他地方导入时, <code>if</code> 语句下的代码不执行, 用于测试 或 执行当前模块需要, 其他模块不需要的代码</p>
<h3 id="3-文件读写"><a href="#3-文件读写" class="headerlink" title="3, 文件读写"></a>3, 文件读写</h3><p><strong>打开文件的方法</strong>:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># open 函数</span></span><br><span class="line"><span class="built_in">open</span>(</span><br><span class="line">    file,</span><br><span class="line">    mode=<span class="string">&#x27;r&#x27;</span>,</span><br><span class="line">    buffering=<span class="number">-1</span>,</span><br><span class="line">    encoding=<span class="literal">None</span>,</span><br><span class="line">    errors=<span class="literal">None</span>,</span><br><span class="line">    newline=<span class="literal">None</span>,</span><br><span class="line">    closefd=<span class="literal">True</span>,</span><br><span class="line">    opener=<span class="literal">None</span>,</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打开文件方法一:</span></span><br><span class="line">f = <span class="built_in">open</span>(...)</span><br><span class="line">...</span><br><span class="line">f.close() <span class="comment"># 需要 f.close() 关闭文件</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 打开文件方法二:</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(...) <span class="keyword">as</span> f: <span class="comment"># 无需 f.close() 关闭文件</span></span><br></pre></td></tr></table></figure>

<p><strong>打开文件的常用模式</strong>: </p>
<p><code>r</code>    只读,    默认模式，如果文件不存在就报错，存在就正常读取</p>
<p><code>w</code>    只写,    如果文件不存在，新建文件然后写入, 存在，先清空文件内容，再写入</p>
<p><code>a</code>    追加,    如果文件不存在，新建文件，然后写入, 存在，在文件的最后追加写入</p>
<p><code>x</code>    新建,    如果文件存在则报错，如果不存在就新建文件，然后写入内容，比 w 模式更安全</p>
<p><code>b</code>    二进制模式, 比如 rb、wb、ab</p>
<p><code>+</code>    读写模式, 比如 r+、w+、a+</p>
<p><strong>给文件写入内容:</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = <span class="string">&quot;&quot;&quot;星辰大海需要门票,</span></span><br><span class="line"><span class="string">诗和远方路途遥远,</span></span><br><span class="line"><span class="string">不管走过多少弯路,</span></span><br><span class="line"><span class="string">每一步都在倒计时.&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;test.txt&#x27;</span>, <span class="string">&#x27;w&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f.write(a)</span><br></pre></td></tr></table></figure>

<p><strong>读取内容:</strong></p>
<p><code>read()</code> 默认读取全部内容, 可以指定读取大小</p>
<p><code>readline()</code> 每次读取一行, 也可指定大小</p>
<p><code>readlines()</code> 一次读取一行并返回 <code>list</code> </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">f = <span class="built_in">open</span>(<span class="string">&#x27;test.txt&#x27;</span>)</span><br><span class="line">print(f.read())</span><br></pre></td></tr></table></figure>

<pre><code>星辰大海需要门票,
诗和远方路途遥远,
不管走过多少弯路,
每一步都在倒计时.</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">f = <span class="built_in">open</span>(<span class="string">&#x27;test.txt&#x27;</span>)</span><br><span class="line">f.readline()</span><br></pre></td></tr></table></figure>




<pre><code>&#39;星辰大海需要门票,\n&#39;</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">f = <span class="built_in">open</span>(<span class="string">&#x27;test.txt&#x27;</span>)</span><br><span class="line">f.readlines()</span><br></pre></td></tr></table></figure>




<pre><code>[&#39;星辰大海需要门票,\n&#39;, &#39;诗和远方路途遥远,\n&#39;, &#39;不管走过多少弯路,\n&#39;, &#39;每一步都在倒计时.&#39;]</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">f.close()</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据分析</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构操作，处理与计算</title>
    <url>/data/pandas1-4798b1c5fd91/</url>
    <content><![CDATA[<blockquote>
<p>pandas 是 Python 的核心数据分析支持库, 基于 NumPy 创建, 它使 python 成为强大而高效的数据分析环境 </p>
</blockquote>
<p><font color=#00A600 >2020年7月13日更新</font></p>
<blockquote>
<p>pandas 基础最重要知识点就是两个数据结构 Series(一维) 和 DataFrame(二维), 处理这两个数据结构的方法和函数, 以及运用的逻辑</p>
</blockquote>
<blockquote>
<p>下文约定 NumPy 简写 <code>np</code>, Pandas 简写 <code>pd</code>, Series 简写 <code>s</code>, DataFrame 简写 <code>df</code></p>
</blockquote>
<h2 id="一-数据结构"><a href="#一-数据结构" class="headerlink" title="一, 数据结构"></a>一, 数据结构</h2><p>pd 的数据结构是基于 np 的, 因此其有着 np 的基因, 许多操作和大部分函数与 np 类似</p>
<p>pd 的数据结构其实是 np 数组数据对象 array 的容器, 在 pd 中有了索引结构, 可以利用索引来取 array 或 array 的值</p>
<h3 id="1-创建-s-和-df"><a href="#1-创建-s-和-df" class="headerlink" title="1, 创建 s 和 df"></a>1, 创建 s 和 df</h3><p>创建 s 用 Series 方法, 创建 df 用 DataFrame 方法, 创建时若不指定索引, 将自动生成(从 0 开始)</p>
<p>s 是一维, 只有行索引, 而 df 有行和列索引</p>
<p>创建方式灵活多变, 可以查看参数, 根据要求传参进行创建, 简单介绍几种</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line">s = pd.Series(<span class="built_in">range</span>(<span class="number">3</span>))</span><br><span class="line">df = pd.DataFrame(<span class="built_in">range</span>(<span class="number">3</span>))</span><br><span class="line">display(s)</span><br><span class="line">df</span><br></pre></td></tr></table></figure>


<pre><code>0    0
1    1
2    2
dtype: int64</code></pre>
<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

<pre><code>.dataframe tbody tr th &#123;
    vertical-align: top;
&#125;

.dataframe thead th &#123;
    text-align: right;
&#125;</code></pre>
<p></style></p>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>0</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>0</td>
    </tr>
    <tr>
      <th>1</th>
      <td>1</td>
    </tr>
    <tr>
      <th>2</th>
      <td>2</td>
    </tr>
  </tbody>
</table>
</div>




<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s = pd.Series(<span class="built_in">range</span>(<span class="number">3</span>), index=<span class="built_in">list</span>(<span class="string">&#x27;abc&#x27;</span>))</span><br><span class="line">df = pd.DataFrame(&#123;<span class="string">&#x27;A&#x27;</span>: <span class="built_in">range</span>(<span class="number">3</span>), <span class="string">&#x27;B&#x27;</span>: <span class="built_in">list</span>(<span class="string">&#x27;jkl&#x27;</span>)&#125;, index=<span class="built_in">list</span>(<span class="string">&#x27;abc&#x27;</span>))</span><br><span class="line">display(s)</span><br><span class="line">df</span><br></pre></td></tr></table></figure>


<pre><code>a    0
b    1
c    2
dtype: int64</code></pre>
<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

<pre><code>.dataframe tbody tr th &#123;
    vertical-align: top;
&#125;

.dataframe thead th &#123;
    text-align: right;
&#125;</code></pre>
<p></style></p>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>A</th>
      <th>B</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>a</th>
      <td>0</td>
      <td>j</td>
    </tr>
    <tr>
      <th>b</th>
      <td>1</td>
      <td>k</td>
    </tr>
    <tr>
      <th>c</th>
      <td>2</td>
      <td>l</td>
    </tr>
  </tbody>
</table>
</div>




<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dict_1 = &#123;<span class="string">&#x27;a&#x27;</span>: <span class="number">0</span>, <span class="string">&#x27;b&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;c&#x27;</span>: <span class="number">2</span>&#125;</span><br><span class="line">dict_2 = &#123;<span class="string">&#x27;a&#x27;</span>: <span class="built_in">range</span>(<span class="number">3</span>), <span class="string">&#x27;b&#x27;</span>: <span class="built_in">list</span>(<span class="string">&#x27;jkl&#x27;</span>)&#125;</span><br><span class="line">s = pd.Series(dict_1)</span><br><span class="line">df1 = pd.DataFrame(dict_1, index=[<span class="string">&#x27;A&#x27;</span>])</span><br><span class="line">df2 = pd.DataFrame(dict_2)</span><br><span class="line">display(s)</span><br><span class="line">display(df1)</span><br><span class="line">df2</span><br></pre></td></tr></table></figure>


<pre><code>a    0
b    1
c    2
dtype: int64</code></pre>
<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

<pre><code>.dataframe tbody tr th &#123;
    vertical-align: top;
&#125;

.dataframe thead th &#123;
    text-align: right;
&#125;</code></pre>
<p></style></p>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>a</th>
      <th>b</th>
      <th>c</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>A</th>
      <td>0</td>
      <td>1</td>
      <td>2</td>
    </tr>
  </tbody>
</table>
</div>





<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

<pre><code>.dataframe tbody tr th &#123;
    vertical-align: top;
&#125;

.dataframe thead th &#123;
    text-align: right;
&#125;</code></pre>
<p></style></p>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>a</th>
      <th>b</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>0</td>
      <td>j</td>
    </tr>
    <tr>
      <th>1</th>
      <td>1</td>
      <td>k</td>
    </tr>
    <tr>
      <th>2</th>
      <td>2</td>
      <td>l</td>
    </tr>
  </tbody>
</table>
</div>



<h3 id="2-s-和-df-的常用属性"><a href="#2-s-和-df-的常用属性" class="headerlink" title="2, s 和 df 的常用属性"></a>2, s 和 df 的常用属性</h3><p>大部分属性和 numpy 一样</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s = pd.Series(<span class="number">1</span>, index=<span class="built_in">list</span>(<span class="string">&#x27;abc&#x27;</span>))</span><br><span class="line">df = pd.DataFrame(dict_2)</span><br><span class="line"></span><br><span class="line">s, df</span><br></pre></td></tr></table></figure>




<pre><code>(a    1
 b    1
 c    1
 dtype: int64,
    a  b
 0  0  j
 1  1  k
 2  2  l)</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看形状, 形状不包括 索引</span></span><br><span class="line">s.shape, df.shape</span><br></pre></td></tr></table></figure>




<pre><code>((3,), (3, 2))</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 获取索引</span></span><br><span class="line">s.index, df.index, df.columns</span><br></pre></td></tr></table></figure>




<pre><code>(Index([&#39;a&#39;, &#39;b&#39;, &#39;c&#39;], dtype=&#39;object&#39;),
 RangeIndex(start=0, stop=3, step=1),
 Index([&#39;a&#39;, &#39;b&#39;], dtype=&#39;object&#39;))</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看元素个数</span></span><br><span class="line">s.size, df.size</span><br></pre></td></tr></table></figure>




<pre><code>(3, 6)</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看数据类型</span></span><br><span class="line">s.dtype, df.dtypes</span><br></pre></td></tr></table></figure>




<pre><code>(dtype(&#39;int64&#39;),
 a     int64
 b    object
 dtype: object)</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看值</span></span><br><span class="line">s.values, df.values, df[<span class="string">&#x27;a&#x27;</span>].values</span><br></pre></td></tr></table></figure>




<pre><code>(array([1, 1, 1], dtype=int64),
 array([[0, &#39;j&#39;],
        [1, &#39;k&#39;],
        [2, &#39;l&#39;]], dtype=object),
 array([0, 1, 2], dtype=int64))</code></pre>
<h3 id="3-s-和-df-结构理解"><a href="#3-s-和-df-结构理解" class="headerlink" title="3, s 和 df 结构理解"></a>3, s 和 df 结构理解</h3><p>从上述可以看出, pd 数据结构的值, 是一个 array 对象. 对于 df, 每一列的值取出来也是一个 array 对象, 并且每一列可以是不同的数据类型</p>
<p>需要注意的是, df 每一列取出来, 整体是一个 s, 因此 df 又可以看成 s 的容器</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">type</span>(s), <span class="built_in">type</span>(df[<span class="string">&#x27;a&#x27;</span>]), <span class="built_in">type</span>(df)</span><br></pre></td></tr></table></figure>




<pre><code>(pandas.core.series.Series,
 pandas.core.series.Series,
 pandas.core.frame.DataFrame)</code></pre>
<p>s 和 df 可以有多层索引</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s.index = [[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>], [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]]</span><br><span class="line">df.index = [[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>], [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]]</span><br><span class="line"></span><br><span class="line">s, df</span><br></pre></td></tr></table></figure>




<pre><code>(a  1    1
 b  2    1
 c  3    1
 dtype: int64,
      a  b
 a 1  0  j
 b 2  1  k
 c 3  2  l)</code></pre>
<h2 id="二-数据结构操作-处理与计算"><a href="#二-数据结构操作-处理与计算" class="headerlink" title="二, 数据结构操作, 处理与计算"></a>二, 数据结构操作, 处理与计算</h2><h3 id="1-查看-s-和-df-数据信息常用方法"><a href="#1-查看-s-和-df-数据信息常用方法" class="headerlink" title="1, 查看 s 和 df 数据信息常用方法"></a>1, 查看 s 和 df 数据信息常用方法</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = np.random.randint(<span class="number">1</span>, <span class="number">9</span>, (<span class="number">6</span>, <span class="number">2</span>))</span><br><span class="line">s = pd.Series(a[:, <span class="number">0</span>])</span><br><span class="line">df = pd.DataFrame(a)</span><br><span class="line">s, df</span><br></pre></td></tr></table></figure>




<pre><code>(0    1
 1    2
 2    2
 3    8
 4    8
 5    2
 dtype: int32,
    0  1
 0  1  8
 1  2  3
 2  2  1
 3  8  3
 4  8  8
 5  2  7)</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看前 5 行(默认)</span></span><br><span class="line">s.head()</span><br><span class="line">df.head()</span><br></pre></td></tr></table></figure>




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

<pre><code>.dataframe tbody tr th &#123;
    vertical-align: top;
&#125;

.dataframe thead th &#123;
    text-align: right;
&#125;</code></pre>
<p></style></p>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>0</th>
      <th>1</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>5</td>
      <td>5</td>
    </tr>
    <tr>
      <th>1</th>
      <td>8</td>
      <td>2</td>
    </tr>
    <tr>
      <th>2</th>
      <td>2</td>
      <td>3</td>
    </tr>
    <tr>
      <th>3</th>
      <td>1</td>
      <td>1</td>
    </tr>
    <tr>
      <th>4</th>
      <td>5</td>
      <td>1</td>
    </tr>
  </tbody>
</table>
</div>




<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看后 5 行(默认)</span></span><br><span class="line">s.tail()</span><br><span class="line">df.tail()</span><br></pre></td></tr></table></figure>




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

<pre><code>.dataframe tbody tr th &#123;
    vertical-align: top;
&#125;

.dataframe thead th &#123;
    text-align: right;
&#125;</code></pre>
<p></style></p>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>0</th>
      <th>1</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>1</th>
      <td>8</td>
      <td>2</td>
    </tr>
    <tr>
      <th>2</th>
      <td>2</td>
      <td>3</td>
    </tr>
    <tr>
      <th>3</th>
      <td>1</td>
      <td>1</td>
    </tr>
    <tr>
      <th>4</th>
      <td>5</td>
      <td>1</td>
    </tr>
    <tr>
      <th>5</th>
      <td>3</td>
      <td>7</td>
    </tr>
  </tbody>
</table>
</div>




<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看详情, s 没有该方法</span></span><br><span class="line">df.info()</span><br></pre></td></tr></table></figure>

<pre><code>&lt;class &#39;pandas.core.frame.DataFrame&#39;&gt;
RangeIndex: 6 entries, 0 to 5
Data columns (total 2 columns):
 #   Column  Non-Null Count  Dtype
---  ------  --------------  -----
 0   0       6 non-null      int32
 1   1       6 non-null      int32
dtypes: int32(2)
memory usage: 176.0 bytes</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看统计量</span></span><br><span class="line">s.describe()</span><br><span class="line">df.describe()</span><br></pre></td></tr></table></figure>




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

<pre><code>.dataframe tbody tr th &#123;
    vertical-align: top;
&#125;

.dataframe thead th &#123;
    text-align: right;
&#125;</code></pre>
<p></style></p>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>0</th>
      <th>1</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>count</th>
      <td>6.000000</td>
      <td>6.000000</td>
    </tr>
    <tr>
      <th>mean</th>
      <td>4.000000</td>
      <td>3.166667</td>
    </tr>
    <tr>
      <th>std</th>
      <td>2.529822</td>
      <td>2.401388</td>
    </tr>
    <tr>
      <th>min</th>
      <td>1.000000</td>
      <td>1.000000</td>
    </tr>
    <tr>
      <th>25%</th>
      <td>2.250000</td>
      <td>1.250000</td>
    </tr>
    <tr>
      <th>50%</th>
      <td>4.000000</td>
      <td>2.500000</td>
    </tr>
    <tr>
      <th>75%</th>
      <td>5.000000</td>
      <td>4.500000</td>
    </tr>
    <tr>
      <th>max</th>
      <td>8.000000</td>
      <td>7.000000</td>
    </tr>
  </tbody>
</table>
</div>



<h3 id="2-数据的直接计算"><a href="#2-数据的直接计算" class="headerlink" title="2, 数据的直接计算"></a>2, 数据的直接计算</h3><p>s 和 df 的数据可以像 np 的数组一样直接进行计算, 索引相同的行列进行计算, 不同的 NaN 填充</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df1 = pd.DataFrame(a, columns=[<span class="number">1</span>, <span class="string">&#x27;b&#x27;</span>])</span><br><span class="line">df1 * df</span><br></pre></td></tr></table></figure>




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

<pre><code>.dataframe tbody tr th &#123;
    vertical-align: top;
&#125;

.dataframe thead th &#123;
    text-align: right;
&#125;</code></pre>
<p></style></p>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>0</th>
      <th>1</th>
      <th>b</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>NaN</td>
      <td>8</td>
      <td>NaN</td>
    </tr>
    <tr>
      <th>1</th>
      <td>NaN</td>
      <td>6</td>
      <td>NaN</td>
    </tr>
    <tr>
      <th>2</th>
      <td>NaN</td>
      <td>2</td>
      <td>NaN</td>
    </tr>
    <tr>
      <th>3</th>
      <td>NaN</td>
      <td>24</td>
      <td>NaN</td>
    </tr>
    <tr>
      <th>4</th>
      <td>NaN</td>
      <td>64</td>
      <td>NaN</td>
    </tr>
    <tr>
      <th>5</th>
      <td>NaN</td>
      <td>14</td>
      <td>NaN</td>
    </tr>
  </tbody>
</table>
</div>




<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s1 = pd.Series(a[:, <span class="number">0</span>], index=[<span class="string">&#x27;a&#x27;</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>])</span><br><span class="line">s**<span class="number">2</span> + s1</span><br></pre></td></tr></table></figure>




<pre><code>0     NaN
1     6.0
2     6.0
3    72.0
4    72.0
5     6.0
a     NaN
dtype: float64</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 笛卡儿积展开</span></span><br><span class="line">s + df1</span><br></pre></td></tr></table></figure>




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

<pre><code>.dataframe tbody tr th &#123;
    vertical-align: top;
&#125;

.dataframe thead th &#123;
    text-align: right;
&#125;</code></pre>
<p></style></p>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>0</th>
      <th>1</th>
      <th>2</th>
      <th>3</th>
      <th>4</th>
      <th>5</th>
      <th>b</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>NaN</td>
      <td>3.0</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
    </tr>
    <tr>
      <th>1</th>
      <td>NaN</td>
      <td>4.0</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
    </tr>
    <tr>
      <th>2</th>
      <td>NaN</td>
      <td>4.0</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
    </tr>
    <tr>
      <th>3</th>
      <td>NaN</td>
      <td>10.0</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
    </tr>
    <tr>
      <th>4</th>
      <td>NaN</td>
      <td>10.0</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
    </tr>
    <tr>
      <th>5</th>
      <td>NaN</td>
      <td>4.0</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
    </tr>
  </tbody>
</table>
</div>



<h3 id="3-s-和-df-下标和索引切片操作"><a href="#3-s-和-df-下标和索引切片操作" class="headerlink" title="3, s 和 df 下标和索引切片操作"></a>3, s 和 df 下标和索引切片操作</h3><h4 id="3-01-s-和-df-下标切片取值"><a href="#3-01-s-和-df-下标切片取值" class="headerlink" title="3.01, s 和 df 下标切片取值"></a>3.01, s 和 df 下标切片取值</h4><p>s 和 df 下标切片取值有许多不同之处</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s1, df1</span><br></pre></td></tr></table></figure>




<pre><code>(a    1
 1    2
 2    2
 3    8
 4    8
 5    2
 dtype: int32,
    1  b
 0  1  8
 1  2  3
 2  2  1
 3  8  3
 4  8  8
 5  2  7)</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 此方法 df 只能取行, 不能取列</span></span><br><span class="line">s1[<span class="number">0</span>:<span class="number">2</span>], df1[<span class="number">0</span>:<span class="number">2</span>], s1[[<span class="number">0</span>, <span class="number">2</span>]]</span><br></pre></td></tr></table></figure>




<pre><code>(a    1
 1    2
 dtype: int32,
    1  b
 0  1  8
 1  2  3,
 a    1
 2    2
 dtype: int32)</code></pre>
<p><strong>同 np 一样, 可以条件取值, 此方法常用来筛选和重新赋值等</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s1[s1&gt;<span class="number">1</span>], df1[df1&gt;<span class="number">1</span>], df1[df1 == <span class="number">8</span>]</span><br></pre></td></tr></table></figure>




<pre><code>(1    2
 2    2
 3    8
 4    8
 5    2
 dtype: int32,
      1    b
 0  NaN  8.0
 1  2.0  3.0
 2  2.0  NaN
 3  8.0  3.0
 4  8.0  8.0
 5  2.0  7.0,
      1    b
 0  NaN  8.0
 1  NaN  NaN
 2  NaN  NaN
 3  8.0  NaN
 4  8.0  8.0
 5  NaN  NaN)</code></pre>
<h4 id="3-02-s-和-df-索引切片取值"><a href="#3-02-s-和-df-索引切片取值" class="headerlink" title="3.02, s 和 df 索引切片取值"></a>3.02, s 和 df 索引切片取值</h4><p>索引切片取值, 左右都包含</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 需要将索引转换类型</span></span><br><span class="line">s1.index = s1.index.astype(<span class="built_in">str</span>)</span><br><span class="line">df1.index = df1.index.astype(<span class="built_in">str</span>)</span><br><span class="line">s1[<span class="string">&#x27;a&#x27;</span>:<span class="string">&#x27;2&#x27;</span>], df1[<span class="string">&#x27;1&#x27;</span>:<span class="string">&#x27;3&#x27;</span>]</span><br></pre></td></tr></table></figure>




<pre><code>(a    1
 1    2
 2    2
 dtype: int32,
    1  b
 1  2  3
 2  2  1
 3  8  3)</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df1[<span class="string">&#x27;1&#x27;</span>:<span class="string">&#x27;3&#x27;</span>][[<span class="number">1</span>]], df1[<span class="string">&#x27;b&#x27;</span>], df1[[<span class="string">&#x27;b&#x27;</span>, <span class="number">1</span>]]</span><br></pre></td></tr></table></figure>




<pre><code>(   1
 1  2
 2  2
 3  8,
 0    8
 1    3
 2    1
 3    3
 4    8
 5    7
 Name: b, dtype: int32,
    b  1
 0  8  1
 1  3  2
 2  1  2
 3  3  8
 4  8  8
 5  7  2)</code></pre>
<h4 id="3-03-用-iloc-方法取值-推荐"><a href="#3-03-用-iloc-方法取值-推荐" class="headerlink" title="3.03, 用 iloc 方法取值(推荐)"></a>3.03, 用 iloc 方法取值(推荐)</h4><p>上述的取值太复杂麻烦, iloc 方法传入下标取值更方便且条理清晰. 存在多层索引时, iloc 按最内层索引取值</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 右不包含</span></span><br><span class="line">s1.iloc[<span class="number">0</span>:<span class="number">3</span>], df1.iloc[<span class="number">0</span>:<span class="number">5</span>:<span class="number">2</span>], df1.iloc[[<span class="number">1</span>, <span class="number">4</span>, <span class="number">2</span>], <span class="number">0</span>]</span><br></pre></td></tr></table></figure>




<pre><code>(a    1
 1    2
 2    2
 dtype: int32,
    1  b
 0  1  8
 2  2  1
 4  8  8,
 1    2
 4    8
 2    2
 Name: 1, dtype: int32)</code></pre>
<h4 id="3-04-用-loc-方法"><a href="#3-04-用-loc-方法" class="headerlink" title="3.04, 用 loc 方法"></a>3.04, 用 loc 方法</h4><p>loc 方法取值左右都包含, 传入索引标签取值</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s1.loc[<span class="string">&#x27;a&#x27;</span>:<span class="string">&#x27;2&#x27;</span>], df1.loc[<span class="string">&#x27;1&#x27;</span>:<span class="string">&#x27;3&#x27;</span>, <span class="string">&#x27;b&#x27;</span>]</span><br></pre></td></tr></table></figure>




<pre><code>(a    1
 1    2
 2    2
 dtype: int32,
 1    3
 2    1
 3    3
 Name: b, dtype: int32)</code></pre>
<h4 id="3-05-利用切片修改数据"><a href="#3-05-利用切片修改数据" class="headerlink" title="3.05, 利用切片修改数据"></a>3.05, 利用切片修改数据</h4><p>利用切片修改数据, 其实就是取值重新赋值</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line">df = pd.DataFrame(np.random.rand(<span class="number">5</span>, <span class="number">4</span>),</span><br><span class="line">                  index=<span class="built_in">list</span>(<span class="string">&#x27;abcde&#x27;</span>),</span><br><span class="line">                  columns=<span class="built_in">list</span>(<span class="string">&#x27;ABCD&#x27;</span>))</span><br><span class="line">df[df&gt;<span class="number">0.5</span>]</span><br></pre></td></tr></table></figure>




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

<pre><code>.dataframe tbody tr th &#123;
    vertical-align: top;
&#125;

.dataframe thead th &#123;
    text-align: right;
&#125;</code></pre>
<p></style></p>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>A</th>
      <th>B</th>
      <th>C</th>
      <th>D</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>a</th>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>0.584239</td>
    </tr>
    <tr>
      <th>b</th>
      <td>NaN</td>
      <td>0.946957</td>
      <td>0.710115</td>
      <td>0.542091</td>
    </tr>
    <tr>
      <th>c</th>
      <td>NaN</td>
      <td>0.749082</td>
      <td>NaN</td>
      <td>NaN</td>
    </tr>
    <tr>
      <th>d</th>
      <td>0.990660</td>
      <td>0.537833</td>
      <td>NaN</td>
      <td>NaN</td>
    </tr>
    <tr>
      <th>e</th>
      <td>0.579108</td>
      <td>0.527163</td>
      <td>NaN</td>
      <td>0.930887</td>
    </tr>
  </tbody>
</table>
</div>




<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 将大于 0.5 的数据换成 nan</span></span><br><span class="line">df[df&gt;<span class="number">0.5</span>] = np.nan</span><br><span class="line">df</span><br></pre></td></tr></table></figure>




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

<pre><code>.dataframe tbody tr th &#123;
    vertical-align: top;
&#125;

.dataframe thead th &#123;
    text-align: right;
&#125;</code></pre>
<p></style></p>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>A</th>
      <th>B</th>
      <th>C</th>
      <th>D</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>a</th>
      <td>0.055483</td>
      <td>0.376705</td>
      <td>0.295532</td>
      <td>NaN</td>
    </tr>
    <tr>
      <th>b</th>
      <td>0.230846</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
    </tr>
    <tr>
      <th>c</th>
      <td>0.304272</td>
      <td>NaN</td>
      <td>0.415037</td>
      <td>0.271673</td>
    </tr>
    <tr>
      <th>d</th>
      <td>NaN</td>
      <td>NaN</td>
      <td>0.413262</td>
      <td>0.207829</td>
    </tr>
    <tr>
      <th>e</th>
      <td>NaN</td>
      <td>NaN</td>
      <td>0.387687</td>
      <td>NaN</td>
    </tr>
  </tbody>
</table>
</div>




<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 将 A 列全部改成 1 , 增加一列 E 值为 0</span></span><br><span class="line">df[<span class="string">&#x27;A&#x27;</span>] = <span class="number">1</span> <span class="comment"># 与 df.A = 1 等价</span></span><br><span class="line">df[<span class="string">&#x27;E&#x27;</span>] = <span class="number">0</span></span><br><span class="line">df</span><br></pre></td></tr></table></figure>




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

<pre><code>.dataframe tbody tr th &#123;
    vertical-align: top;
&#125;

.dataframe thead th &#123;
    text-align: right;
&#125;</code></pre>
<p></style></p>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>A</th>
      <th>B</th>
      <th>C</th>
      <th>D</th>
      <th>E</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>a</th>
      <td>1</td>
      <td>0.376705</td>
      <td>0.295532</td>
      <td>NaN</td>
      <td>0</td>
    </tr>
    <tr>
      <th>b</th>
      <td>1</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>0</td>
    </tr>
    <tr>
      <th>c</th>
      <td>1</td>
      <td>NaN</td>
      <td>0.415037</td>
      <td>0.271673</td>
      <td>0</td>
    </tr>
    <tr>
      <th>d</th>
      <td>1</td>
      <td>NaN</td>
      <td>0.413262</td>
      <td>0.207829</td>
      <td>0</td>
    </tr>
    <tr>
      <th>e</th>
      <td>1</td>
      <td>NaN</td>
      <td>0.387687</td>
      <td>NaN</td>
      <td>0</td>
    </tr>
  </tbody>
</table>
</div>




<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 行列值互换</span></span><br><span class="line">df.loc[[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;c&#x27;</span>], [<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;C&#x27;</span>]] = df.loc[[<span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;a&#x27;</span>], [<span class="string">&#x27;C&#x27;</span>, <span class="string">&#x27;A&#x27;</span>]].to_numpy()</span><br><span class="line">df</span><br></pre></td></tr></table></figure>




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

<pre><code>.dataframe tbody tr th &#123;
    vertical-align: top;
&#125;

.dataframe thead th &#123;
    text-align: right;
&#125;</code></pre>
<p></style></p>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>A</th>
      <th>B</th>
      <th>C</th>
      <th>D</th>
      <th>E</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>a</th>
      <td>0.415037</td>
      <td>0.376705</td>
      <td>1.000000</td>
      <td>NaN</td>
      <td>0</td>
    </tr>
    <tr>
      <th>b</th>
      <td>1.000000</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>0</td>
    </tr>
    <tr>
      <th>c</th>
      <td>0.295532</td>
      <td>NaN</td>
      <td>1.000000</td>
      <td>0.271673</td>
      <td>0</td>
    </tr>
    <tr>
      <th>d</th>
      <td>1.000000</td>
      <td>NaN</td>
      <td>0.413262</td>
      <td>0.207829</td>
      <td>0</td>
    </tr>
    <tr>
      <th>e</th>
      <td>1.000000</td>
      <td>NaN</td>
      <td>0.387687</td>
      <td>NaN</td>
      <td>0</td>
    </tr>
  </tbody>
</table>
</div>




<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 只要 B 不为 nan 的数据</span></span><br><span class="line">df[df[<span class="string">&#x27;B&#x27;</span>] == df[<span class="string">&#x27;B&#x27;</span>]]</span><br></pre></td></tr></table></figure>




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

<pre><code>.dataframe tbody tr th &#123;
    vertical-align: top;
&#125;

.dataframe thead th &#123;
    text-align: right;
&#125;</code></pre>
<p></style></p>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>A</th>
      <th>B</th>
      <th>C</th>
      <th>D</th>
      <th>E</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>a</th>
      <td>0.415037</td>
      <td>0.376705</td>
      <td>1.0</td>
      <td>NaN</td>
      <td>0</td>
    </tr>
  </tbody>
</table>
</div>
]]></content>
      <categories>
        <category>数据分析</category>
      </categories>
      <tags>
        <tag>pandas</tag>
      </tags>
  </entry>
  <entry>
    <title>数据容器</title>
    <url>/data/python2-264a8e0ab5f1/</url>
    <content><![CDATA[<blockquote>
<p>整理更偏重数据分析方向的 python 基础知识, 快速入门. python 应用领域广泛, 在科学计算, 统计, 人工智能等领域有巨大优势, 学好 python 基础对入门数据分析来说, 是基石</p>
</blockquote>
<p><a href="https://docs.python.org/zh-cn/3.8/">python官方文档</a></p>
<p><font color=#00A600 >2020年6月19日更新</font></p>
<h2 id="二-python-数据容器"><a href="#二-python-数据容器" class="headerlink" title="二, python 数据容器"></a>二, python 数据容器</h2><p>数据容器简单理解就是存储数据的容器, 例如字符串存储字符, 列表和元组等存储数据元素, 变量存储赋予的数据等</p>
<p>数据容器又有有序和无序(就是没有先后顺序), 可变和不可变(就是内存地址不变)之分, 这是为了数据的安全, 调用, 计算和处理等设计的, 例如字符串和元组是有序不可变容器, 列表是有序可变容器, 字典是无序可变容器</p>
<h3 id="1-数据容器的下标索引和切片"><a href="#1-数据容器的下标索引和切片" class="headerlink" title="1, 数据容器的下标索引和切片"></a>1, 数据容器的下标索引和切片</h3><p><strong>有序容器</strong>才有下标索引和切片操作, 例如字符串, 元组和列表</p>
<p>下标从 <code>0</code> 开始(容器里的第一个元素), 可反向索引从 <code>-1</code> 开始(最后一个元素), 可利用下标索引取对应的元素</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;abcdef&#x27;</span>[<span class="number">0</span>]</span><br></pre></td></tr></table></figure>




<pre><code>&#39;a&#39;</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;abcdef&#x27;</span>[<span class="number">-1</span>]</span><br></pre></td></tr></table></figure>




<pre><code>&#39;f&#39;</code></pre>
<p>切片的语法: <code>[起始:结束:步长]</code>, 起始, 结束和步长指的是下标索引, <strong>不包括 <code>结束</code></strong></p>
<p>如没有 <code>起始</code>, 默认 0 开始, 没有 <code>结束</code> 则到最后一个结束, 没有步长默认是 <code>1</code>, 例如:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;abcdef&#x27;</span>[:<span class="number">-1</span>]</span><br></pre></td></tr></table></figure>




<pre><code>&#39;abcde&#39;</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;abcdef&#x27;</span>[::<span class="number">2</span>]</span><br></pre></td></tr></table></figure>




<pre><code>&#39;ace&#39;</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;abcdef&#x27;</span>[<span class="number">1</span>:<span class="number">-3</span>]</span><br></pre></td></tr></table></figure>




<pre><code>&#39;bc&#39;</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;abcdef&#x27;</span>[<span class="number">4</span>:<span class="number">-4</span>] <span class="comment"># 起始和结束之间没有元素</span></span><br></pre></td></tr></table></figure>




<pre><code>&#39;&#39;</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;abcdef&#x27;</span>[<span class="number">-1</span>:<span class="number">1</span>]</span><br></pre></td></tr></table></figure>




<pre><code>&#39;&#39;</code></pre>
<p>步长为负数时反向切片, 且切片的结果顺序反过来, 例:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;abcdef&#x27;</span>[<span class="number">-1</span>:<span class="number">1</span>:<span class="number">-2</span>]</span><br></pre></td></tr></table></figure>




<pre><code>&#39;fd&#39;</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;abcdef&#x27;</span>[<span class="number">1</span>:<span class="number">-1</span>:<span class="number">-2</span>]</span><br></pre></td></tr></table></figure>




<pre><code>&#39;&#39;</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;abc&#x27;</span>[::<span class="number">-1</span>] <span class="comment"># 默认从 -1 开始, 0 结束</span></span><br></pre></td></tr></table></figure>




<pre><code>&#39;cba&#39;</code></pre>
<h3 id="2-字符串-str"><a href="#2-字符串-str" class="headerlink" title="2. 字符串 str"></a>2. 字符串 str</h3><p>单引号, 双引号或三引号(可换行)包围的字符</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">print(<span class="string">&#x27;abc123&#x27;</span>, <span class="string">&quot;abc字符串&quot;</span>, <span class="string">&#x27;&#x27;&#x27;a</span></span><br><span class="line"><span class="string">bc&#x27;&#x27;&#x27;</span>, </span><br><span class="line"><span class="string">&quot;&quot;&quot;abc</span></span><br><span class="line"><span class="string">abc</span></span><br><span class="line"><span class="string">abc&quot;&quot;&quot;</span>, <span class="string">&#x27;这是&quot;abc&quot;&#x27;</span>)</span><br></pre></td></tr></table></figure>

<pre><code>abc123 abc字符串 a
bc abc
abc
abc 这是&quot;abc&quot;</code></pre>
<h4 id="2-01-字符编码"><a href="#2-01-字符编码" class="headerlink" title="2.01, 字符编码:"></a>2.01, 字符编码:</h4><p>最早的 ASCII 编码( 1 个字节)只有127个字符被编码到计算机里，也就是大小写英文字母, 数字和一些符号, 然后 Unicode 编码( 2 个字节)诞生, 把所有语言字符都统一到一套编码里, 但是如果文本大部分是英文，用 Unicode 编码比 ASCII 编码需要多一倍的存储空间, 然后 UTF-8 编码诞生, 它把英文字母编码成 1 个字节，汉字通常 3 个字节，很生僻的字符 4-6 个字节</p>
<h4 id="2-02-转义字符"><a href="#2-02-转义字符" class="headerlink" title="2.02, 转义字符\:"></a>2.02, 转义字符<code>\</code>:</h4><p>转义字符能将字符转义为特殊功能的字符, 例如 <code>\n</code> 表示换行, <code>\t</code> 表示制表符:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">print(<span class="string">&#x27;abc\nabc\tabc&#x27;</span>)</span><br></pre></td></tr></table></figure>

<pre><code>abc
abc    abc</code></pre>
<p>若要输出 <code>\</code>, 则自己将自己转义, 若不需要转义, 可用 <code>r&#39;&#39;</code> 表示字符串不需要转义:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">print(<span class="string">&#x27;\\&#x27;</span>, <span class="string">r&#x27;abc\nabc\tabc&#x27;</span>)</span><br></pre></td></tr></table></figure>

<pre><code>\ abc\nabc\tabc</code></pre>
<h4 id="2-03-字符串常用操作方法"><a href="#2-03-字符串常用操作方法" class="headerlink" title="2.03, 字符串常用操作方法:"></a>2.03, 字符串常用操作方法:</h4><p>字符串操作方法都是返回一个原字符串操作后的新字符串, 原字符串不可变</p>
<p>查看字符串方法的详细介绍: <code>str.方法名?</code></p>
<p><strong>find 和 rfind</strong>:<br>查找指定字符串第一次出现的位置(find), 或最后一次出现的位置(rfind), 找到返回其下标索引, 没找到返回 -1, 可以指定查找的开始和结束位置</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">str.find?</span><br></pre></td></tr></table></figure>


<pre><code>[1;31mDocstring:[0m
S.rfind(sub[, start[, end]]) -&gt; int

Return the highest index in S where substring sub is found,
such that sub is contained within S[start:end].  Optional
arguments start and end are interpreted as in slice notation.

Return -1 on failure.
[1;31mType:[0m      method_descriptor</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = <span class="string">&#x27;abcdef&#x27;</span></span><br><span class="line">a.find(<span class="string">&#x27;c&#x27;</span>), a.find(<span class="string">&#x27;cd&#x27;</span>), a.rfind(<span class="string">&#x27;c&#x27;</span>), a.rfind(<span class="string">&#x27;cd&#x27;</span>)</span><br></pre></td></tr></table></figure>




<pre><code>(2, 2, 2, 2)</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a.find(<span class="string">&#x27;a&#x27;</span>, <span class="number">2</span>, <span class="number">4</span>)</span><br></pre></td></tr></table></figure>




<pre><code>-1</code></pre>
<p><strong>index 和 rindex</strong>:<br>和 find, rfind 一样, 只是没找到时报一个异常</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a.index(<span class="string">&#x27;c&#x27;</span>), a.rindex(<span class="string">&#x27;cd&#x27;</span>)</span><br></pre></td></tr></table></figure>




<pre><code>(2, 2)</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a.index(<span class="string">&#x27;ac&#x27;</span>)</span><br></pre></td></tr></table></figure>
<pre><code>---------------------------------------------------------------------------

ValueError                                Traceback (most recent call last)
&lt;ipython-input-61-ddc226c3eb2d&gt; in &lt;module&gt;
----&gt; 1 a.index(&#39;ac&#39;)

ValueError: substring not found</code></pre>
<p><strong>count</strong>:<br>返回指定字符串在指定范围内出现的次数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = <span class="string">&#x27;accbc&#x27;</span></span><br><span class="line">a.count(<span class="string">&#x27;c&#x27;</span>), a.count(<span class="string">&#x27;c&#x27;</span>, <span class="number">2</span>, <span class="number">4</span>) <span class="comment"># 不包含结束</span></span><br></pre></td></tr></table></figure>




<pre><code>(3, 1)</code></pre>
<p><strong>replace</strong>:<br>替换指定字符串为新字符串, 可指定替换次数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a.replace(<span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>), a.replace(<span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="number">2</span>)</span><br></pre></td></tr></table></figure>




<pre><code>(&#39;addbd&#39;, &#39;addbc&#39;)</code></pre>
<p><strong>split 和 rsplit</strong>:<br>以指定字符串内符号将字符串分割于列表中, 返回列表, 可指定分割次数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = <span class="string">&#x27;a-b-c-d-e-f&#x27;</span></span><br><span class="line">a.split(<span class="string">&#x27;-&#x27;</span>, <span class="number">2</span>), a.rsplit(<span class="string">&#x27;-&#x27;</span>, <span class="number">2</span>)</span><br></pre></td></tr></table></figure>




<pre><code>([&#39;a&#39;, &#39;b&#39;, &#39;c-d-e-f&#39;], [&#39;a-b-c-d&#39;, &#39;e&#39;, &#39;f&#39;])</code></pre>
<p><strong>capitalize</strong>:<br>将字符串第一个字母大写, 其余小写, 第一个不是字母则都小写</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = <span class="string">&#x27;aBCd&#x27;</span></span><br><span class="line">b = <span class="string">&#x27;字母ABC&#x27;</span></span><br><span class="line">a.capitalize(), b.capitalize()</span><br></pre></td></tr></table></figure>




<pre><code>(&#39;Abcd&#39;, &#39;字母abc&#39;)</code></pre>
<p><strong>title</strong>:<br>将字符串中在一起的字母第一个大写, 其余的小写</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = <span class="string">&#x27;my name 是aBc不是c&#x27;</span></span><br><span class="line">a.title()</span><br></pre></td></tr></table></figure>




<pre><code>&#39;My Name 是Abc不是C&#39;</code></pre>
<p><strong>startswith 和 endswith</strong>:<br>检查是否以指定字符串开始或结束, 是则返回 True, 否则返回 False, 可指定开始和结束范围</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a.startswith(<span class="string">&#x27;my&#x27;</span>), a.startswith(<span class="string">&#x27;my&#x27;</span>, <span class="number">1</span>), a.startswith(<span class="string">&#x27;na&#x27;</span>, <span class="number">3</span>)</span><br></pre></td></tr></table></figure>




<pre><code>(True, False, True)</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a.endswith(<span class="string">&#x27;name&#x27;</span>, <span class="number">1</span>, <span class="number">7</span>), a.endswith(<span class="string">&#x27;name&#x27;</span>, <span class="number">1</span>, <span class="number">6</span>) <span class="comment"># 不包含结束</span></span><br></pre></td></tr></table></figure>




<pre><code>(True, False)</code></pre>
<p><strong>lower 和 upper</strong>:<br>字母全大写或全小写</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a.lower(), a.upper()</span><br></pre></td></tr></table></figure>




<pre><code>(&#39;my name 是abc不是c&#39;, &#39;MY NAME 是ABC不是C&#39;)</code></pre>
<p><strong>ljust, rjust 和 center</strong>:<br>左对齐, 右对齐或居中, 并填充 <u>指定长度-字符串长度</u> 个指定字符(默认空格)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = <span class="string">&#x27;abc&#x27;</span></span><br><span class="line">a.ljust(<span class="number">4</span>), a.rjust(<span class="number">5</span>, <span class="string">&#x27;是&#x27;</span>), a.center(<span class="number">5</span>,<span class="string">&#x27;*&#x27;</span>)</span><br></pre></td></tr></table></figure>




<pre><code>(&#39;abc &#39;, &#39;是是abc&#39;, &#39;*abc*&#39;)</code></pre>
<p><strong>lstrip, rstrip 和 strip</strong>:<br>删除左边, 右边或两边的指定字符(默认空格符), 中间不能删</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = <span class="string">&#x27; ac bc&#x27;</span></span><br><span class="line">a.lstrip(), a.rstrip(<span class="string">&#x27;c&#x27;</span>), a.strip(<span class="string">&#x27;bc&#x27;</span>)</span><br></pre></td></tr></table></figure>




<pre><code>(&#39;ac bc&#39;, &#39; ac b&#39;, &#39; ac &#39;)</code></pre>
<p><strong>partition 和 rpartition</strong>:<br>将字符串以第一个或最后一个指定字符分割成三个部分于元组中, 返回元组</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = <span class="string">&#x27;abcdcdef&#x27;</span></span><br><span class="line">a.partition(<span class="string">&#x27;c&#x27;</span>), a.rpartition(<span class="string">&#x27;cd&#x27;</span>)</span><br></pre></td></tr></table></figure>




<pre><code>((&#39;ab&#39;, &#39;c&#39;, &#39;dcdef&#39;), (&#39;abcd&#39;, &#39;cd&#39;, &#39;ef&#39;))</code></pre>
<p><strong>splitlines</strong>:<br>按照行分割字符串于列表中, 返回列表, 可包括换行符</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = <span class="string">&quot;&quot;&quot;第一行</span></span><br><span class="line"><span class="string">第二行</span></span><br><span class="line"><span class="string">第三行&quot;&quot;&quot;</span></span><br><span class="line">a.splitlines(), a.splitlines(keepends=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>




<pre><code>([&#39;第一行&#39;, &#39;第二行&#39;, &#39;第三行&#39;], [&#39;第一行\n&#39;, &#39;第二行\n&#39;, &#39;第三行&#39;])</code></pre>
<p><strong>join</strong>:<br>将指定的字符插入到数据容器(iterable)中的每个元素之间并将元素连接成字符串</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = <span class="string">&#x27;.&#x27;</span></span><br><span class="line">b = <span class="string">&#x27;abc&#x27;</span></span><br><span class="line">c = [<span class="string">&#x27;www&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>]</span><br><span class="line">d = (<span class="string">&#x27;www&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>)</span><br><span class="line">a.join(b), a.join(c), a.join(d)</span><br></pre></td></tr></table></figure>




<pre><code>(&#39;a.b.c&#39;, &#39;www.b.c&#39;, &#39;www.b.c&#39;)</code></pre>
<h4 id="2-04-字符串的下标索引和切片操作"><a href="#2-04-字符串的下标索引和切片操作" class="headerlink" title="2.04, 字符串的下标索引和切片操作"></a>2.04, 字符串的下标索引和切片操作</h4><p>字符串的下标索引和切片操作只可以对字符串进行查询, 不可以改变原字符串</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = <span class="string">&#x27;abcdef&#x27;</span></span><br><span class="line">a[<span class="number">1</span>:<span class="number">4</span>]</span><br></pre></td></tr></table></figure>




<pre><code>&#39;bcd&#39;</code></pre>
<h3 id="3-列表-list"><a href="#3-列表-list" class="headerlink" title="3. 列表 list"></a>3. 列表 list</h3><p>用 <code>[]</code> 括号包围元素构成列表, 元素之间用 <code>,</code> 号隔开, 元素可以是各种不同类型, 空列表是 <code>[]</code></p>
<h4 id="3-01-列表的下标索引和切片操作"><a href="#3-01-列表的下标索引和切片操作" class="headerlink" title="3.01, 列表的下标索引和切片操作"></a>3.01, 列表的下标索引和切片操作</h4><p>列表是<strong>有序可变容器</strong>, 可使用下标或切片操作对列表元素进行查询, 修改和删除</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line">a[<span class="number">1</span>], a[<span class="number">1</span>:<span class="number">3</span>]  <span class="comment"># 查找</span></span><br></pre></td></tr></table></figure>




<pre><code>(&#39;b&#39;, [&#39;b&#39;, 1])</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a[<span class="number">1</span>] = <span class="string">&#x27;B&#x27;</span>  <span class="comment"># 修改</span></span><br><span class="line">a</span><br></pre></td></tr></table></figure>




<pre><code>[&#39;a&#39;, &#39;B&#39;, 1, 2]</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">del</span> a[<span class="number">1</span>:<span class="number">3</span>]  <span class="comment"># 删除语句 del</span></span><br><span class="line">a</span><br></pre></td></tr></table></figure>




<pre><code>[&#39;a&#39;, 2]</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">print(<span class="built_in">id</span>(a))</span><br><span class="line">a[<span class="number">0</span>] = <span class="string">&#x27;b&#x27;</span></span><br><span class="line">print(a, <span class="built_in">id</span>(a))  <span class="comment"># 列表修改前后内存地址不变</span></span><br></pre></td></tr></table></figure>

<pre><code>1802200300424
[&#39;b&#39;, 2] 1802200300424</code></pre>
<h4 id="3-02-列表的常用操作方法"><a href="#3-02-列表的常用操作方法" class="headerlink" title="3.02, 列表的常用操作方法"></a>3.02, 列表的常用操作方法</h4><p>列表是可变容器, 需注意对列表的操作方法没有返回值的, 返回值为 None, 操作后, 列表通常发生了改变</p>
<p>查看列表操作方法的详情: <code>list.方法名?</code></p>
<p><strong>append</strong>:<br>在列表后面追加元素(object)</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">list.append?</span><br></pre></td></tr></table></figure>


<pre><code>Signature: list.append(self, object, /)
Docstring: Append object to the end of the list.
Type:      method_descriptor</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = [<span class="string">&#x27;a&#x27;</span>]</span><br><span class="line">b = [<span class="string">&#x27;b&#x27;</span>]</span><br><span class="line">a.append(b)</span><br><span class="line">print(a)</span><br><span class="line">print(a.append(<span class="number">1</span>))</span><br><span class="line">a</span><br></pre></td></tr></table></figure>

<pre><code>[&#39;a&#39;, [&#39;b&#39;]]
None

[&#39;a&#39;, [&#39;b&#39;], 1]</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a.append(a)  <span class="comment"># 追加自身</span></span><br><span class="line">a</span><br></pre></td></tr></table></figure>

<pre><code>[&#39;a&#39;, [&#39;b&#39;], 1, [...]]</code></pre>
<p><strong>extend</strong>:<br>将一个数据容器(iterable)中的元素逐个追加到列表后面</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = [<span class="string">&#x27;a&#x27;</span>]</span><br><span class="line">b = [<span class="string">&#x27;b&#x27;</span>]</span><br><span class="line">c = <span class="string">&#x27;abc&#x27;</span></span><br><span class="line">a.extend(b)</span><br><span class="line">print(a)</span><br><span class="line">a.extend(c)</span><br><span class="line">a</span><br></pre></td></tr></table></figure>

<pre><code>[&#39;a&#39;, &#39;b&#39;]

[&#39;a&#39;, &#39;b&#39;, &#39;a&#39;, &#39;b&#39;, &#39;c&#39;]</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a.extend(a)  <span class="comment"># 追加自身</span></span><br><span class="line">a</span><br></pre></td></tr></table></figure>

<pre><code>[&#39;a&#39;, &#39;b&#39;, &#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;a&#39;, &#39;b&#39;, &#39;a&#39;, &#39;b&#39;, &#39;c&#39;]</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a.extend(<span class="built_in">range</span>(<span class="number">3</span>))</span><br><span class="line">a</span><br></pre></td></tr></table></figure>


<pre><code>[&#39;a&#39;, &#39;b&#39;, &#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;a&#39;, &#39;b&#39;, &#39;a&#39;, &#39;b&#39;, &#39;c&#39;, 0, 1, 2]</code></pre>
<p><strong>insert</strong>:<br>在指定的索引前面插入元素(object)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = [<span class="string">&#x27;a&#x27;</span>]</span><br><span class="line">b = [<span class="string">&#x27;b&#x27;</span>]</span><br><span class="line">a.insert(<span class="number">1</span>, b)  <span class="comment"># 超出索引范围则在最后插入</span></span><br><span class="line">a</span><br></pre></td></tr></table></figure>


<pre><code>[&#39;a&#39;, [&#39;b&#39;]]</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a.insert(<span class="number">1</span>, a)  <span class="comment"># 插入自身</span></span><br><span class="line">a</span><br></pre></td></tr></table></figure>




<pre><code>[&#39;a&#39;, [...], [&#39;b&#39;]]</code></pre>
<p><strong>index</strong>:<br>返回第一个指定元素的索引值, 可指定开始和结束范围</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>]</span><br><span class="line">a.index(<span class="string">&#x27;b&#x27;</span>), a.index(<span class="string">&#x27;b&#x27;</span>, <span class="number">2</span>, <span class="number">4</span>)</span><br></pre></td></tr></table></figure>




<pre><code>(1, 2)</code></pre>
<p><strong>count</strong>:<br>统计指定元素在列表中的数量</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a.count(<span class="string">&#x27;b&#x27;</span>)</span><br></pre></td></tr></table></figure>




<pre><code>2</code></pre>
<p><strong>pop</strong>:<br>删除指定位置的元素(默认最后一个)并返回删除元素</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a.pop(), a.pop(<span class="number">1</span>), a</span><br></pre></td></tr></table></figure>




<pre><code>(&#39;c&#39;, &#39;b&#39;, [&#39;a&#39;, &#39;b&#39;])</code></pre>
<p><strong>remove</strong>:<br>删除指定元素</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a.remove(<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">a</span><br></pre></td></tr></table></figure>




<pre><code>[&#39;b&#39;]</code></pre>
<p><strong>sort</strong>:<br>对列表排序, 可以指定排序规则(默认字母或数字顺序, 排序规则可自定义), 升序(默认)或降序</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = [<span class="string">&#x27;abac&#x27;</span>, <span class="string">&#x27;cd&#x27;</span>, <span class="string">&#x27;bef&#x27;</span>]</span><br><span class="line">b = [<span class="number">3</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line">a.sort()</span><br><span class="line">b.sort(reverse=<span class="literal">True</span>)</span><br><span class="line">a, b</span><br></pre></td></tr></table></figure>




<pre><code>([&#39;abac&#39;, &#39;bef&#39;, &#39;cd&#39;], [5, 3, 2, 1])</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a.sort(key=<span class="built_in">len</span>)  <span class="comment"># 按字符串长度排序</span></span><br><span class="line">a</span><br></pre></td></tr></table></figure>




<pre><code>[&#39;cd&#39;, &#39;bef&#39;, &#39;abac&#39;]</code></pre>
<p><strong>sorted</strong>:<br>将一个数据容器(iterable)排序后, 以列表形式返回, 不改变原容器, 可以指定排序规则(默认字母或数字顺序, 排序规则可自定义), 升序(默认)或降序</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = <span class="string">&#x27;cn da&#x27;</span></span><br><span class="line">b = [<span class="number">1</span>, <span class="number">4</span>, <span class="number">3</span>]</span><br><span class="line"><span class="built_in">sorted</span>(a), <span class="built_in">sorted</span>(b), b</span><br></pre></td></tr></table></figure>




<pre><code>([&#39; &#39;, &#39;a&#39;, &#39;c&#39;, &#39;d&#39;, &#39;n&#39;], [1, 3, 4], [1, 4, 3])</code></pre>
<p><strong>reverse</strong>:<br>将列表逆置</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = [<span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line">a.reverse()</span><br><span class="line">a</span><br></pre></td></tr></table></figure>




<pre><code>[2, 1, 3]</code></pre>
<h3 id="4-元组-tuple"><a href="#4-元组-tuple" class="headerlink" title="4, 元组 tuple"></a>4, 元组 tuple</h3><p>元组用 <code>()</code> 括号包围元素组成, 元素之间用 <code>,</code> 号隔开, 空元组就是 <code>()</code></p>
<p>元组是<strong>有序不可变容器</strong>, 因为不可变, 用元组存储数据更安全, 也是因为不可变, 元组不能进行元素的增删改, 但可进行查询</p>
<p>小括号 <code>()</code> 里只有一个元素时, 小括号是数学运算符, 因此必须在元素后加 <code>,</code> 号才是元组类型</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">type</span>(([<span class="number">1</span>, <span class="number">2</span>]))</span><br></pre></td></tr></table></figure>




<pre><code>list</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">type</span>(([<span class="number">1</span>, <span class="number">2</span>],))</span><br></pre></td></tr></table></figure>




<pre><code>tuple</code></pre>
<p>通常多个元素用逗号 <code>,</code> 隔开排在一起, 是一个元组类型</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>, <span class="number">3</span>, [<span class="number">1</span>, <span class="number">2</span>]</span><br></pre></td></tr></table></figure>




<pre><code>(1, 3, [1, 2])</code></pre>
<p>元组可以利用下标索引和切片进行元素查询, 元组本身不可变, 但是如果元组中的元素是可变对象, 可对该元素进行增删改</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = (<span class="number">1</span>, <span class="number">2</span>, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line">a[<span class="number">1</span>:]</span><br></pre></td></tr></table></figure>




<pre><code>(2, [1, 2, 3])</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a[<span class="number">2</span>][<span class="number">1</span>]</span><br></pre></td></tr></table></figure>




<pre><code>2</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a[<span class="number">2</span>][<span class="number">1</span>] = <span class="string">&#x27;a&#x27;</span></span><br><span class="line">a</span><br></pre></td></tr></table></figure>




<pre><code>(1, 2, [1, &#39;a&#39;, 3])</code></pre>
<p>元组的方法 <code>index</code> 和 <code>count</code>, 使用和列表一样</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a.index(<span class="number">1</span>)</span><br></pre></td></tr></table></figure>




<pre><code>0</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a.count(<span class="number">1</span>)</span><br></pre></td></tr></table></figure>




<pre><code>1</code></pre>
<p>元组, 列表, 字符串的 + 和 *</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">(<span class="number">1</span>, <span class="number">2</span>) + (<span class="number">1</span>, <span class="number">3</span>), (<span class="number">1</span>, <span class="number">2</span>)*<span class="number">2</span></span><br></pre></td></tr></table></figure>




<pre><code>((1, 2, 1, 3), (1, 2, 1, 2))</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">3</span>] + [<span class="number">2</span>], [<span class="number">1</span>, <span class="number">2</span>]*<span class="number">2</span></span><br></pre></td></tr></table></figure>




<pre><code>([1, 3, 2], [1, 2, 1, 2])</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;13&#x27;</span> + <span class="string">&#x27;2&#x27;</span>, <span class="string">&#x27;12&#x27;</span>*<span class="number">2</span></span><br></pre></td></tr></table></figure>




<pre><code>(&#39;132&#39;, &#39;1212&#39;)</code></pre>
<h3 id="5-字典-dict"><a href="#5-字典-dict" class="headerlink" title="5, 字典 dict"></a>5, 字典 dict</h3><p>字典中每个元素都必须是 <code>键:值</code> 对, 然后由 <code>&#123;&#125;</code> 括号包围, 每个元素之间 <code>,</code> 号隔开, 空字典是 <code>&#123;&#125;</code></p>
<p>字典是<strong>无序可变容器</strong>, 字典中的元素可变, 但是每个元素 <code>键</code> 是唯一不可变的, 所以不能用可变对象(例如列表)做 <code>键</code>, 一个键对应一个值</p>
<p>因为无序, 所以没有下标索引和切片操作, 但可根据键进行字典的增, 删, 改, 查</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = &#123;<span class="string">&#x27;a&#x27;</span>: <span class="number">1</span>, <span class="number">2</span>: <span class="string">&#x27;ab&#x27;</span>&#125;</span><br><span class="line">a[<span class="string">&#x27;b&#x27;</span>] = <span class="number">12</span>  <span class="comment"># 增元素</span></span><br><span class="line">a</span><br></pre></td></tr></table></figure>




<pre><code>&#123;&#39;a&#39;: 1, 2: &#39;ab&#39;, &#39;b&#39;: 12&#125;</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">del</span> a[<span class="string">&#x27;b&#x27;</span>]  <span class="comment"># 删元素 , 可以删除整个字典</span></span><br><span class="line">a</span><br></pre></td></tr></table></figure>




<pre><code>&#123;&#39;a&#39;: 1, 2: &#39;ab&#39;&#125;</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a[<span class="string">&#x27;a&#x27;</span>] = [<span class="number">1</span>, <span class="number">2</span>]  <span class="comment"># 改值</span></span><br><span class="line">a</span><br></pre></td></tr></table></figure>




<pre><code>&#123;&#39;a&#39;: [1, 2], 2: &#39;ab&#39;&#125;</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a[<span class="string">&#x27;a&#x27;</span>], a[<span class="number">2</span>] <span class="comment"># 查值</span></span><br></pre></td></tr></table></figure>




<pre><code>([1, 2], &#39;ab&#39;)</code></pre>
<h4 id="5-01-字典方法"><a href="#5-01-字典方法" class="headerlink" title="5.01, 字典方法"></a>5.01, 字典方法</h4><p>查看字典方法详情: <code>dict.方法名?</code></p>
<p><strong>clear</strong>:<br>清空字典</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = &#123;<span class="number">1</span>:<span class="string">&#x27;a&#x27;</span>&#125;</span><br><span class="line">a.clear()</span><br><span class="line">a</span><br></pre></td></tr></table></figure>




<pre><code>&#123;&#125;</code></pre>
<p><strong>fromkeys</strong>:<br>传入一个数据容器(iterable)创建一个指定键, 相同值(默认是 None)的字典</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">dict</span>.fromkeys(<span class="string">&#x27;abc&#x27;</span>, <span class="number">1</span>)</span><br></pre></td></tr></table></figure>




<pre><code>&#123;&#39;a&#39;: 1, &#39;b&#39;: 1, &#39;c&#39;: 1&#125;</code></pre>
<p><strong>get</strong>:<br>返回指定键的值, 如果不存在, 返回 None</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = &#123;<span class="number">1</span>: <span class="string">&#x27;a&#x27;</span>, <span class="number">2</span>: <span class="string">&#x27;b&#x27;</span>&#125;</span><br><span class="line">a.get(<span class="number">1</span>), a.get(<span class="number">3</span>)</span><br></pre></td></tr></table></figure>




<pre><code>(&#39;a&#39;, None)</code></pre>
<p><strong>keys</strong>:<br>返回一个包含所有键的数据容器(dict_keys 类型)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a.keys(), <span class="built_in">type</span>(a.keys())</span><br></pre></td></tr></table></figure>




<pre><code>(dict_keys([1, 2]), dict_keys)</code></pre>
<p><strong>items</strong>:<br>返回一个将所有 <code>键:值</code> 对变成 <code>(键, 值)</code> 元组的数据容器(dict_items 类型)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a.items()</span><br></pre></td></tr></table></figure>




<pre><code>dict_items([(1, &#39;a&#39;), (2, &#39;b&#39;)])</code></pre>
<p><strong>values</strong>:<br>返回一个包含所有值的数据容器(dict_values 类型)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a.values()</span><br></pre></td></tr></table></figure>




<pre><code>dict_values([&#39;a&#39;, &#39;b&#39;])</code></pre>
<p><strong>setdefault</strong>:<br>和 get 类似, 但当键不存在时, 将添加键并设置值(默认为 None)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a.setdefault(<span class="number">3</span>)</span><br><span class="line">a</span><br></pre></td></tr></table></figure>




<pre><code>&#123;1: &#39;a&#39;, 2: &#39;b&#39;, 3: None&#125;</code></pre>
<p><strong>update</strong>:<br>字典中更新或添加元素</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = &#123;<span class="string">&#x27;a&#x27;</span>: <span class="number">1</span>&#125;</span><br><span class="line">b = &#123;<span class="string">&#x27;a&#x27;</span>: <span class="number">2</span>&#125;</span><br><span class="line">a.update(b)</span><br><span class="line">a</span><br></pre></td></tr></table></figure>




<pre><code>&#123;&#39;a&#39;: 2&#125;</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">c = [(<span class="number">1</span>, <span class="number">2</span>), (<span class="number">2</span>, <span class="number">3</span>)]</span><br><span class="line">a.update(c)</span><br><span class="line">a</span><br></pre></td></tr></table></figure>




<pre><code>&#123;&#39;a&#39;: 2, 1: 2, 2: 3&#125;</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">d = ([<span class="number">3</span>, <span class="number">2</span>], [<span class="number">4</span>, <span class="number">3</span>])</span><br><span class="line">a.update(d)</span><br><span class="line">a</span><br></pre></td></tr></table></figure>




<pre><code>&#123;&#39;a&#39;: 2, 1: 2, 2: 3, 3: 2, 4: 3&#125;</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">e = <span class="built_in">zip</span>([<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>], [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line">a.update(e)</span><br><span class="line">a</span><br></pre></td></tr></table></figure>




<pre><code>&#123;&#39;a&#39;: 2, 1: 2, 2: 3, 3: 2, 4: 3, 5: 1, 6: 2, 7: 3&#125;</code></pre>
<p><strong>pop</strong>:<br>删除指定键对应的元素, 返回元素的值, 如果键不存在, 返回指定对象, 不指定则报错</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a.pop(<span class="string">&#x27;a&#x27;</span>)</span><br></pre></td></tr></table></figure>




<pre><code>2</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a.pop(<span class="string">&#x27;b&#x27;</span>, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br></pre></td></tr></table></figure>




<pre><code>[1, 2, 3]</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a.pop(<span class="string">&#x27;b&#x27;</span>)</span><br></pre></td></tr></table></figure>


<pre><code>---------------------------------------------------------------------------

KeyError                                  Traceback (most recent call last)

&lt;ipython-input-7-f3b7e84d9f82&gt; in &lt;module&gt;
----&gt; 1 a.pop(&#39;b&#39;)


KeyError: &#39;b&#39;</code></pre>
<p><strong>popitem</strong>:<br>删除字典最后一个元素, 以 (键, 值) 元组形式返回, 字典为空时报错</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = &#123;<span class="number">1</span>:<span class="number">3</span>&#125;</span><br><span class="line">a.popitem()</span><br></pre></td></tr></table></figure>




<pre><code>(1, 3)</code></pre>
<h3 id="6-集合-set"><a href="#6-集合-set" class="headerlink" title="6, 集合 set"></a>6, 集合 set</h3><p>集合是<strong>无序可变容器</strong>, 由 <code>&#123;&#125;</code> 括号包围元素构成, 元素之间 <code>,</code> 号隔开且无重复元素, 创建集合必须使用 <code>set()</code> 方法传入数据容器, 不传就是空集合 <code>set()</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = <span class="built_in">set</span>([<span class="number">1</span>, <span class="number">3</span>, <span class="number">1</span>])</span><br><span class="line">b = <span class="built_in">set</span>(<span class="string">&#x27;abca&#x27;</span>)</span><br><span class="line">a, b</span><br></pre></td></tr></table></figure>




<pre><code>(&#123;1, 3&#125;, &#123;&#39;a&#39;, &#39;b&#39;, &#39;c&#39;&#125;)</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">bool</span>(<span class="built_in">set</span>())</span><br></pre></td></tr></table></figure>




<pre><code>False</code></pre>
<p>集合方法(不做详细介绍):</p>
<p>add    为集合添加元素</p>
<p>clear    移除集合中的所有元素</p>
<p>copy    拷贝一个集合</p>
<p>difference    返回多个集合的差集</p>
<p>difference_update    移除集合中的元素，该元素在指定的集合也存在</p>
<p>discard    删除集合中指定的元素</p>
<p>intersection    返回集合的交集</p>
<p>intersection_update    返回集合的交集</p>
<p>isdisjoint    判断两个集合是否包含相同的元素，如果没有返回 True，否则返回 False</p>
<p>issubset    判断指定集合是否为该方法参数集合的子集</p>
<p>issuperset    判断该方法的参数集合是否为指定集合的子集</p>
<p>pop    随机移除元素</p>
<p>remove    移除指定元素</p>
<p>symmetric_difference    返回两个集合中不重复的元素集合</p>
<p>symmetric_difference_update    移除当前集合中在另外一个指定集合相同的元素，并将另外一个指定集合中不同的元素插入到当前集合中</p>
<p>union    返回两个集合的并集</p>
<p>update    给集合添加元素</p>
<h3 id="7-range"><a href="#7-range" class="headerlink" title="7, range"></a>7, range</h3><p><code>range</code> 生成一个整数组成的数据容器(range 类型), 生成格式: <code>range(起始, 结束, 步长)</code>, 不包括 <code>结束</code>,  <code>起始</code>(默认0) 和 <code>步长</code>(默认1) 可以省略, <code>range</code> 常用来控制循环次数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">range</span>(<span class="number">9</span>)</span><br></pre></td></tr></table></figure>




<pre><code>range(0, 9)</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">3</span>, <span class="number">1</span>, <span class="number">-1</span>)) <span class="comment"># 步长为负数时, 起始要比结束大</span></span><br></pre></td></tr></table></figure>




<pre><code>[3, 2]</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">3</span>,<span class="number">-5</span>, <span class="number">-2</span>))</span><br></pre></td></tr></table></figure>




<pre><code>[3, 1, -1, -3]</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">    print(<span class="string">&#x27;您好&#x27;</span>)</span><br></pre></td></tr></table></figure>

<pre><code>您好
您好
您好</code></pre>
<h3 id="8-数据容器统计和遍历"><a href="#8-数据容器统计和遍历" class="headerlink" title="8, 数据容器统计和遍历"></a>8, 数据容器统计和遍历</h3><p>数据容器的统计和遍历, 只有字典比较特殊, 需要指定统计或遍历<code>键</code>还是<code>值</code>(默认是<code>键</code>)</p>
<p><strong>统计</strong>:</p>
<p>len 方法, 统计各种容器中元素个数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = <span class="string">&#x27;abcd&#x27;</span></span><br><span class="line">b = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line">c = <span class="built_in">dict</span>(one=<span class="number">1</span>, two=<span class="number">2</span>)</span><br><span class="line">d = <span class="built_in">range</span>(<span class="number">3</span>)</span><br><span class="line"><span class="built_in">len</span>(a), <span class="built_in">len</span>(b), <span class="built_in">len</span>(c), <span class="built_in">len</span>(d)</span><br></pre></td></tr></table></figure>




<pre><code>(4, 4, 2, 3)</code></pre>
<p>max, min 最大最小</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">max</span>(a), <span class="built_in">min</span>(b), <span class="built_in">max</span>(c.values()), <span class="built_in">min</span>(<span class="built_in">range</span>(<span class="number">3</span>))</span><br></pre></td></tr></table></figure>




<pre><code>(&#39;d&#39;, 1, 2, 0)</code></pre>
<p>sum 求和, 只能是数值</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sum</span>(b), <span class="built_in">sum</span>(c.values()), <span class="built_in">sum</span>(d)</span><br></pre></td></tr></table></figure>




<pre><code>(10, 3, 3)</code></pre>
<p>any, all 任何一个元素或全部元素为真, 返回 True, 否则 False</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = [<span class="number">1</span>, <span class="number">2</span>, <span class="string">&#x27;&#x27;</span>]</span><br><span class="line">b = &#123;<span class="number">1</span>: <span class="string">&#x27;a&#x27;</span>, <span class="number">2</span>: <span class="literal">None</span>&#125;</span><br><span class="line"><span class="built_in">any</span>(a), <span class="built_in">all</span>(a), <span class="built_in">all</span>(b), <span class="built_in">all</span>(b.values())</span><br></pre></td></tr></table></figure>




<pre><code>(True, False, True, False)</code></pre>
<p><strong>遍历和列表生成式</strong>:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = <span class="string">&#x27;abc&#x27;</span></span><br><span class="line">b = (<span class="number">1</span>, <span class="number">2</span>, [<span class="number">1</span>, <span class="number">2</span>])</span><br><span class="line">c = &#123;<span class="string">&#x27;a&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;b&#x27;</span>: [<span class="number">1</span>, <span class="number">2</span>]&#125;</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> a:</span><br><span class="line">    print(i, end=<span class="string">&#x27; &#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> b:</span><br><span class="line">    print(i, end=<span class="string">&#x27; &#x27;</span>)</span><br></pre></td></tr></table></figure>

<pre><code>a b c 1 2 [1, 2] </code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> c:</span><br><span class="line">    print(i)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> c.values():</span><br><span class="line">    print(i)</span><br><span class="line"><span class="keyword">for</span> i, j <span class="keyword">in</span> c.items():</span><br><span class="line">    print(i, j)</span><br></pre></td></tr></table></figure>

<pre><code>a
b
1
[1, 2]
a 1
b [1, 2]</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[(i,j) <span class="keyword">for</span> i <span class="keyword">in</span> a <span class="keyword">for</span> j <span class="keyword">in</span> b]</span><br></pre></td></tr></table></figure>




<pre><code>[(&#39;a&#39;, 1),
 (&#39;a&#39;, 2),
 (&#39;a&#39;, [1, 2]),
 (&#39;b&#39;, 1),
 (&#39;b&#39;, 2),
 (&#39;b&#39;, [1, 2]),
 (&#39;c&#39;, 1),
 (&#39;c&#39;, 2),
 (&#39;c&#39;, [1, 2])]</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[<span class="string">&#x27;L-&#x27;</span> + i <span class="keyword">for</span> i <span class="keyword">in</span> a]</span><br></pre></td></tr></table></figure>




<pre><code>[&#39;L-a&#39;, &#39;L-b&#39;, &#39;L-c&#39;]</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[(j, k) <span class="keyword">for</span> j, k <span class="keyword">in</span> c.items()]</span><br></pre></td></tr></table></figure>




<pre><code>[(&#39;a&#39;, 1), (&#39;b&#39;, [1, 2])]</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[i**<span class="number">2</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>) <span class="keyword">if</span> i &gt;= <span class="number">5</span>]</span><br></pre></td></tr></table></figure>




<pre><code>[25, 36, 49, 64, 81]</code></pre>
<br>
]]></content>
      <categories>
        <category>数据分析</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>处理和计算函数</title>
    <url>/data/pandas2-467dbcb23e38/</url>
    <content><![CDATA[<blockquote>
<p>pandas 是 Python 的核心数据分析支持库, 基于 NumPy 创建, 它使 python 成为强大而高效的数据分析环境 </p>
</blockquote>
<blockquote>
<p>pandas 基础最重要知识点就是两个数据结构 Series(一维) 和 DataFrame(二维), 处理这两个数据结构的方法和函数, 以及运用的逻辑</p>
</blockquote>
<blockquote>
<p>下文约定 NumPy 简写 <code>np</code>, Pandas 简写 <code>pd</code>, Series 简写 <code>s</code>, DataFrame 简写 <code>df</code></p>
</blockquote>
<h2 id="三-s-和-df-的处理和计算函数"><a href="#三-s-和-df-的处理和计算函数" class="headerlink" title="三, s 和 df 的处理和计算函数"></a>三, s 和 df 的处理和计算函数</h2><h3 id="1-索引"><a href="#1-索引" class="headerlink" title="1, 索引"></a>1, 索引</h3><p>在 pd 里, 索引非常重要, 一个行索引, 通常就是数据的一条记录(例如一个人的信息), 一个列索引就是数据的一个特征(例如某个人的性别, 年龄等), 通过索引能够更方便数据处理与计算</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line">s = pd.Series(np.random.rand(<span class="number">4</span>), index=<span class="built_in">list</span>(<span class="string">&#x27;abcd&#x27;</span>))</span><br><span class="line">df = pd.DataFrame(np.random.rand(<span class="number">4</span>, <span class="number">4</span>),</span><br><span class="line">                  index=<span class="built_in">list</span>(<span class="string">&#x27;abcd&#x27;</span>),</span><br><span class="line">                  columns=<span class="built_in">list</span>(<span class="string">&#x27;ABCD&#x27;</span>))</span><br><span class="line">s, df</span><br></pre></td></tr></table></figure>




<pre><code>(a    0.081048
 b    0.075218
 c    0.339713
 d    0.103027
 dtype: float64,
           A         B         C         D
 a  0.752838  0.858899  0.779652  0.390347
 b  0.727027  0.518987  0.356425  0.154784
 c  0.134500  0.115313  0.994597  0.236809
 d  0.259354  0.624735  0.430290  0.282564)</code></pre>
<p><strong>reindex 索引重排, 新增的索引 nan 填充, 缺少索引的数据舍弃</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 新增 e 舍弃 d, 有许多参数可以调节</span></span><br><span class="line">s.reindex(<span class="built_in">list</span>(<span class="string">&#x27;bcae&#x27;</span>)), df.reindex(columns=<span class="built_in">list</span>(<span class="string">&#x27;BCAE&#x27;</span>))</span><br></pre></td></tr></table></figure>




<pre><code>(b    0.719566
 c    0.997383
 a    0.702877
 e         NaN
 dtype: float64,
           B         C         A   E
 a  0.260505  0.112192  0.661345 NaN
 b  0.419849  0.335675  0.840509 NaN
 c  0.211215  0.542169  0.751707 NaN
 d  0.310829  0.019690  0.859212 NaN)</code></pre>
<p><strong>sort_index 索引排序</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 默认 True 升序, 许多参数可调, df 只排行索引</span></span><br><span class="line">s.sort_index(ascending=<span class="literal">False</span>), df.sort_index(ascending=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure>




<pre><code>(d    0.182391
 c    0.387592
 b    0.457121
 a    0.637088
 dtype: float64,
           A         B         C         D
 d  0.729718  0.406537  0.248429  0.837150
 c  0.527112  0.646597  0.956364  0.444216
 b  0.232444  0.790157  0.504928  0.728113
 a  0.693281  0.805136  0.185669  0.737717)</code></pre>
<p><strong>rename, set_index, reset_index 设置索引</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 注意参数及传参方式</span></span><br><span class="line">s.rename(index=&#123;<span class="string">&#x27;a&#x27;</span>: <span class="string">&#x27;f&#x27;</span>&#125;), df.rename(<span class="keyword">lambda</span> x: x + x)</span><br></pre></td></tr></table></figure>




<pre><code>(f    0.637088
 b    0.457121
 c    0.387592
 d    0.182391
 dtype: float64,
            A         B         C         D
 aa  0.693281  0.805136  0.185669  0.737717
 bb  0.232444  0.790157  0.504928  0.728113
 cc  0.527112  0.646597  0.956364  0.444216
 dd  0.729718  0.406537  0.248429  0.837150)</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># s 没有此方法, 可以将某列设为索引, 默认不保留原列, 可设参数 drop 保留</span></span><br><span class="line">df1 = df.set_index([[<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;d&#x27;</span>], [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]])</span><br><span class="line">df2 = df.set_index(<span class="string">&#x27;A&#x27;</span>)</span><br><span class="line">df1, df2</span><br></pre></td></tr></table></figure>




<pre><code>(            A         B         C         D
 a 1  0.752838  0.858899  0.779652  0.390347
 b 2  0.727027  0.518987  0.356425  0.154784
 c 3  0.134500  0.115313  0.994597  0.236809
 d 4  0.259354  0.624735  0.430290  0.282564,
                  B         C         D
 A                                     
 0.752838  0.858899  0.779652  0.390347
 0.727027  0.518987  0.356425  0.154784
 0.134500  0.115313  0.994597  0.236809
 0.259354  0.624735  0.430290  0.282564)</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 将索引设为列(drop=True将其删除), 多层索引时可选某层</span></span><br><span class="line">df1.reset_index(level=<span class="number">1</span>), df2.reset_index()</span><br></pre></td></tr></table></figure>




<pre><code>(   level_1         A         B         C         D
 a        1  0.693281  0.805136  0.185669  0.737717
 b        2  0.232444  0.790157  0.504928  0.728113
 c        3  0.527112  0.646597  0.956364  0.444216
 d        4  0.729718  0.406537  0.248429  0.837150,
           A         B         C         D
 0  0.693281  0.805136  0.185669  0.737717
 1  0.232444  0.790157  0.504928  0.728113
 2  0.527112  0.646597  0.956364  0.444216
 3  0.729718  0.406537  0.248429  0.837150)</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 索引可以设置名字, 设置索引还可以通过获取索引重新赋值</span></span><br><span class="line"><span class="comment"># df 还可以转置</span></span><br><span class="line">print(df2.index.name)</span><br><span class="line">df2.index = <span class="built_in">list</span>(<span class="string">&#x27;abcd&#x27;</span>) <span class="comment"># 重设索引后, 索引名消失</span></span><br><span class="line">df2, df2.T</span><br></pre></td></tr></table></figure>

<pre><code>A





(          B         C         D
 a  0.858899  0.779652  0.390347
 b  0.518987  0.356425  0.154784
 c  0.115313  0.994597  0.236809
 d  0.624735  0.430290  0.282564,
           a         b         c         d
 B  0.858899  0.518987  0.115313  0.624735
 C  0.779652  0.356425  0.994597  0.430290
 D  0.390347  0.154784  0.236809  0.282564)</code></pre>
<p><strong>多层索引</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">ar = [[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>], [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]]</span><br><span class="line">tup = <span class="built_in">list</span>(<span class="built_in">zip</span>(*ar))</span><br><span class="line">pd.MultiIndex.from_tuples(tup)</span><br></pre></td></tr></table></figure>




<pre><code>MultiIndex([(&#39;a&#39;, 1),
            (&#39;b&#39;, 2),
            (&#39;c&#39;, 3)],
           )</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">index = pd.MultiIndex.from_product(ar)</span><br><span class="line">s = pd.Series(<span class="built_in">range</span>(<span class="number">9</span>), index=index)</span><br><span class="line">s</span><br></pre></td></tr></table></figure>




<pre><code>a  1    0
   2    1
   3    2
b  1    3
   2    4
   3    5
c  1    6
   2    7
   3    8
dtype: int64</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pd.MultiIndex.from_frame(df2[[<span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>]])</span><br></pre></td></tr></table></figure>




<pre><code>MultiIndex([( 0.8588989323584892,  0.7796522836753877),
            ( 0.5189870245469372,  0.3564252746188795),
            (0.11531289701355718,  0.9945971753660031),
            (  0.624734777956396, 0.43029040226834503)],
           names=[&#39;B&#39;, &#39;C&#39;])</code></pre>
<h3 id="2-增删与合并数据"><a href="#2-增删与合并数据" class="headerlink" title="2, 增删与合并数据"></a>2, 增删与合并数据</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line">df = pd.DataFrame(np.random.randint(<span class="number">1</span>, <span class="number">9</span>, (<span class="number">4</span>, <span class="number">5</span>)))</span><br><span class="line">print(df)</span><br></pre></td></tr></table></figure>

<pre><code>   0  1  2  3  4
0  8  5  1  6  2
1  6  5  1  6  8
2  7  5  5  4  6
3  2  1  3  6  1</code></pre>
<p><strong>insert 在指定位置前插入数据</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># s 没有该方法</span></span><br><span class="line">df.insert(<span class="number">2</span>, <span class="string">&#x27;A&#x27;</span>, <span class="number">1</span>)</span><br><span class="line">print(df)</span><br></pre></td></tr></table></figure>

<pre><code>   0  1  A  2  3  4
0  8  5  1  1  6  2
1  6  5  1  1  6  8
2  7  5  1  5  4  6
3  2  1  1  3  6  1</code></pre>
<p><strong>append 在数据最后增加数据</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># s 只能传 s</span></span><br><span class="line">df1 = pd.DataFrame(&#123;<span class="string">&#x27;B&#x27;</span>: [<span class="number">1</span>, <span class="number">2</span>]&#125;)</span><br><span class="line"><span class="comment"># df 可以在行后面增加, 也可在列后面新增</span></span><br><span class="line">df.iloc[<span class="number">0</span>].append(pd.Series(<span class="number">8</span>))</span><br><span class="line">df.append([<span class="number">1</span>]), df.append(df1, ignore_index=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>




<pre><code>(   0    1    A    2    3    4
 0  8  5.0  1.0  1.0  6.0  2.0
 1  6  5.0  1.0  1.0  6.0  8.0
 2  7  5.0  1.0  5.0  4.0  6.0
 3  2  1.0  1.0  3.0  6.0  1.0
 0  1  NaN  NaN  NaN  NaN  NaN,
      0    1    A    2    3    4    B
 0  8.0  5.0  1.0  1.0  6.0  2.0  NaN
 1  6.0  5.0  1.0  1.0  6.0  8.0  NaN
 2  7.0  5.0  1.0  5.0  4.0  6.0  NaN
 3  2.0  1.0  1.0  3.0  6.0  1.0  NaN
 4  NaN  NaN  NaN  NaN  NaN  NaN  1.0
 5  NaN  NaN  NaN  NaN  NaN  NaN  2.0)</code></pre>
<p><strong>drop 删除指定数据</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df[<span class="string">&#x27;A&#x27;</span>].drop(<span class="number">1</span>), df.drop(<span class="number">1</span>, axis=<span class="number">1</span>)</span><br></pre></td></tr></table></figure>




<pre><code>(0    1
 2    1
 3    1
 Name: A, dtype: int64,
    0  A  2  3  4
 0  8  1  1  6  2
 1  6  1  1  6  8
 2  7  1  5  4  6
 3  2  1  3  6  1)</code></pre>
<p><strong>concat 合并数据</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df1 = pd.DataFrame(np.random.randint(<span class="number">1</span>, <span class="number">3</span>, (<span class="number">4</span>, <span class="number">4</span>)),</span><br><span class="line">                   index=<span class="built_in">list</span>(<span class="string">&#x27;abcd&#x27;</span>), columns=<span class="built_in">list</span>(<span class="string">&#x27;ABCD&#x27;</span>))</span><br><span class="line">df2 = pd.DataFrame(np.random.randint(<span class="number">1</span>, <span class="number">3</span>, (<span class="number">4</span>, <span class="number">4</span>)),</span><br><span class="line">                   index=<span class="built_in">list</span>(<span class="string">&#x27;abef&#x27;</span>), columns=<span class="built_in">list</span>(<span class="string">&#x27;ABEF&#x27;</span>))</span><br><span class="line">df1, df2</span><br></pre></td></tr></table></figure>




<pre><code>(   A  B  C  D
 a  2  2  1  2
 b  2  1  1  2
 c  2  1  2  2
 d  1  1  2  2,
    A  B  E  F
 a  2  1  1  1
 b  1  2  1  1
 e  2  1  1  2
 f  2  2  2  1)</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 默认按列索引合并, 保留合并后的全部索引, 缺失用 nan 填充</span></span><br><span class="line"><span class="comment"># join 参数可控制合并的方式: inner 只留下都有的索引</span></span><br><span class="line">pd.concat([df1, df2]), pd.concat([df1, df2], join=<span class="string">&#x27;inner&#x27;</span>)</span><br></pre></td></tr></table></figure>




<pre><code>(   A  B    C    D    E    F
 a  2  2  1.0  2.0  NaN  NaN
 b  2  1  1.0  2.0  NaN  NaN
 c  2  1  2.0  2.0  NaN  NaN
 d  1  1  2.0  2.0  NaN  NaN
 a  2  1  NaN  NaN  1.0  1.0
 b  1  2  NaN  NaN  1.0  1.0
 e  2  1  NaN  NaN  1.0  2.0
 f  2  2  NaN  NaN  2.0  1.0,
    A  B
 a  2  2
 b  2  1
 c  2  1
 d  1  1
 a  2  1
 b  1  2
 e  2  1
 f  2  2)</code></pre>
<p><strong>join 主要用于行索引的合并</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 默认以左边(df1)为基准, 相同列名需要加以区分</span></span><br><span class="line"><span class="comment"># how 参数: outer 全保留, inner 只保留共同部分</span></span><br><span class="line">df1.join(df2, lsuffix=<span class="string">&#x27;_1&#x27;</span>, rsuffix=<span class="string">&#x27;_2&#x27;</span>), df1.join(df2, how=<span class="string">&#x27;outer&#x27;</span>, lsuffix=<span class="string">&#x27;_1&#x27;</span>, rsuffix=<span class="string">&#x27;_2&#x27;</span>)</span><br></pre></td></tr></table></figure>




<pre><code>(   A_1  B_1  C  D  A_2  B_2    E    F
 a    2    2  1  2  2.0  1.0  1.0  1.0
 b    2    1  1  2  1.0  2.0  1.0  1.0
 c    2    1  2  2  NaN  NaN  NaN  NaN
 d    1    1  2  2  NaN  NaN  NaN  NaN,
    A_1  B_1    C    D  A_2  B_2    E    F
 a  2.0  2.0  1.0  2.0  2.0  1.0  1.0  1.0
 b  2.0  1.0  1.0  2.0  1.0  2.0  1.0  1.0
 c  2.0  1.0  2.0  2.0  NaN  NaN  NaN  NaN
 d  1.0  1.0  2.0  2.0  NaN  NaN  NaN  NaN
 e  NaN  NaN  NaN  NaN  2.0  1.0  1.0  2.0
 f  NaN  NaN  NaN  NaN  2.0  2.0  2.0  1.0)</code></pre>
<p><strong>merge 主要用于内容的合并, 常用于两者有相同内容的列</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 默认 inner, 全部列都保留, </span></span><br><span class="line"><span class="comment"># 但只保留两者都有的列内容相同的行, 且行索引都舍弃</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 可以选择以某一个为基准, 需要合并的列内容, 以及保留某一个的索引</span></span><br><span class="line">pd.merge(df1, df2), pd.merge(df1, df2,</span><br><span class="line">                             how=<span class="string">&#x27;left&#x27;</span>, <span class="comment"># 以 df1 为准, 匹配不上的保留 df1</span></span><br><span class="line">                             on=[<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>], <span class="comment"># 按 A,B 列合并</span></span><br><span class="line">                             left_index=<span class="literal">True</span>) <span class="comment"># 保留匹配上的 df1 的行索引</span></span><br></pre></td></tr></table></figure>




<pre><code>(   A  B  C  D  E  F
 0  2  2  1  2  2  1
 1  2  1  1  2  1  1
 2  2  1  1  2  1  2
 3  2  1  2  2  1  1
 4  2  1  2  2  1  2,
      A  B  C  D    E    F
 f    2  2  1  2  2.0  1.0
 a    2  1  1  2  1.0  1.0
 e    2  1  1  2  1.0  2.0
 a    2  1  2  2  1.0  1.0
 e    2  1  2  2  1.0  2.0
 NaN  1  1  2  2  NaN  NaN)</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 假设 df1 的 C 列与 df2 的 E 列内容相同需要合并</span></span><br><span class="line">print(pd.merge(df1, df2, left_on=<span class="string">&#x27;C&#x27;</span>, right_on=<span class="string">&#x27;E&#x27;</span>))</span><br></pre></td></tr></table></figure>

<pre><code>   A_x  B_x  C  D  A_y  B_y  E  F
0    2    2  1  2    2    1  1  1
1    2    2  1  2    1    2  1  1
2    2    2  1  2    2    1  1  2
3    2    1  1  2    2    1  1  1
4    2    1  1  2    1    2  1  1
5    2    1  1  2    2    1  1  2
6    2    1  2  2    2    2  2  1
7    1    1  2  2    2    2  2  1</code></pre>
<h3 id="3-数据选择与处理"><a href="#3-数据选择与处理" class="headerlink" title="3, 数据选择与处理"></a>3, 数据选择与处理</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line">np.random.seed(<span class="number">0</span>)</span><br><span class="line">df = pd.DataFrame(np.random.randint(<span class="number">1</span>, <span class="number">9</span>, (<span class="number">6</span>, <span class="number">6</span>)),</span><br><span class="line">                  index=<span class="built_in">list</span>(<span class="string">&#x27;abcdef&#x27;</span>),</span><br><span class="line">                  columns=<span class="built_in">list</span>(<span class="string">&#x27;ABCDEF&#x27;</span>))</span><br><span class="line">print(df)</span><br></pre></td></tr></table></figure>

<pre><code>   A  B  C  D  E  F
a  5  8  6  1  4  4
b  4  8  2  4  6  3
c  5  8  7  1  1  5
d  3  2  7  8  8  7
e  1  2  6  2  6  1
f  2  5  4  1  4  6</code></pre>
<p><strong>sample 随机选择数据</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 可以指定数量, 也可以按比例选</span></span><br><span class="line">df.iloc[<span class="number">0</span>].sample(<span class="number">2</span>) <span class="comment"># s 也可</span></span><br><span class="line">df.sample(<span class="number">3</span>), df.sample(frac=<span class="number">0.5</span>, axis=<span class="number">1</span>)</span><br></pre></td></tr></table></figure>




<pre><code>(   A  B  C  D  E  F
 d  3  2  7  8  8  7
 b  4  8  2  4  6  3
 f  2  5  4  1  4  6,
    E  F  D
 a  4  4  1
 b  6  3  4
 c  1  5  1
 d  8  7  8
 e  6  1  2
 f  4  6  1)</code></pre>
<p><strong>where 按条件选择数据, 且可替换, 替换的是条件之外的数据</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df.A.where(df.A&gt;<span class="number">3</span>) <span class="comment"># s 也可</span></span><br><span class="line">df1 = df.where(df&gt;<span class="number">1</span>)</span><br><span class="line">df1, df.where(df==<span class="number">1</span>, <span class="keyword">lambda</span> x: x*x)</span><br></pre></td></tr></table></figure>




<pre><code>(     A  B  C    D    E    F
 a  5.0  8  6  NaN  4.0  4.0
 b  4.0  8  2  4.0  6.0  3.0
 c  5.0  8  7  NaN  NaN  5.0
 d  3.0  2  7  8.0  8.0  7.0
 e  NaN  2  6  2.0  6.0  NaN
 f  2.0  5  4  NaN  4.0  6.0,
     A   B   C   D   E   F
 a  25  64  36   1  16  16
 b  16  64   4  16  36   9
 c  25  64  49   1   1  25
 d   9   4  49  64  64  49
 e   1   4  36   4  36   1
 f   4  25  16   1  16  36)</code></pre>
<p><strong>isin 生成布尔数组来选择数据</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">values = [<span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;c&#x27;</span>]</span><br><span class="line">df.C.isin(values), df.A[df.C.isin(values)]</span><br></pre></td></tr></table></figure>




<pre><code>(a    False
 b    False
 c     True
 d     True
 e    False
 f    False
 Name: C, dtype: bool,
 c    5
 d    3
 Name: A, dtype: int32)</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df[df.isin(values)], df[df.index.isin(values)]</span><br></pre></td></tr></table></figure>




<pre><code>(     A    B    C   D   E    F
 a  5.0  NaN  NaN NaN NaN  NaN
 b  NaN  NaN  NaN NaN NaN  3.0
 c  5.0  NaN  7.0 NaN NaN  5.0
 d  3.0  NaN  7.0 NaN NaN  7.0
 e  NaN  NaN  NaN NaN NaN  NaN
 f  NaN  5.0  NaN NaN NaN  NaN,
    A  B  C  D  E  F
 a  5  8  6  1  4  4
 c  5  8  7  1  1  5)</code></pre>
<p><strong>isna( isnull ) 和 notna ( notnull ) 生成布尔数组</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 可以 pd 调用, 也可 df 或 s 调用</span></span><br><span class="line">pd.isna(df1.D), df1.D.isnull(), df1.isna()</span><br></pre></td></tr></table></figure>




<pre><code>(a     True
 b    False
 c     True
 d    False
 e    False
 f     True
 Name: D, dtype: bool,
 a     True
 b    False
 c     True
 d    False
 e    False
 f     True
 Name: D, dtype: bool,
        A      B      C      D      E      F
 a  False  False  False   True  False  False
 b  False  False  False  False  False  False
 c  False  False  False   True   True  False
 d  False  False  False  False  False  False
 e   True  False  False  False  False   True
 f  False  False  False   True  False  False)</code></pre>
<p><strong>dropna 删除 nan, fillna 将 nan 填充</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 默认有 nan 的行就删除, 参数 all: 全部 nan 才删除</span></span><br><span class="line">df1.A.dropna() <span class="comment"># s 也可</span></span><br><span class="line">df1.dropna(), df1.dropna(axis=<span class="number">1</span>, how=<span class="string">&#x27;all&#x27;</span>)</span><br></pre></td></tr></table></figure>




<pre><code>(     A  B  C    D    E    F
 b  4.0  8  2  4.0  6.0  3.0
 d  3.0  2  7  8.0  8.0  7.0,
      A  B  C    D    E    F
 a  5.0  8  6  NaN  4.0  4.0
 b  4.0  8  2  4.0  6.0  3.0
 c  5.0  8  7  NaN  NaN  5.0
 d  3.0  2  7  8.0  8.0  7.0
 e  NaN  2  6  2.0  6.0  NaN
 f  2.0  5  4  NaN  4.0  6.0)</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 给定填充值, 默认全部填充, </span></span><br><span class="line"><span class="comment"># 可以指定填充数, 填充方式</span></span><br><span class="line">df1.A.fillna(<span class="number">0</span>) <span class="comment"># s 也可</span></span><br><span class="line">df1.fillna(<span class="number">0</span>), df1.fillna(<span class="number">0</span>, limit=<span class="number">1</span>) <span class="comment"># 每一列填充一个</span></span><br></pre></td></tr></table></figure>




<pre><code>(     A  B  C    D    E    F
 a  5.0  8  6  0.0  4.0  4.0
 b  4.0  8  2  4.0  6.0  3.0
 c  5.0  8  7  0.0  0.0  5.0
 d  3.0  2  7  8.0  8.0  7.0
 e  0.0  2  6  2.0  6.0  0.0
 f  2.0  5  4  0.0  4.0  6.0,
      A  B  C    D    E    F
 a  5.0  8  6  0.0  4.0  4.0
 b  4.0  8  2  4.0  6.0  3.0
 c  5.0  8  7  NaN  0.0  5.0
 d  3.0  2  7  8.0  8.0  7.0
 e  0.0  2  6  2.0  6.0  0.0
 f  2.0  5  4  NaN  4.0  6.0)</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># ffill 前面值填充, bfill 后面值填充</span></span><br><span class="line">df1.fillna(method=<span class="string">&#x27;ffill&#x27;</span>), df1.fillna(method=<span class="string">&#x27;bfill&#x27;</span>)</span><br></pre></td></tr></table></figure>




<pre><code>(     A  B  C    D    E    F
 a  5.0  8  6  NaN  4.0  4.0
 b  4.0  8  2  4.0  6.0  3.0
 c  5.0  8  7  4.0  6.0  5.0
 d  3.0  2  7  8.0  8.0  7.0
 e  3.0  2  6  2.0  6.0  7.0
 f  2.0  5  4  2.0  4.0  6.0,
      A  B  C    D    E    F
 a  5.0  8  6  4.0  4.0  4.0
 b  4.0  8  2  4.0  6.0  3.0
 c  5.0  8  7  8.0  8.0  5.0
 d  3.0  2  7  8.0  8.0  7.0
 e  2.0  2  6  2.0  6.0  6.0
 f  2.0  5  4  NaN  4.0  6.0)</code></pre>
<p><strong>drop_duplicates 去重</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df.iloc[<span class="number">0</span>] = df.iloc[<span class="number">1</span>]</span><br><span class="line"><span class="comment"># 默认保留第 1 条数据</span></span><br><span class="line">df.A.drop_duplicates() <span class="comment"># s 也可</span></span><br><span class="line">df, df.drop_duplicates()</span><br></pre></td></tr></table></figure>




<pre><code>(   A  B  C  D  E  F
 a  4  8  2  4  6  3
 b  4  8  2  4  6  3
 c  5  8  7  1  1  5
 d  3  2  7  8  8  7
 e  1  2  6  2  6  1
 f  2  5  4  1  4  6,
    A  B  C  D  E  F
 a  4  8  2  4  6  3
 c  5  8  7  1  1  5
 d  3  2  7  8  8  7
 e  1  2  6  2  6  1
 f  2  5  4  1  4  6)</code></pre>
<p><strong>nlargest 选择某列(某几列)值最大的几条数据, 对应还有 nsmallest</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df.nlargest(<span class="number">3</span>, <span class="string">&#x27;A&#x27;</span>), df.nsmallest(<span class="number">3</span>, <span class="string">&#x27;A&#x27;</span>), df.nlargest(<span class="number">3</span>, [<span class="string">&#x27;C&#x27;</span>, <span class="string">&#x27;D&#x27;</span>])</span><br></pre></td></tr></table></figure>




<pre><code>(   A  B  C  D  E  F
 c  5  8  7  1  1  5
 a  4  8  2  4  6  3
 b  4  8  2  4  6  3,
    A  B  C  D  E  F
 e  1  2  6  2  6  1
 f  2  5  4  1  4  6
 d  3  2  7  8  8  7,
    A  B  C  D  E  F
 d  3  2  7  8  8  7
 c  5  8  7  1  1  5
 e  1  2  6  2  6  1)</code></pre>
<p><strong>filter 按索引查找数据, 可正则模糊查找</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df.<span class="built_in">filter</span>([<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>]), df.<span class="built_in">filter</span>(like=<span class="string">&#x27;a&#x27;</span>, axis=<span class="number">0</span>), df.<span class="built_in">filter</span>(regex=<span class="string">&#x27;c&#x27;</span>, axis=<span class="number">0</span>)</span><br></pre></td></tr></table></figure>




<pre><code>(   A  B
 a  4  8
 b  4  8
 c  5  8
 d  3  2
 e  1  2
 f  2  5,
    A  B  C  D  E  F
 a  4  8  2  4  6  3,
    A  B  C  D  E  F
 c  5  8  7  1  1  5)</code></pre>
<p><strong>assign 用于新增辅助列</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df.assign(A1=df[<span class="string">&#x27;A&#x27;</span>]/df[<span class="string">&#x27;F&#x27;</span>]), df.assign(A1=<span class="keyword">lambda</span> x:x.A/x.F)</span><br></pre></td></tr></table></figure>




<pre><code>(   A  B  C  D  E  F        A1
 a  4  8  2  4  6  3  1.333333
 b  4  8  2  4  6  3  1.333333
 c  5  8  7  1  1  5  1.000000
 d  3  2  7  8  8  7  0.428571
 e  1  2  6  2  6  1  1.000000
 f  2  5  4  1  4  6  0.333333,
    A  B  C  D  E  F        A1
 a  4  8  2  4  6  3  1.333333
 b  4  8  2  4  6  3  1.333333
 c  5  8  7  1  1  5  1.000000
 d  3  2  7  8  8  7  0.428571
 e  1  2  6  2  6  1  1.000000
 f  2  5  4  1  4  6  0.333333)</code></pre>
<p><strong>clip 将过大或过小的数据去掉, 并填充指定值</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 小于指定值的填充为指定值小者, 大于的反之</span></span><br><span class="line">df.clip(<span class="number">2</span>, <span class="number">6</span>), df.clip(df.A, df.A + <span class="number">2</span>, axis=<span class="number">0</span>)</span><br></pre></td></tr></table></figure>




<pre><code>(   A  B  C  D  E  F
 a  4  6  2  4  6  3
 b  4  6  2  4  6  3
 c  5  6  6  2  2  5
 d  3  2  6  6  6  6
 e  2  2  6  2  6  2
 f  2  5  4  2  4  6,
    A  B  C  D  E  F
 a  4  6  4  4  6  4
 b  4  6  4  4  6  4
 c  5  7  7  5  5  5
 d  3  3  5  5  5  5
 e  1  2  3  2  3  1
 f  2  4  4  2  4  4)</code></pre>
<h3 id="4-数据分组聚合计算"><a href="#4-数据分组聚合计算" class="headerlink" title="4, 数据分组聚合计算"></a>4, 数据分组聚合计算</h3><p>聚合计算和 np 函数基本一样, 例如 sum, count, median, min, max, mean, var, std 等, 比较容易. 更为重要的, 是将数据按需分组后再聚合运算</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line">np.random.seed(<span class="number">0</span>)</span><br><span class="line">df = pd.DataFrame(np.random.randint(<span class="number">1</span>, <span class="number">9</span>, (<span class="number">6</span>, <span class="number">6</span>)),</span><br><span class="line">                  index=<span class="built_in">list</span>(<span class="string">&#x27;abcdef&#x27;</span>),</span><br><span class="line">                  columns=<span class="built_in">list</span>(<span class="string">&#x27;ABCDEF&#x27;</span>))</span><br><span class="line"></span><br><span class="line">df.A.where(df.A&gt;<span class="number">3</span>, <span class="string">&#x27;M&#x27;</span>, inplace=<span class="literal">True</span>)</span><br><span class="line">df.A.where(df.A==<span class="string">&#x27;M&#x27;</span>, <span class="string">&#x27;N&#x27;</span>, inplace=<span class="literal">True</span>)</span><br><span class="line">df.B.where(df.B&gt;<span class="number">3</span>, <span class="string">&#x27;J&#x27;</span>, inplace=<span class="literal">True</span>)</span><br><span class="line">df.B.where(df.B==<span class="string">&#x27;J&#x27;</span>, <span class="string">&#x27;K&#x27;</span>, inplace=<span class="literal">True</span>)</span><br><span class="line">df.C.where(df.C&lt;<span class="number">5</span>, np.nan, inplace=<span class="literal">True</span>)</span><br><span class="line">print(df)</span><br></pre></td></tr></table></figure>

<pre><code>   A  B    C  D  E  F
a  N  K  NaN  1  4  4
b  N  K  2.0  4  6  3
c  N  K  NaN  1  1  5
d  M  J  NaN  8  8  7
e  M  J  NaN  2  6  1
f  M  K  4.0  1  4  6</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 默认按列加和, 将 nan 转换为 0 来计算</span></span><br><span class="line">df.<span class="built_in">sum</span>(), df.<span class="built_in">sum</span>(axis=<span class="number">1</span>)</span><br><span class="line"><span class="comment"># 默认按列统计忽略 nan</span></span><br><span class="line">df.count(axis=<span class="number">1</span>), df.set_index([<span class="string">&quot;A&quot;</span>, <span class="string">&quot;B&quot;</span>]).count(level=<span class="string">&quot;A&quot;</span>)</span><br><span class="line"><span class="comment"># df.cumsum()</span></span><br><span class="line"><span class="comment"># df.cummax()</span></span><br><span class="line"><span class="comment"># 等等</span></span><br></pre></td></tr></table></figure>




<pre><code>(a    5
 b    6
 c    5
 d    5
 e    5
 f    6
 dtype: int64,
    C  D  E  F
 A            
 M  1  3  3  3
 N  1  3  3  3)</code></pre>
<p><strong>value_counts 统计 s 中每个值出现次数</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># s 的值统计, 也即是 df 的每一列中每个值的数量统计</span></span><br><span class="line">df.A.value_counts(), df.C.value_counts()</span><br></pre></td></tr></table></figure>




<pre><code>(M    3
 N    3
 Name: A, dtype: int64,
 4.0    1
 2.0    1
 Name: C, dtype: int64)</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 可以统计索引, 可按百分比显示, 可以分组统计</span></span><br><span class="line">df.set_index(<span class="string">&#x27;A&#x27;</span>).index.value_counts(normalize=<span class="literal">True</span>), df.D.value_counts(bins=<span class="number">2</span>)</span><br></pre></td></tr></table></figure>




<pre><code>(M    0.5
 N    0.5
 Name: A, dtype: float64,
 (0.992, 4.5]    5
 (4.5, 8.0]      1
 Name: D, dtype: int64)</code></pre>
<p><strong>nunique 去重计数, 统计每一行或列不同值的数量</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df.nunique() </span><br></pre></td></tr></table></figure>




<pre><code>A    2
B    2
C    2
D    4
E    4
F    6
dtype: int64</code></pre>
<p><strong>quantile 计算分位数</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">print(df.quantile([<span class="number">0.3</span>, <span class="number">0.6</span>]))</span><br></pre></td></tr></table></figure>

<pre><code>       C    D    E    F
0.3  2.6  1.0  4.0  3.5
0.6  3.2  2.0  6.0  5.0</code></pre>
<p><strong>cut 与 qcut 数据分箱</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 将某一列中的值分别分到一个范围中, 默认左不包含右包含</span></span><br><span class="line"><span class="comment"># 这对分组非常有用, 例如年龄分段</span></span><br><span class="line">c = pd.cut(df.D, bins=[<span class="number">0</span>, <span class="number">3</span>, <span class="number">8</span>], labels=[<span class="string">&#x27;0到3&#x27;</span>, <span class="string">&#x27;3到8&#x27;</span>])</span><br><span class="line">c</span><br></pre></td></tr></table></figure>




<pre><code>a    0到3
b    3到8
c    0到3
d    3到8
e    0到3
f    0到3
Name: D, dtype: category
Categories (2, object): [0到3 &lt; 3到8]</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 根据数值的频率来选择间隔, 使每个分段里值的个数相同</span></span><br><span class="line">pd.qcut(df.D, q=<span class="number">2</span>), pd.qcut(df.D, q=<span class="number">2</span>).value_counts()</span><br></pre></td></tr></table></figure>




<pre><code>(a    (0.999, 1.5]
 b      (1.5, 8.0]
 c    (0.999, 1.5]
 d      (1.5, 8.0]
 e      (1.5, 8.0]
 f    (0.999, 1.5]
 Name: D, dtype: category
 Categories (2, interval[float64]): [(0.999, 1.5] &lt; (1.5, 8.0]],
 (1.5, 8.0]      3
 (0.999, 1.5]    3
 Name: D, dtype: int64)</code></pre>
<p><strong>rank 用来给数据排名, 例如销售额, 成绩等</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 有多种排名方式可供选择, 举一例: 给 D 列排名</span></span><br><span class="line">df[<span class="string">&#x27;排名&#x27;</span>] = df.D.rank(method=<span class="string">&#x27;dense&#x27;</span>, ascending=<span class="literal">False</span>)</span><br><span class="line">print(df)</span><br></pre></td></tr></table></figure>

<pre><code>   A  B    C  D  E  F   排名
a  N  K  NaN  1  4  4  4.0
b  N  K  2.0  4  6  3  2.0
c  N  K  NaN  1  1  5  4.0
d  M  J  NaN  8  8  7  1.0
e  M  J  NaN  2  6  1  3.0
f  M  K  4.0  1  4  6  4.0</code></pre>
<p><strong>sort_values 数据排序</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df.sort_values(<span class="string">&#x27;排名&#x27;</span>, inplace=<span class="literal">True</span>)</span><br><span class="line">print(df)</span><br></pre></td></tr></table></figure>

<pre><code>   A  B    C  D  E  F   排名
d  M  J  NaN  8  8  7  1.0
b  N  K  2.0  4  6  3  2.0
e  M  J  NaN  2  6  1  3.0
a  N  K  NaN  1  4  4  4.0
c  N  K  NaN  1  1  5  4.0
f  M  K  4.0  1  4  6  4.0</code></pre>
<p><strong>shift 数据移动, 索引不变</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 默认向后移动一行, 同类型相移动, nan 填充</span></span><br><span class="line">df.info(), df.shift(<span class="number">1</span>), df.shift(<span class="number">-1</span>, axis=<span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<pre><code>&lt;class &#39;pandas.core.frame.DataFrame&#39;&gt;
Index: 6 entries, d to f
Data columns (total 7 columns):
 #   Column  Non-Null Count  Dtype  
---  ------  --------------  -----  
 0   A       6 non-null      object 
 1   B       6 non-null      object 
 2   C       2 non-null      float64
 3   D       6 non-null      int32  
 4   E       6 non-null      int32  
 5   F       6 non-null      int32  
 6   排名      6 non-null      float64
dtypes: float64(2), int32(3), object(2)
memory usage: 312.0+ bytes

(None,
      A    B    C    D    E    F   排名
 d  NaN  NaN  NaN  NaN  NaN  NaN  NaN
 b    M    J  NaN  8.0  8.0  7.0  1.0
 e    N    K  2.0  4.0  6.0  3.0  2.0
 a    M    J  NaN  2.0  6.0  1.0  3.0
 c    N    K  NaN  1.0  4.0  4.0  4.0
 f    N    K  NaN  1.0  1.0  5.0  4.0,
    A    B    C    D    E   F  排名
 d  J  NaN  1.0  8.0  7.0 NaN NaN
 b  K  NaN  2.0  6.0  3.0 NaN NaN
 e  J  NaN  3.0  6.0  1.0 NaN NaN
 a  K  NaN  4.0  4.0  4.0 NaN NaN
 c  K  NaN  4.0  1.0  5.0 NaN NaN
 f  K  NaN  4.0  4.0  6.0 NaN NaN)</code></pre>
<p><strong>agg 和 apply 传入函数进行高级聚合运算, 已存在的函数用字符串形式传入, 自定义函数传入函数名</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df.agg(<span class="string">&#x27;sum&#x27;</span>), df.agg([<span class="string">&#x27;max&#x27;</span>, <span class="string">&#x27;min&#x27;</span>]), df.apply([<span class="string">&#x27;max&#x27;</span>, <span class="string">&#x27;min&#x27;</span>])</span><br></pre></td></tr></table></figure>




<pre><code>(A     MNMNNM
 B     JKJKKK
 C          6
 D         17
 E         29
 F         26
 排名        18
 dtype: object,
      A  B    C  D  E  F   排名
 max  N  K  4.0  8  8  7  4.0
 min  M  J  2.0  1  1  1  1.0,
      A  B    C  D  E  F   排名
 max  N  K  4.0  8  8  7  4.0
 min  M  J  2.0  1  1  1  1.0)</code></pre>
<p>🔺🔺<strong>groupby 按指定的列(行)中不同值分组, 与前面的聚合函数组合出无限的变化, 满足各种需求</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 分组后是一个迭代器, 可以查看分组, 获取分组</span></span><br><span class="line">df.groupby(<span class="string">&#x27;A&#x27;</span>), df.groupby(<span class="string">&#x27;A&#x27;</span>).groups, df.groupby(<span class="string">&#x27;A&#x27;</span>).get_group(<span class="string">&#x27;M&#x27;</span>)</span><br></pre></td></tr></table></figure>




<pre><code>(&lt;pandas.core.groupby.generic.DataFrameGroupBy object at 0x000002C3AE430630&gt;,
 &#123;&#39;M&#39;: Index([&#39;d&#39;, &#39;e&#39;, &#39;f&#39;], dtype=&#39;object&#39;),
  &#39;N&#39;: Index([&#39;b&#39;, &#39;a&#39;, &#39;c&#39;], dtype=&#39;object&#39;)&#125;,
    A  B    C  D  E  F   排名
 d  M  J  NaN  8  8  7  1.0
 e  M  J  NaN  2  6  1  3.0
 f  M  K  4.0  1  4  6  4.0)</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 分别取出 M 和 N 中 F 列任意排名的数据</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_second</span>(<span class="params">x, m, n</span>):</span></span><br><span class="line">    <span class="keyword">return</span> x[x[m].rank(method=<span class="string">&#x27;dense&#x27;</span>, ascending=<span class="literal">False</span>)==n]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过修改 n 参数取出任意排名</span></span><br><span class="line">print(df.groupby(<span class="string">&#x27;A&#x27;</span>).apply(get_second, m=<span class="string">&#x27;F&#x27;</span>, n=<span class="number">3.0</span>))</span><br></pre></td></tr></table></figure>

<pre><code>     A  B    C  D  E  F   排名
A                           
M e  M  J  NaN  2  6  1  3.0
N b  N  K  2.0  4  6  3  2.0</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 将上述 cut 分箱得到的数据用来分组统计</span></span><br><span class="line">print(df.groupby(c).count())</span><br></pre></td></tr></table></figure>

<pre><code>     A  B  C  D  E  F  排名
D                        
0到3  4  4  1  4  4  4   4
3到8  2  2  1  2  2  2   2</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 对不同的列作不同的分组聚合运算</span></span><br><span class="line">print(df.groupby(<span class="string">&#x27;A&#x27;</span>).agg(&#123;<span class="string">&#x27;E&#x27;</span>: [<span class="string">&#x27;mean&#x27;</span>, <span class="string">&#x27;max&#x27;</span>], <span class="string">&#x27;F&#x27;</span>: <span class="string">&#x27;sum&#x27;</span>&#125;))</span><br></pre></td></tr></table></figure>

<pre><code>          E       F
       mean max sum
A                  
M  6.000000   8  14
N  3.666667   6  12</code></pre>
<h3 id="5-数据透视与窗口函数"><a href="#5-数据透视与窗口函数" class="headerlink" title="5, 数据透视与窗口函数"></a>5, 数据透视与窗口函数</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line">np.random.seed(<span class="number">0</span>)</span><br><span class="line">df = pd.DataFrame(np.random.randint(<span class="number">1</span>, <span class="number">20</span>, (<span class="number">4</span>, <span class="number">5</span>)))</span><br><span class="line">df.columns = <span class="built_in">list</span>(<span class="string">&#x27;ABCDE&#x27;</span>)</span><br><span class="line">print(df)</span><br></pre></td></tr></table></figure>

<pre><code>    A   B   C  D   E
0  13  16   1  4   4
1   8  10  19  5   7
2  13   2   7  8  15
3  18   6  14  9  10</code></pre>
<p><strong>melt 将列索引展开成数据</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 默认全部展开</span></span><br><span class="line">df1 = pd.melt(df, id_vars=[<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>], var_name=<span class="string">&#x27;F&#x27;</span>, value_name=<span class="string">&#x27;G&#x27;</span>)</span><br><span class="line">df1, pd.melt(df, id_vars=[<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>], value_vars=[<span class="string">&#x27;C&#x27;</span>])</span><br></pre></td></tr></table></figure>




<pre><code>(     A   B  F   G
 0   13  16  C   1
 1    8  10  C  19
 2   13   2  C   7
 3   18   6  C  14
 4   13  16  D   4
 5    8  10  D   5
 6   13   2  D   8
 7   18   6  D   9
 8   13  16  E   4
 9    8  10  E   7
 10  13   2  E  15
 11  18   6  E  10,
     A   B variable  value
 0  13  16        C      1
 1   8  10        C     19
 2  13   2        C      7
 3  18   6        C     14)</code></pre>
<p><strong>pivot 将行值展开成为列索引</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">print(df1.pivot(columns=<span class="string">&#x27;F&#x27;</span>, values=[<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>]))</span><br></pre></td></tr></table></figure>

<pre><code>       A                 B            
F      C     D     E     C     D     E
0   13.0   NaN   NaN  16.0   NaN   NaN
1    8.0   NaN   NaN  10.0   NaN   NaN
2   13.0   NaN   NaN   2.0   NaN   NaN
3   18.0   NaN   NaN   6.0   NaN   NaN
4    NaN  13.0   NaN   NaN  16.0   NaN
5    NaN   8.0   NaN   NaN  10.0   NaN
6    NaN  13.0   NaN   NaN   2.0   NaN
7    NaN  18.0   NaN   NaN   6.0   NaN
8    NaN   NaN  13.0   NaN   NaN  16.0
9    NaN   NaN   8.0   NaN   NaN  10.0
10   NaN   NaN  13.0   NaN   NaN   2.0
11   NaN   NaN  18.0   NaN   NaN   6.0</code></pre>
<p><strong>pivot_table 与 groupby + 聚合函数 类似, 可以对表格进行各种需求的透视</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df1.index = <span class="built_in">list</span>(<span class="string">&#x27;LMNLMNLMNLMN&#x27;</span>)</span><br><span class="line">df1.reset_index(inplace=<span class="literal">True</span>)</span><br><span class="line">df1.rename(columns=&#123;<span class="string">&#x27;index&#x27;</span>: <span class="string">&#x27;Q&#x27;</span>&#125;, inplace=<span class="literal">True</span>)</span><br><span class="line">print(df1.pivot_table(index=[<span class="string">&#x27;Q&#x27;</span>, <span class="string">&#x27;F&#x27;</span>], aggfunc=<span class="string">&#x27;mean&#x27;</span>))</span><br></pre></td></tr></table></figure>

<pre><code>        A   B     G
Q F                
L C  15.5  11   7.5
  D  13.0   2   8.0
  E   8.0  10   7.0
M C   8.0  10  19.0
  D  15.5  11   6.5
  E  13.0   2  15.0
N C  13.0   2   7.0
  D   8.0  10   5.0
  E  15.5  11   7.0</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df1, df1.pivot_table(index=<span class="string">&#x27;Q&#x27;</span>,</span><br><span class="line">                    columns=<span class="string">&#x27;F&#x27;</span>,</span><br><span class="line">                    values=<span class="string">&#x27;A&#x27;</span>,</span><br><span class="line">                    aggfunc=[<span class="string">&#x27;mean&#x27;</span>, <span class="string">&#x27;sum&#x27;</span>])</span><br></pre></td></tr></table></figure>




<pre><code>(    Q   A   B  F   G
 0   L  13  16  C   1
 1   M   8  10  C  19
 2   N  13   2  C   7
 3   L  18   6  C  14
 4   M  13  16  D   4
 5   N   8  10  D   5
 6   L  13   2  D   8
 7   M  18   6  D   9
 8   N  13  16  E   4
 9   L   8  10  E   7
 10  M  13   2  E  15
 11  N  18   6  E  10,
    mean             sum        
 F     C     D     E   C   D   E
 Q                              
 L  15.5  13.0   8.0  31  13   8
 M   8.0  15.5  13.0   8  31  13
 N  13.0   8.0  15.5  13   8  31)</code></pre>
<p><strong>rolling 将数据依次移动指定尺寸的窗口并进行聚合运算</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df1.rolling(<span class="number">3</span>)</span><br></pre></td></tr></table></figure>




<pre><code>Rolling [window=3,center=False,axis=0]</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 每移动 3 条数据加和一次作为一条新数据,</span></span><br><span class="line"><span class="comment"># 前面默认 nan 填充</span></span><br><span class="line">df1, df1.rolling(<span class="number">3</span>).<span class="built_in">sum</span>()</span><br></pre></td></tr></table></figure>




<pre><code>(    Q   A   B  F   G
 0   L  13  16  C   1
 1   M   8  10  C  19
 2   N  13   2  C   7
 3   L  18   6  C  14
 4   M  13  16  D   4
 5   N   8  10  D   5
 6   L  13   2  D   8
 7   M  18   6  D   9
 8   N  13  16  E   4
 9   L   8  10  E   7
 10  M  13   2  E  15
 11  N  18   6  E  10,
        A     B     G
 0    NaN   NaN   NaN
 1    NaN   NaN   NaN
 2   34.0  28.0  27.0
 3   39.0  18.0  40.0
 4   44.0  24.0  25.0
 5   39.0  32.0  23.0
 6   34.0  28.0  17.0
 7   39.0  18.0  22.0
 8   44.0  24.0  21.0
 9   39.0  32.0  20.0
 10  34.0  28.0  26.0
 11  39.0  18.0  32.0)</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 可以设置最小观察值(必须小于移动尺寸)</span></span><br><span class="line"><span class="comment"># 可以用高级函数聚合运算</span></span><br><span class="line">df1.rolling(<span class="built_in">len</span>(df1), min_periods=<span class="number">1</span>).<span class="built_in">sum</span>(), df1.rolling(<span class="number">2</span>).agg([<span class="string">&#x27;sum&#x27;</span>, np.<span class="built_in">max</span>])</span><br></pre></td></tr></table></figure>




<pre><code>(        A      B      G
 0    13.0   16.0    1.0
 1    21.0   26.0   20.0
 2    34.0   28.0   27.0
 3    52.0   34.0   41.0
 4    65.0   50.0   45.0
 5    73.0   60.0   50.0
 6    86.0   62.0   58.0
 7   104.0   68.0   67.0
 8   117.0   84.0   71.0
 9   125.0   94.0   78.0
 10  138.0   96.0   93.0
 11  156.0  102.0  103.0,
        A           B           G      
      sum  amax   sum  amax   sum  amax
 0    NaN   NaN   NaN   NaN   NaN   NaN
 1   21.0  13.0  26.0  16.0  20.0  19.0
 2   21.0  13.0  12.0  10.0  26.0  19.0
 3   31.0  18.0   8.0   6.0  21.0  14.0
 4   31.0  18.0  22.0  16.0  18.0  14.0
 5   21.0  13.0  26.0  16.0   9.0   5.0
 6   21.0  13.0  12.0  10.0  13.0   8.0
 7   31.0  18.0   8.0   6.0  17.0   9.0
 8   31.0  18.0  22.0  16.0  13.0   9.0
 9   21.0  13.0  26.0  16.0  11.0   7.0
 10  21.0  13.0  12.0  10.0  22.0  15.0
 11  31.0  18.0   8.0   6.0  25.0  15.0)</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span>(<span class="params">x</span>):</span></span><br><span class="line">    <span class="keyword">return</span> x.iloc[<span class="number">0</span>] * x.iloc[<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">df1[[<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;G&#x27;</span>]], df1.rolling(<span class="number">2</span>)[<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;G&#x27;</span>].apply(f)</span><br></pre></td></tr></table></figure>




<pre><code>(     A   G
 0   13   1
 1    8  19
 2   13   7
 3   18  14
 4   13   4
 5    8   5
 6   13   8
 7   18   9
 8   13   4
 9    8   7
 10  13  15
 11  18  10,
         A      G
 0     NaN    NaN
 1   104.0   19.0
 2   104.0  133.0
 3   234.0   98.0
 4   234.0   56.0
 5   104.0   20.0
 6   104.0   40.0
 7   234.0   72.0
 8   234.0   36.0
 9   104.0   28.0
 10  104.0  105.0
 11  234.0  150.0)</code></pre>
<h3 id="6-文本字符串处理"><a href="#6-文本字符串处理" class="headerlink" title="6, 文本字符串处理"></a>6, 文本字符串处理</h3><p>文本字符串处理方法基本上和 python 内建字符串方法同名, 这些方法自动忽略 nan 进行处理</p>
<p>方法较多, 常用的举几个例子:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s = pd.Series([<span class="string">&#x27;A_1&#x27;</span>, <span class="string">&#x27;B_2&#x27;</span>, <span class="string">&#x27;C_3&#x27;</span>, np.nan],</span><br><span class="line">              index=[<span class="string">&#x27;A_a&#x27;</span>, <span class="string">&#x27;B_b&#x27;</span>, <span class="string">&#x27;C_c&#x27;</span>, <span class="string">&#x27;D&#x27;</span>])</span><br><span class="line">s</span><br></pre></td></tr></table></figure>




<pre><code>A_a    A_1
B_b    B_2
C_c    C_3
D      NaN
dtype: object</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 取值</span></span><br><span class="line">s.<span class="built_in">str</span>[<span class="number">0</span>], s.<span class="built_in">str</span>[:<span class="number">2</span>], s.index.<span class="built_in">str</span>[<span class="number">2</span>]</span><br></pre></td></tr></table></figure>




<pre><code>(A_a      A
 B_b      B
 C_c      C
 D      NaN
 dtype: object,
 A_a     A_
 B_b     B_
 C_c     C_
 D      NaN
 dtype: object,
 Index([&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, nan], dtype=&#39;object&#39;))</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 拆分</span></span><br><span class="line">s.<span class="built_in">str</span>.split(<span class="string">&#x27;_&#x27;</span>), s.<span class="built_in">str</span>.split(<span class="string">&#x27;_&#x27;</span>).<span class="built_in">str</span>.get(<span class="number">0</span>), s.<span class="built_in">str</span>.split(<span class="string">&#x27;_&#x27;</span>).<span class="built_in">str</span>[<span class="number">1</span>]</span><br></pre></td></tr></table></figure>




<pre><code>(A_a    [A, 1]
 B_b    [B, 2]
 C_c    [C, 3]
 D         NaN
 dtype: object,
 A_a      A
 B_b      B
 C_c      C
 D      NaN
 dtype: object,
 A_a      1
 B_b      2
 C_c      3
 D      NaN
 dtype: object)</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s, s.<span class="built_in">str</span>.split(<span class="string">&#x27;_&#x27;</span>, expand=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>




<pre><code>(A_a    A_1
 B_b    B_2
 C_c    C_3
 D      NaN
 dtype: object,
        0    1
 A_a    A    1
 B_b    B    2
 C_c    C    3
 D    NaN  NaN)</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 替换, 默认正则匹配, 可传入函数高级匹配</span></span><br><span class="line">s.<span class="built_in">str</span>.replace(<span class="string">&#x27;_&#x27;</span>, <span class="string">&#x27;&#x27;</span>), s.index.<span class="built_in">str</span>.replace(<span class="string">&#x27;_&#x27;</span>, <span class="string">&#x27;&#x27;</span>)</span><br></pre></td></tr></table></figure>




<pre><code>(A_a     A1
 B_b     B2
 C_c     C3
 D      NaN
 dtype: object,
 Index([&#39;Aa&#39;, &#39;Bb&#39;, &#39;Cc&#39;, &#39;D&#39;], dtype=&#39;object&#39;))</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 拼接</span></span><br><span class="line">s1 = s.<span class="built_in">str</span>.split(<span class="string">&#x27;_&#x27;</span>).<span class="built_in">str</span>[<span class="number">0</span>]</span><br><span class="line">s1, s1.<span class="built_in">str</span>.cat(), s1.<span class="built_in">str</span>.cat(sep=<span class="string">&#x27;_&#x27;</span>), s1.<span class="built_in">str</span>.cat(sep=<span class="string">&#x27;_&#x27;</span>, na_rep=<span class="string">&#x27;_&#x27;</span>)</span><br></pre></td></tr></table></figure>




<pre><code>(A_a      A
 B_b      B
 C_c      C
 D      NaN
 dtype: object,
 &#39;ABC&#39;,
 &#39;A_B_C&#39;,
 &#39;A_B_C__&#39;)</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s1.<span class="built_in">str</span>.cat([<span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;2&#x27;</span>, <span class="string">&#x27;3&#x27;</span>, <span class="string">&#x27;4&#x27;</span>], na_rep=<span class="string">&#x27;_&#x27;</span>)</span><br></pre></td></tr></table></figure>




<pre><code>A_a    A1
B_b    B2
C_c    C3
D      _4
dtype: object</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 提取</span></span><br><span class="line">s, s.<span class="built_in">str</span>.extract(<span class="string">r&#x27;([ABC])_(\d)&#x27;</span>)</span><br></pre></td></tr></table></figure>




<pre><code>(A_a    A_1
 B_b    B_2
 C_c    C_3
 D      NaN
 dtype: object,
        0    1
 A_a    A    1
 B_b    B    2
 C_c    C    3
 D    NaN  NaN)</code></pre>
]]></content>
      <categories>
        <category>数据分析</category>
      </categories>
      <tags>
        <tag>pandas</tag>
      </tags>
  </entry>
  <entry>
    <title>温水煮青蛙</title>
    <url>/principle/Frog_effect-efcc6f353da2/</url>
    <content><![CDATA[<p>温水煮青蛙，也即是 “青蛙效应”：</p>
<blockquote>
<p>将一只青蛙放入盛满热水的锅里，青蛙触电般便跳了出来；然后又把它放入盛满凉水的锅里，将水慢慢加热，当水温开始让青蛙难以忍受的时候，它已经来不及或难以跳出水面了。</p>
</blockquote>
<p>一个没有危机意识，安于现状的人，已经是一只温水里的青蛙；</p>
<p>一个没有防备心理女孩，很容易被套路和手段老辣的 pua 渣男温水煮青蛙煮了；</p>
<p>一个不能居安思危，独立自主的民族，也会被一些强大的国家温水煮了青蛙……</p>
<p>启示：</p>
<ul>
<li><p>培养感受细微变化的能力，保持好奇，居安思危，锐意进取；</p>
</li>
<li><p>关注局部，也要着眼全局，突如其来的变化从容面对，缓慢变化的细节拉长时空对比，发现危险和机遇。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>原理原则</category>
      </categories>
      <tags>
        <tag>原则原理</tag>
      </tags>
  </entry>
  <entry>
    <title>四维空间长什么样?</title>
    <url>/principle/space-4e1b661cc9fa/</url>
    <content><![CDATA[<p>作为三维的生物，我们的眼睛只能看到这个世界的二维投影，即这个世界的影子，三维的立体感，是在大脑中根据经验想象出来的。而四维的生物，便能看到他们世界的三维投影。例如，他们可以同时看到三维空间中正方体的所有六面，以及正方体中所有点，就像我们可以同时看到二维平面上正方形的四条边以及正方形内部所有点一样。</p>
<p>想象一下，一个三维的物体在我们眼前移动，投影虽然在变，我们尚可以想象他不变的体型，而假如一个不规则四维生物来到我们的世界，在你的眼前移动，由于我们只能看到二维的投影，所以你将看到一个形状一直变化，想象不出体型的怪物。在此，<strong>降维打击</strong>就很好理解了，</p>
<blockquote>
<p>你完全看不清对方，而对方可以不碰到你的皮肤直接取你的心脏。</p>
</blockquote>
<p>下面我们用 Python-matplotlib 来想象一下四维空间到底啥样？</p>
<p>我们无法真正看到三维空间，更无法看到四维空间，要‘看到’四维空间，只能另辟蹊径了。</p>
<blockquote>
<p>用类推法，插上想象的翅膀，走进四维世界。</p>
</blockquote>
<br>

<h3 id="一维空间是这样的："><a href="#一维空间是这样的：" class="headerlink" title="一维空间是这样的："></a>一维空间是这样的：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import matplotlib.pyplot as plt</span><br><span class="line">from mpl_toolkits.mplot3d import Axes3D</span><br><span class="line"></span><br><span class="line">fig &#x3D; plt.figure()</span><br><span class="line">ax &#x3D; fig.gca(projection&#x3D;&#39;3d&#39;)</span><br><span class="line"></span><br><span class="line">a1, a2, a3 &#x3D; [0, 4], [0, 4], [0, 4]</span><br><span class="line"></span><br><span class="line">figure &#x3D; ax.plot(a1, a2, a3, c&#x3D; &#39;r&#39;, linestyle&#x3D;&quot;-&quot;)</span><br><span class="line"></span><br><span class="line">for i in range(len(a1)): </span><br><span class="line">    ax.text(a1[i],a2[i],a3[i],i,color&#x3D;&#39;r&#39;) </span><br><span class="line"></span><br><span class="line">plt.xticks([])</span><br><span class="line">plt.yticks([])</span><br><span class="line">plt.axis(&#39;off&#39;)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p><img src="/images/Python-matplotlib-drawing/One-dimensional-space.png"></p>
<p>他是一条被两端的两个点包围的线段。</p>
<br>

<h3 id="二维空间是这样的："><a href="#二维空间是这样的：" class="headerlink" title="二维空间是这样的："></a>二维空间是这样的：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import matplotlib.pyplot as plt</span><br><span class="line">from mpl_toolkits.mplot3d import Axes3D</span><br><span class="line"></span><br><span class="line">fig &#x3D; plt.figure()</span><br><span class="line">ax &#x3D; fig.gca(projection&#x3D;&#39;3d&#39;)</span><br><span class="line"></span><br><span class="line">h1, h2, h3 &#x3D; [4, 4], [0, 4], [4, 0]</span><br><span class="line">i1, i2, i3 &#x3D; [4, 0], [0, 4], [4, 4]</span><br><span class="line">j1, j2, j3 &#x3D; [4, 0], [4, 4], [0, 4]</span><br><span class="line"></span><br><span class="line">figure &#x3D; ax.plot(h1, h2, h3, c&#x3D; &#39;silver&#39;)</span><br><span class="line">figure &#x3D; ax.plot(i1, i2, i3, c&#x3D; &#39;silver&#39;)</span><br><span class="line">figure &#x3D; ax.plot(j1, j2, j3, c&#x3D; &#39;silver&#39;)</span><br><span class="line"></span><br><span class="line">plt.xticks([])</span><br><span class="line">plt.yticks([])</span><br><span class="line">plt.axis(&#39;off&#39;)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p><img src="/images/Python-matplotlib-drawing/Tow-dimensional-space.png"></p>
<p>他是一个被三条线段包围的三角形平面。</p>
<br>

<h3 id="三维空间是这样的："><a href="#三维空间是这样的：" class="headerlink" title="三维空间是这样的："></a>三维空间是这样的：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import matplotlib.pyplot as plt</span><br><span class="line">from mpl_toolkits.mplot3d import Axes3D</span><br><span class="line"></span><br><span class="line">fig &#x3D; plt.figure()</span><br><span class="line">ax &#x3D; fig.gca(projection&#x3D;&#39;3d&#39;)</span><br><span class="line"></span><br><span class="line">b1, b2, b3 &#x3D; [0, 4], [0, 4], [0, 0]</span><br><span class="line">c1, c2, c3 &#x3D; [0, 0], [0, 4], [0, 4]</span><br><span class="line">d1, d2, d3 &#x3D; [0, 4], [0, 0], [0, 4]</span><br><span class="line">h1, h2, h3 &#x3D; [4, 4], [0, 4], [4, 0]</span><br><span class="line">i1, i2, i3 &#x3D; [4, 0], [0, 4], [4, 4]</span><br><span class="line">j1, j2, j3 &#x3D; [4, 0], [4, 4], [0, 4]</span><br><span class="line"></span><br><span class="line">figure &#x3D; ax.plot(b1, b2, b3, c&#x3D; &#39;r&#39;)</span><br><span class="line">figure &#x3D; ax.plot(c1, c2, c3, c&#x3D; &#39;k&#39;)</span><br><span class="line">figure &#x3D; ax.plot(d1, d2, d3, c&#x3D; &#39;b&#39;)</span><br><span class="line">figure &#x3D; ax.plot(h1, h2, h3, c&#x3D; &#39;tan&#39;)</span><br><span class="line">figure &#x3D; ax.plot(i1, i2, i3, c&#x3D; &#39;pink&#39;)</span><br><span class="line">figure &#x3D; ax.plot(j1, j2, j3, c&#x3D; &#39;gold&#39;, linestyle&#x3D;&quot;--&quot;)</span><br><span class="line"></span><br><span class="line">plt.xticks([])</span><br><span class="line">plt.yticks([])</span><br><span class="line">plt.axis(&#39;off&#39;)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p><img src="/images/Python-matplotlib-drawing/Three-dimensional-space.png"></p>
<p>他是一个被四个三角形平面包围的三维四面体。其中虚线代表我们看不见的那条菱，但是通过旋转，看不见的那条菱，我们也可以看到。</p>
<p><img src="/images/Python-matplotlib-drawing/Three-dimensional-space1.png"></p>
<p>直接看，他其实就是一个四边形中间交叉两条对角线，一个三维的二维投影。</p>
<br>

<h3 id="四维空间是这样的："><a href="#四维空间是这样的：" class="headerlink" title="四维空间是这样的："></a>四维空间是这样的：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import matplotlib.pyplot as plt</span><br><span class="line">from mpl_toolkits.mplot3d import Axes3D</span><br><span class="line"></span><br><span class="line">fig &#x3D; plt.figure()</span><br><span class="line">ax &#x3D; fig.gca(projection&#x3D;&#39;3d&#39;)</span><br><span class="line"></span><br><span class="line">a1, a2, a3 &#x3D; [0, 4], [0, 4], [0, 4]</span><br><span class="line">b1, b2, b3 &#x3D; [0, 4], [0, 4], [0, 0]</span><br><span class="line">c1, c2, c3 &#x3D; [0, 0], [0, 4], [0, 4]</span><br><span class="line">d1, d2, d3 &#x3D; [0, 4], [0, 0], [0, 4]</span><br><span class="line">e1, e2, e3 &#x3D; [4, 4], [4, 4], [4, 0]</span><br><span class="line">f1, f2, f3 &#x3D; [4, 0], [4, 4], [4, 4]</span><br><span class="line">g1, g2, g3 &#x3D; [4, 4], [4, 0], [4, 4]</span><br><span class="line">h1, h2, h3 &#x3D; [4, 4], [0, 4], [4, 0]</span><br><span class="line">i1, i2, i3 &#x3D; [4, 0], [0, 4], [4, 4]</span><br><span class="line">j1, j2, j3 &#x3D; [4, 0], [4, 4], [0, 4]</span><br><span class="line"></span><br><span class="line">figure &#x3D; ax.plot(a1, a2, a3, c&#x3D; &#39;silver&#39;, linestyle&#x3D;&quot;--&quot;)</span><br><span class="line">figure &#x3D; ax.plot(b1, b2, b3, c&#x3D; &#39;silver&#39;)</span><br><span class="line">figure &#x3D; ax.plot(c1, c2, c3, c&#x3D; &#39;silver&#39;)</span><br><span class="line">figure &#x3D; ax.plot(d1, d2, d3, c&#x3D; &#39;silver&#39;)</span><br><span class="line">figure &#x3D; ax.plot(e1, e2, e3, c&#x3D; &#39;silver&#39;)</span><br><span class="line">figure &#x3D; ax.plot(f1, f2, f3, c&#x3D; &#39;silver&#39;)</span><br><span class="line">figure &#x3D; ax.plot(g1, g2, g3, c&#x3D; &#39;silver&#39;)</span><br><span class="line">figure &#x3D; ax.plot(h1, h2, h3, c&#x3D; &#39;silver&#39;)</span><br><span class="line">figure &#x3D; ax.plot(i1, i2, i3, c&#x3D; &#39;silver&#39;)</span><br><span class="line">figure &#x3D; ax.plot(j1, j2, j3, c&#x3D; &#39;silver&#39;)</span><br><span class="line"></span><br><span class="line">for i in range(len(a1)): </span><br><span class="line">    ax.text(a1[i],a2[i],a3[i],i,color&#x3D;&#39;r&#39;) </span><br><span class="line"></span><br><span class="line">plt.xticks([])</span><br><span class="line">plt.yticks([])</span><br><span class="line">plt.axis(&#39;off&#39;)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p><img src="/images/Python-matplotlib-drawing/Four-dimensional-space.png"></p>
<p>在此，已经超出了我们的经验范围，打开脑洞，充分想象，<strong>他是一个被五个三维四面体包围的四维超四面体</strong>。其中的虚线代表我们无论如何旋转，都看不见，而四维生物旋转之后能看见的那条菱。</p>
<p><img src="/images/Python-matplotlib-drawing/Four-dimensional-space1.png"></p>
<p><img src="/images/Python-matplotlib-drawing/Four-dimensional-space2.png"></p>
<p>直接看，他其实是一个六面体，一个四维的三维投影。</p>
<p><strong>Game over！</strong></p>
<p><em>注：初学 Python 和 matplotlib，只能用代码堆叠来实现，见谅。</em></p>
]]></content>
      <categories>
        <category>原理原则</category>
      </categories>
      <tags>
        <tag>四维空间</tag>
      </tags>
  </entry>
  <entry>
    <title>黄金分割</title>
    <url>/principle/Fibonacci-sequence-golden-section-8a231ce05614/</url>
    <content><![CDATA[<p>用 Python 生成100以内的斐波那契数列：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">n = <span class="number">100</span></span><br><span class="line">a, b = <span class="number">0</span>, <span class="number">1</span></span><br><span class="line"><span class="keyword">while</span> a &lt; n:</span><br><span class="line">    print(a, end=<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">    a, b = b, a+b</span><br><span class="line">print()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>0 1 1 2 3 5 8 13 21 34 55 89</strong></p>
</blockquote>
<blockquote>
<p><strong>这个数列的特点是：相邻两项之和等于后一项；除了前三项之外，后一项与前一项之比接近黄金分割比例 1.618 。</strong></p>
</blockquote>
<p>以这个数列中的数为边长的正方形，拼成的矩形为近似黄金矩形：</p>
<p><img src="/images/Fibonacci-sequence-golden-section/hj03.jpg"></p>
<br>

<blockquote>
<p><strong>黄金分割：将一条线段分成两段，全长与其中一部分的比等于这部分与另一部分的比，比值约为 1.618 。</strong></p>
</blockquote>
<p><img src="/images/Fibonacci-sequence-golden-section/hj01.jpg"></p>
<br>

<p>看看美丽的五角星：</p>
<p><img src="/images/Fibonacci-sequence-golden-section/hj02.jpg"></p>
<p>它的每条边都是按照黄金比例分割的，内接五角星之后，内嵌五角星的每条边以及每条边被分割的线段，与外接五角星被分割的线段存在多个黄金比例。</p>
<p>一个比较有意思的数学题：20 棵树栽 20 排，每排栽四棵。所得到的解，正好是上图，请自己数数，很有意思。</p>
<br>

<p>在视觉感受上，符合黄金分割比例的图像或立体事物，有着深刻的和谐和变化内涵。和谐在相似，重复，联系之中；变化在运动和活力之中，而这些性质恰好是分形的特点。关于分形，可以看看 ‘<strong>科学大院</strong>‘ 的五集连播，非常震撼：</p>
<p><a href="https://mp.weixin.qq.com/s/8KDKDM-xQRX3uLgTjplKug">混沌与分形（一）：命运无常，是天意还是混沌的力量？</a></p>
<p><a href="https://mp.weixin.qq.com/s/Q-HFrtsuDaQ9JYFHwlnIww">混沌与分形（二）：分形的奇迹——分数维的曲线</a></p>
<p><a href="https://mp.weixin.qq.com/s/sVIhgN7vLeomccERbc__Lg">混沌与分形（三）：人体竟是分形的杰作？！</a></p>
<p><a href="https://mp.weixin.qq.com/s/qhAFg5w7MI1JEhrUzfuOIA">混沌与分形（四）：分形是天使，混沌是魔鬼？</a></p>
<p><a href="https://mp.weixin.qq.com/s/cYtbfnVVyNixpSx0-9hXfQ">混沌与分形（大结局）：未来，一切皆有可能</a></p>
<br>

<p>大自然真是妙不可言，而这妙不可言的背后的价值认同，是植根在我们身体和灵魂中的和谐和变化规律。</p>
]]></content>
      <categories>
        <category>原理原则</category>
      </categories>
      <tags>
        <tag>黄金分割</tag>
      </tags>
  </entry>
  <entry>
    <title>百分之三十七原则--选择的策略</title>
    <url>/principle/37percent-principle-72142339141f/</url>
    <content><![CDATA[<p>生活中处处面临选择, 买车, 买房, 买股票, 选对象, 找工作…. 怎样做才能最大概率选到最好的？</p>
<p>面对纷繁复杂的选择, 我们通常凭直觉，结果总是不尽人意，造成较大损失, 甚至可能耽误一辈子，然而我们看看在数学家的眼里, 怎样做才是最佳的选择策略：</p>
<blockquote>
<p><strong>在尽可能多的选择对象中，你不必急于做出选择，前面 37% 的选择对象中，你只需要观察，在 37% 之后，一旦遇到比之前最好的还要好的，或者与之前最好的接近的，就选它。</strong></p>
</blockquote>
<hr>
<p>证明过程如下:</p>
<p>假设有 x 个选择对象, 只能选一个, 而且不能回头。</p>
<p><strong>那么我们先观察 [1, y] 的对象, 在 [y+1, x] 中做选择。</strong></p>
<p>再设最好的对象为 A ，然后我们分三种情况来讨论：</p>
<ol>
<li><p>如果 A ∈ [1, y] , 因为我们从 [y+1, x] 中做选择，你会错过A，但是按照上述的选择策略，你会选到接近 A 的 。</p>
</li>
<li><p>如果 A = y+1 , 你直接就选到了最好的 A 。</p>
</li>
<li><p>如果 A ∈ [y+2, x] , 你可能选到 A , 也可能选不到, 但是按照上述的选择策略，你做出的选择，最差也是比前面 y/x 的对象中最好的还要好的。</p>
</li>
</ol>
<br>

<p>第一种情况我们错过了 A , 第二种情况直接选到了 A , 下面我们来看第三种情况, 只需要计算 y/x 等于多少时， 选到 A 的概率最大：</p>
<p>设 A 的位置为 t , 而 A 在 [1, x] 中随机分布, 故 A 在该位置的概率为 1/x .</p>
<p>再设在 [1, t-1] 中最好的那个对象为 B , 要使 A 被选中, 则 B 必然在 [1, y] 中, 如图:</p>
<p><img src="/images/37percent-principle/371.jpg"></p>
<p>这个概率为</p>
<p>$$P_{t}=\frac{1}{x} \frac{y}{t-1}$$</p>
<p>由于 A ∈ [y+1, x] , 把上式从 y+1 到 x 累加得</p>
<p>$$P=\sum_{t=y+1}^{x} \frac{1}{x} \frac{y}{t-1}=\frac{y}{x} \sum_{t=y+1}^{x} \frac{1}{t-1}=\frac{y}{x} \sum_{t=y}^{x-1} \frac{1}{t}$$</p>
<p>假设 x 足够大, 则</p>
<p>$$P=\frac{y}{x} \sum_{t=y}^{x-1} \frac{1}{t} \approx \frac{y}{x} \int_{y}^{x} \frac{1}{t} d t=\frac{y}{x}(\ln x-\ln y)=\frac{\ln x}{x} \cdot y-\frac{1}{x} \cdot y \ln y$$</p>
<p>求导得</p>
<p>$$P^{\prime}=\frac{\ln x}{x}-\frac{1}{x}(\ln y+1)$$</p>
<p>令P’ = 0 , 此时概率 P 最大, 可得</p>
<p>$$\frac{y}{x}=\frac{1}{e}=0.367879 \ldots$$</p>
<p>综上可得，y/x ≈ 37% 而此式包含的全部含义是：</p>
<blockquote>
<p><strong>x 个选择对象,在做选择时, 前面大约 37% 的对象你只需要观察, 从 37% 之后开始做选择, 一旦遇到比之前最好的还要好的，或者与之前最好的接近的，就选它，这样做了，你能最大概率选到最好的 A ，就算选不到 A ，至少也是最接近 A 的。</strong></p>
</blockquote>
<p>数学真的很奇妙, 它支撑着整个科学大厦, 孕育了智能社会, 还能优化人生方向.</p>
]]></content>
      <categories>
        <category>原理原则</category>
      </categories>
      <tags>
        <tag>原则原理</tag>
      </tags>
  </entry>
  <entry>
    <title>实用 Markdown 语法汇总</title>
    <url>/Markdown-d39685381dd6/</url>
    <content><![CDATA[<p><a href="https://billwuhao.com/2020/08/08/zhuye/#more" title="诗和远方都在脚下"><img src="/images/dbj.jpg"></a></p>
<blockquote>
<p>Markdown , 兼容 HTML，易读易写的轻量级网络标记语言, 注重内容和简洁的排版, 不用担心部署和移植的问题。</p>
</blockquote>
<h2 id="一-段落-换行-空行等"><a href="#一-段落-换行-空行等" class="headerlink" title="一. 段落, 换行,空行等"></a>一. 段落, 换行,空行等</h2><h3 id="1，段落"><a href="#1，段落" class="headerlink" title="1，段落"></a>1，段落</h3><p>段落之间使用空行隔开</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">第一段落</span><br><span class="line"></span><br><span class="line">第二段落</span><br></pre></td></tr></table></figure>

<p>第一段落</p>
<p>第二段落</p>
<h3 id="2，换行"><a href="#2，换行" class="headerlink" title="2，换行"></a>2，换行</h3><p>在需要换行处多敲两个空格来实现</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">第一行（接两个空格）  </span><br><span class="line">第二行</span><br></pre></td></tr></table></figure>

<p>第一行<br>第二行</p>
<h3 id="3，插入空行"><a href="#3，插入空行" class="headerlink" title="3，插入空行"></a>3，插入空行</h3><p>使用两个空行中加入一个<code>&lt;br&gt;</code>独占一行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">段落</span><br><span class="line"></span><br><span class="line">&lt;br&gt;</span><br><span class="line"></span><br><span class="line">段落</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>段落</p>
<br>

<p>段落</p>
<h3 id="4，插入分隔符"><a href="#4，插入分隔符" class="headerlink" title="4，插入分隔符"></a>4，插入分隔符</h3><p><code>***</code>、<code>---</code>或者<code>___</code> 独占一行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">---</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="5，插入空格或特殊符号"><a href="#5，插入空格或特殊符号" class="headerlink" title="5，插入空格或特殊符号"></a>5，插入空格或特殊符号</h3><p>插入空格或特殊符号，需要 HTML 字符实体语言，例如：</p>
<p><code>&amp;#32;</code>为半角空格<code> </code>，<code>&amp;#12288;</code>为全角空格&#12288;，<code>&amp;#12539;</code>为全角分隔号<code>・</code>，等等。</p>
<br>

<h2 id="二-标题-列表-引用与代码块"><a href="#二-标题-列表-引用与代码块" class="headerlink" title="二. 标题, 列表, 引用与代码块"></a>二. 标题, 列表, 引用与代码块</h2><h3 id="1，标题"><a href="#1，标题" class="headerlink" title="1，标题"></a>1，标题</h3><p><code>#</code>后面跟一个空格接着写文本即是标题</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 标题1</span><br><span class="line">## 标题2</span><br><span class="line">### 标题3</span><br></pre></td></tr></table></figure>

<h3 id="2，列表"><a href="#2，列表" class="headerlink" title="2，列表"></a>2，列表</h3><p><code>1.</code>、<code>*</code>、<code>+</code>或者<code>-</code>后面跟一个空格在文字前生成</p>
<p>a. 有序列表:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. 第一列</span><br><span class="line">2. 第二列</span><br><span class="line">3. 第三列</span><br></pre></td></tr></table></figure>
<ol>
<li>第一列</li>
<li>第二列</li>
<li>第三列</li>
</ol>
<p>b. 无序列表:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- 第一列</span><br><span class="line">* 第二列</span><br><span class="line">+ 第三列</span><br></pre></td></tr></table></figure>

<ul>
<li>第一列</li>
</ul>
<ul>
<li>第二列</li>
</ul>
<ul>
<li>第三列</li>
</ul>
<p>c. 嵌套列表:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. 第一章</span><br><span class="line">   1. 1-1</span><br><span class="line">   2. 1-2</span><br><span class="line">2. 第二章</span><br><span class="line">   * 2-1</span><br><span class="line">   * 2-2</span><br></pre></td></tr></table></figure>

<ol>
<li>第一章<ol>
<li>1-1</li>
<li>1-2</li>
</ol>
</li>
<li>第二章<ul>
<li>2-1</li>
<li>2-2</li>
</ul>
</li>
</ol>
<h3 id="3，引用"><a href="#3，引用" class="headerlink" title="3，引用"></a>3，引用</h3><p><code>&gt;</code> 符号后的内容表现为引用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;这里划重点......</span><br><span class="line"></span><br><span class="line">&gt;这里是重点    </span><br><span class="line">这里还是重点</span><br><span class="line"></span><br><span class="line">&gt;&gt;多个 &gt; 符号也可以...</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这里划重点……</p>
</blockquote>
<blockquote>
<p>这里还重点<br>这里还是重点</p>
</blockquote>
<blockquote>
<blockquote>
<p>多个 &gt; 符号也可以…</p>
</blockquote>
</blockquote>
<br>

<h3 id="4，代码块"><a href="#4，代码块" class="headerlink" title="4，代码块"></a>4，代码块</h3><p>a. 文字中代码用``来插入，例如 <code>print(&#39;hello, world.&#39;)</code> ，` 是Tab键上边，数字 1 键左侧的那个</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">例如 &#96;print(&#39;hello, world.&#39;)&#96; , </span><br></pre></td></tr></table></figure>

<p>b. 代码块用一组```来插入, 例如:  </p>
<p>```<br>love = ‘就多多抱抱我’<br>if ‘你爱我’ &gt; ‘0’:<br>&nbsp;&nbsp;&nbsp;&nbsp;print(love)<br>```</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">love &#x3D; &#39;就多多抱抱我&#39;</span><br><span class="line">if &#39;你爱我&#39; &gt; &#39;0&#39;:</span><br><span class="line">    print(love)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>还可以另起段落直接缩进四个空格成为代码块，例如：</p>
<pre><code># 这里是代码块
love = &#39;就多多抱抱我&#39;
if &#39;你爱我&#39; &gt; &#39;0&#39;:
    print(love)</code></pre>
<p>c. 代码高亮显示, 在第一组```后面加上代码的相应语言, 例如:  </p>
<p>```Python<br>love = ‘就多多抱抱我’<br>if ‘你爱我’ &gt; ‘0’:<br>&nbsp;&nbsp;&nbsp;&nbsp;print(love)<br>```</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">love = <span class="string">&#x27;就多多抱抱我&#x27;</span></span><br><span class="line"><span class="keyword">if</span> <span class="string">&#x27;你爱我&#x27;</span> &gt; <span class="string">&#x27;0&#x27;</span>:</span><br><span class="line">    print(love)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<br>

<h2 id="三-超链接与插入图片"><a href="#三-超链接与插入图片" class="headerlink" title="三. 超链接与插入图片"></a>三. 超链接与插入图片</h2><h3 id="1，超链接"><a href="#1，超链接" class="headerlink" title="1，超链接"></a>1，超链接</h3><p>用<code>[]()</code>建立, 例如:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[超链接](网址)</span><br></pre></td></tr></table></figure>

<p><a href="%E7%BD%91%E5%9D%80">超链接</a></p>
<h3 id="2，插入图片"><a href="#2，插入图片" class="headerlink" title="2，插入图片"></a>2，插入图片</h3><p>用<code>![]()</code>建立, 例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">![](https:&#x2F;&#x2F;ss1.bdstatic.com&#x2F;70cFuXSh_Q1YnxGkpoWK1HF6hhy&#x2F;it&#x2F;u&#x3D;1079881694,817470207&amp;fm&#x3D;200&amp;gp&#x3D;0.jpg)</span><br></pre></td></tr></table></figure>

<p><img src="https://ss1.bdstatic.com/70cFuXSh_Q1YnxGkpoWK1HF6hhy/it/u=1079881694,817470207&fm=200&gp=0.jpg"></p>
<h3 id="3，图片作为超链接"><a href="#3，图片作为超链接" class="headerlink" title="3，图片作为超链接"></a>3，图片作为超链接</h3><p>用<code>[![]()]()</code>建立，其实就是在超链接语法里嵌套图片链接语法</p>
<br>

<h2 id="四-表格与科学表达式"><a href="#四-表格与科学表达式" class="headerlink" title="四. 表格与科学表达式"></a>四. 表格与科学表达式</h2><h3 id="1，插入表格，"><a href="#1，插入表格，" class="headerlink" title="1，插入表格，"></a>1，插入表格，</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">自动|右对齐|居中|左对齐</span><br><span class="line">0  |---: | :---: | :---  </span><br><span class="line">0  |1    |2      |3</span><br><span class="line">0  |1    |2      |3</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>自动</th>
<th align="right">右对齐</th>
<th align="center">居中</th>
<th align="left">左对齐</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td align="right">1</td>
<td align="center">2</td>
<td align="left">3</td>
</tr>
<tr>
<td>0</td>
<td align="right">1</td>
<td align="center">2</td>
<td align="left">3</td>
</tr>
</tbody></table>
<p>推荐神器，将表格转为各种格式：<a href="https://tableconvert.com/">https://tableconvert.com/</a>，省时省力。</p>
<h3 id="2，科学表达式"><a href="#2，科学表达式" class="headerlink" title="2，科学表达式"></a>2，科学表达式</h3><p>输入 LaTeX 语法的表达式，可以通过相应的插件渲染成为相应的公式：</p>
<p>a，数学式</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$$</span><br><span class="line">H(Y | X)&#x3D;\sum_&#123;x \in \mathcal&#123;X&#125;, y \in \mathcal&#123;Y&#125;&#125; p(x, y) \log \left(\frac&#123;p(x)&#125;&#123;p(x, y)&#125;\right)</span><br><span class="line">$$</span><br><span class="line"></span><br><span class="line">$$</span><br><span class="line">f(x)&#x3D;\frac&#123;1&#125;&#123;\sqrt&#123;2 \pi \sigma x&#125;&#125; e^&#123;-\frac&#123;(x-\mu)^&#123;2&#125;&#125;&#123;2 \sigma^&#123;2&#125;&#125;&#125;</span><br><span class="line">$$</span><br></pre></td></tr></table></figure>
<p>$$<br>H(Y | X)=\sum_{x \in \mathcal{X}, y \in \mathcal{Y}} p(x, y) \log \left(\frac{p(x)}{p(x, y)}\right)<br>$$</p>
<p>$$<br>f(x)=\frac{1}{\sqrt{2 \pi \sigma x}} e^{-\frac{(x-\mu)^{2}}{2 \sigma^{2}}}<br>$$</p>
<p>b，化学式</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$$</span><br><span class="line">4 \mathrm&#123;Al&#125;(\mathrm&#123;Hg&#125;)+3 \mathrm&#123;O&#125;_&#123;2&#125;+2 \times \mathrm&#123;H&#125;_&#123;2&#125; \mathrm&#123;O&#125;&#x3D;2\left(\mathrm&#123;Al&#125;_&#123;2&#125; \mathrm&#123;O&#125;_&#123;3&#125; \cdot \mathrm&#123;xH&#125;_&#123;2&#125; \mathrm&#123;O&#125;\right)+4 \mathrm&#123;Hg&#125;</span><br><span class="line">$$</span><br></pre></td></tr></table></figure>

<p>$$<br>4 \mathrm{Al}(\mathrm{Hg})+3 \mathrm{O}<em>{2}+2 \times \mathrm{H}</em>{2} \mathrm{O}=2\left(\mathrm{Al}<em>{2} \mathrm{O}</em>{3} \cdot \mathrm{xH}_{2} \mathrm{O}\right)+4 \mathrm{Hg}<br>$$</p>
<p>c，物理式</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$$</span><br><span class="line">\vec&#123;E&#125;&#x3D;\frac&#123;1&#125;&#123;4 \pi \varepsilon&#125; \int \frac&#123;d q&#125;&#123;r^&#123;2&#125;&#125; \hat&#123;r&#125;, \quad U&#x3D;\frac&#123;1&#125;&#123;4 \pi \varepsilon&#125; \int \frac&#123;d q&#125;&#123;r&#125;, \quad\left(U_&#123;\infty&#125;&#x3D;0\right), \quad \vec&#123;B&#125;&#x3D;\frac&#123;\mu&#125;&#123;4 \pi&#125; \frac&#123;q \vec&#123;v&#125; \times \hat&#123;\vec&#123;r&#125;&#125;&#125;&#123;r^&#123;2&#125;&#125;</span><br><span class="line">$$</span><br></pre></td></tr></table></figure>
<p>$$<br>\vec{E}=\frac{1}{4 \pi \varepsilon} \int \frac{d q}{r^{2}} \hat{r}, \quad U=\frac{1}{4 \pi \varepsilon} \int \frac{d q}{r}, \quad\left(U_{\infty}=0\right), \quad \vec{B}=\frac{\mu}{4 \pi} \frac{q \vec{v} \times \hat{\vec{r}}}{r^{2}}<br>$$</p>
<p>推荐一个神器可以将图片转为文本公式，甚至是手写的：<a href="https://mathpix.com/">https://mathpix.com/</a></p>
<br>

<h2 id="五-其他常用语法"><a href="#五-其他常用语法" class="headerlink" title="五. 其他常用语法"></a>五. 其他常用语法</h2><h3 id="1，斜体-加粗和下划线"><a href="#1，斜体-加粗和下划线" class="headerlink" title="1，斜体, 加粗和下划线"></a>1，斜体, 加粗和下划线</h3><p>斜体用<code>*</code>包含文字, 加粗字体用<code>**</code>包含文字, 下划线用<code>&lt;u&gt;&lt;/u&gt;</code>包含文字，删除用<code>~~</code>包含文字。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">*斜体*, **加粗**, &lt;u&gt;下划线&lt;&#x2F;u&gt;，~~删除~~</span><br></pre></td></tr></table></figure>

<p><em>斜体</em>, <strong>加粗</strong>, <u>下划线</u>，<del>删除</del></p>
<p>如果就想显示字符，可用转义字符<code>\</code>进行转义，例如：<code>\*\*加粗\*\*</code>，显示为 **加粗**</p>
<h3 id="2，设置字体等"><a href="#2，设置字体等" class="headerlink" title="2，设置字体等"></a>2，设置字体等</h3><p>因为支持 HTML 语法，更多高级功能查看 HTML 语法。HTML 颜色代码查询：<a href="https://html-color-codes.info/chinese/">https://html-color-codes.info/chinese/</a></p>
<p>大字蓝色居中：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;font color&#x3D;#0080FF size&#x3D;7 face&#x3D;&quot;黑体&quot;&gt;&lt;center&gt;欢迎来到我的博客&lt;&#x2F;center&gt;&lt;&#x2F;font&gt;</span><br></pre></td></tr></table></figure>
<p><font color=#0080FF size=7 face="黑体"><center>欢迎来到我的博客</center></font></p>
<p>红色靠左</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;font color&#x3D;#ff0000 &gt;&lt;p align&#x3D;&quot;left&quot;&gt;24时时时学习, 365天天天进步&lt;&#x2F;p&gt;&lt;&#x2F;font&gt;</span><br></pre></td></tr></table></figure>

<p><font color=#ff0000 ><p align="left">24时时时学习, 365天天天进步</p></font></p>
<p>小字靠右</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;font size&#x3D;3&gt;&lt;p align&#x3D;&quot;right&quot;&gt;2019年4月12日&lt;&#x2F;p&gt;&lt;&#x2F;font&gt;</span><br></pre></td></tr></table></figure>

<p><font size=3><p align="right">2019年4月12日</p></font></p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>markdown</tag>
      </tags>
  </entry>
</search>
